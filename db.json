{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/icp.png","path":"img/icp.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/0.jpg","path":"img/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/1.jpg","path":"img/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/2.jpg","path":"img/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/3.jpg","path":"img/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/4.jpg","path":"img/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/5.jpg","path":"img/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/banner/6.jpg","path":"img/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"bada5c0bab29eb49af93c7643fe0cf553c89e758","modified":1603332778114},{"_id":"source/CNAME","hash":"ff74ab460003c974a47eb2387a2e45399e67a171","modified":1603332778114},{"_id":"source/about/index.md","hash":"2c534baa609c5626ef3bdbd8dfa615aee4c1e63f","modified":1603332778120},{"_id":"source/_posts/Java集合.md","hash":"c0c9d74af34d8976fd7e6ca0404fef7a5b26f8af","modified":1603332778115},{"_id":"source/_posts/Kebernets 进行集群部署.md","hash":"e4e95821528ac2e970fe22c99398326e72347ce2","modified":1603332778115},{"_id":"source/_posts/LC周赛-2019-09-15.md","hash":"cd9457eb2b2552f45f26e5993cfb08c41270c837","modified":1603332778116},{"_id":"source/_posts/Redis-基本数据结构.md","hash":"68630eb87552a4b42a969b7732e4d16fbcf64fa9","modified":1603332778116},{"_id":"source/_posts/TCP-IP-阅读笔记-1.md","hash":"167cfd7cdf5b632363c421c0ce36ddf800f7530f","modified":1603332778116},{"_id":"source/_posts/TCP-IP-阅读笔记-2 加密.md","hash":"99a2bc5d1db7edf4b2d194cb2ab34200e40a5c00","modified":1603332778117},{"_id":"source/_posts/c-新特性.md","hash":"39d645af1e5edaacc6bc28454973669126adcb9f","modified":1603332778117},{"_id":"source/_posts/cmake学习笔记.md","hash":"ff0dcdd71df6a2c425bc2f07ec3036ea83c6be31","modified":1603332778117},{"_id":"source/_posts/leetcode-周赛20191005.md","hash":"40e0150f97ed76c16e6e5fe056faa5b8216bc8e0","modified":1603332778118},{"_id":"source/_posts/初探Anna.md","hash":"582e334d246e47ee8d9e3e8cf67b9de7cc0ee336","modified":1603332778118},{"_id":"source/_posts/数据库整理-索引.md","hash":"247eacec5d3f0f51f20a78ff658e7103a5d7fce8","modified":1603332778118},{"_id":"source/_posts/杂谈-鸡血帖.md","hash":"e60766cb6682197f4c9f494290bab32370a66415","modified":1603332778119},{"_id":"source/_posts/聊一聊一致性话题.md","hash":"b1830fad8941b79c1d2987340233e2722b5a2f69","modified":1608450615982},{"_id":"source/_posts/背包问题.md","hash":"19b41f14a2e2543eb0b904bf7175f17699d15e70","modified":1603332778119},{"_id":"source/_posts/让我们实现一些负载均衡算法.md","hash":"8f9ac6a3b1a6f9cc7fa22c802a3efd8a480ecb20","modified":1603332778120},{"_id":"source/_posts/设计模式-单例.md","hash":"c3f25f399c288fd8a223b95ac17f79af57ecacff","modified":1603332778120},{"_id":"source/contact/index.md","hash":"25b2824eaa36964954a760f056f15fba8ef46dde","modified":1603332778121},{"_id":"source/categories/index.md","hash":"406e8056606b737006aa0a3d501adfe6f24d3554","modified":1603332778121},{"_id":"source/tags/index.md","hash":"5fd023d29a245b254d11512bd2f9e06fd35b094e","modified":1603332778121},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1603332778132},{"_id":"themes/butterfly/README.md","hash":"a11128da336eca89c228ed101c9066547caa01de","modified":1603332778132},{"_id":"themes/butterfly/_config.yml","hash":"ec3eb170c3e9d2938b5395a66f19bc664d69cfa6","modified":1603333712573},{"_id":"themes/butterfly/README_CN.md","hash":"467fe8167b270521fb092b7a24f101333358105e","modified":1603332778132},{"_id":"themes/butterfly/package.json","hash":"a26bcdac000622967bc371865b9441b4e6a412d5","modified":1603332778160},{"_id":"themes/butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1603332778132},{"_id":"themes/butterfly/languages/default.yml","hash":"74609a7cb02eac9f654798c09585d2c0166474ce","modified":1603332778133},{"_id":"themes/butterfly/languages/en.yml","hash":"74609a7cb02eac9f654798c09585d2c0166474ce","modified":1603332778133},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"8725226dcb5b1b6d103a96f3f70e7f0c6328a41e","modified":1603332778133},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"26214b3a3ee4958df5be46d098624d6105fe6bc2","modified":1603332778134},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1603332778134},{"_id":"themes/butterfly/layout/404.pug","hash":"0542b16d04c16f6bd2b86e83dba5676862a1d800","modified":1603332778134},{"_id":"themes/butterfly/layout/category.pug","hash":"d014234c26d2c07caaea6703f7b48cb69c51907d","modified":1603332778134},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1603332778159},{"_id":"themes/butterfly/layout/page.pug","hash":"d5063ec93d33bd8488c12007709b6aafd8b9cf5f","modified":1603332778159},{"_id":"themes/butterfly/layout/post.pug","hash":"720237fc7ec0d4f9e66892311063cdcd552ea04f","modified":1603332778159},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1603332778159},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"01879e11e7fd1b1c98fb44c2b63c056af3d10415","modified":1603332778131},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1603332778131},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1603332778131},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"68bde1db513958ed1c23cd83f6dd844a85935cb6","modified":1603332778135},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"d37e3113e3eecf99f302d3fa0305b4ed5aaa3732","modified":1603332778135},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"45aadf2e0fdc0c17b19156b31457cd45e7248ce0","modified":1603332778135},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"0ac6564d7b2729a77abc78d0df89431bc2fb0432","modified":1603332778140},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"79ef449c5e04d0ecb4b9980d419ecbaf3d54d35a","modified":1603332778143},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"a9645f8c48d69eb31b6f8ef1f8d151d4b165ee0d","modified":1603332778144},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"c10836fd167c0401bf16ae2a1604c85462241ba2","modified":1603332778144},{"_id":"themes/butterfly/scripts/events/404.js","hash":"3c30dbd8b910ce7d8d7d8353cf2266cbc5d8775d","modified":1603332778160},{"_id":"themes/butterfly/scripts/events/check_hexo.js","hash":"15c58a4cb86f64581f71c37d9f2e1395e22a52bf","modified":1603332778160},{"_id":"themes/butterfly/scripts/events/replace_config.js","hash":"cdb4f462bceb155f59b98cd705efadbdc1fb5309","modified":1603332778161},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1603332778161},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"e9cf275c362d8634f093e63068da7ed1e53c7600","modified":1603332778161},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"55350958668e27a47070e5db50e4d2ff382e552b","modified":1603332778161},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"f30b0c108474b2869b35ee70dbc6ed2f2066979d","modified":1603332778162},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"ff79813afbaabd16188e7dbd435fe52273956c85","modified":1603332778162},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"e4461cedecb0d9fe7434cda8436e98d3f3a63159","modified":1603332778162},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"34e8fecbd6cc21470ba1381af65a12f59fa59d3e","modified":1603332778163},{"_id":"themes/butterfly/scripts/tags/button.js","hash":"e75283267f3a4773e6d803593d557e218396f260","modified":1603332778163},{"_id":"themes/butterfly/scripts/tags/gallery.js","hash":"77e657eb74a7718b7e11e04284827e4a85805b86","modified":1603332778163},{"_id":"themes/butterfly/scripts/tags/hide.js","hash":"ea5939e3d5b3d3106527093a4fe0adaaf1fef2f8","modified":1603332778164},{"_id":"themes/butterfly/scripts/tags/mermaid.js","hash":"f358a6a5b7979290263e5b02766d0b9449e60841","modified":1603332778164},{"_id":"themes/butterfly/scripts/tags/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1603332778164},{"_id":"themes/butterfly/scripts/tags/tabs.js","hash":"1f3bff5bbab30bb103e256ea6fb5b71a1bfe6dc1","modified":1603332778164},{"_id":"themes/butterfly/source/css/index.styl","hash":"d02ea8b8451513df5245151870195973709f25f2","modified":1603332778174},{"_id":"themes/butterfly/source/css/var.styl","hash":"6cc0c49e75e7384245a699914a74ccfe2ee0642c","modified":1603332778174},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1603332778175},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1603332778175},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1603332778179},{"_id":"themes/butterfly/source/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1603332778179},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1603332778179},{"_id":"themes/butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1603332778179},{"_id":"themes/butterfly/source/js/main.js","hash":"6d21e93b56da9b749d517bf61ebbf08d89d0ab7a","modified":1603332778180},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"2eafc44f4a5b24bef836b00dfc4360a84edb8dcc","modified":1603332778180},{"_id":"themes/butterfly/source/js/utils.js","hash":"f24426cd3c20057ecf46a872f748bece3fb9653a","modified":1603332778180},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"5390f2aea030486bf78678b910bda177b0ba5d05","modified":1603332778136},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"afb58249ddd121e5a8cf5d289fe215e15b90b82a","modified":1603332778136},{"_id":"themes/butterfly/layout/includes/head/aplayer.pug","hash":"b24959f00ac75f12f66b445158aad143ee860795","modified":1603332778136},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"345a957d9044e83c3440c610b6d31b7e8ecd9adf","modified":1603332778136},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"8df13e06cdfff76003e0c5e77ff309091027a766","modified":1603332778137},{"_id":"themes/butterfly/layout/includes/head/darkmode.pug","hash":"6f7cbc741e3c00a5321e1aa762a85d68d9ba6a85","modified":1603332778137},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1603332778137},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1603332778137},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"0fdf2a14f9ae498a6ca0de4409926001d4fb8b01","modified":1603332778137},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1603332778137},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"62cf37e28795d8b68a0e850ec8c94987b9e08db5","modified":1603332778138},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"ffd3f8147286902ea3992c4a3f83ef66cc4a362b","modified":1603332778138},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"14cd0f9c0c578512896b487263cd48570d74771a","modified":1603332778138},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"da07d43d31dddc37cc1ac9766df86345bcefcdff","modified":1603332778139},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"26f1955e89894dfb54573e616880ab6fad878f2d","modified":1603332778139},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1603332778139},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"7ffcf93bc5ee95ca461aea2735cedc0785c9884d","modified":1603332778140},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1603332778140},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"68dfd3c6a0f00b3ffc0333c81e165b4626f7425f","modified":1603332778141},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"2a1201ad33033f6ff0748e37d0f31ed43eca0b9b","modified":1603332778141},{"_id":"themes/butterfly/layout/includes/mobile-sidebar/index.pug","hash":"d12fab033fb32b55abbc9be9b04cc6ab6465b98e","modified":1603332778141},{"_id":"themes/butterfly/layout/includes/mobile-sidebar/mobile-menus.pug","hash":"b13d95c53c5031e6305ec1fe83d6758f52fa96ee","modified":1603332778142},{"_id":"themes/butterfly/layout/includes/page/artitalk.pug","hash":"46bc194907f481a3a5dec1bb36b30ccf953e1970","modified":1603332778142},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":1603332778142},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"41642902aa1bb65a81257c82ebd2584678598c03","modified":1603332778143},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"da24e13ca15a376373fa3bae65f2bfb02f881b87","modified":1603332778143},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":1603332778143},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1603332778144},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"bab59f87da66386e5abc84550614752c660a0705","modified":1603332778144},{"_id":"themes/butterfly/layout/includes/third-party/artitalk.pug","hash":"11f5227d3518bc91a85fdbd650a381aedfc10fe5","modified":1603332778145},{"_id":"themes/butterfly/layout/includes/third-party/baidu_push.pug","hash":"a3552fb4d969f72af0d1b099201faac1236e01d9","modified":1603332778145},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"29b851208aba27b62cae45b17d18c2237c278292","modified":1603332778150},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"abce595b5b8887577af07a8e2644fd76d2443556","modified":1603332778152},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"c81c2fef5f5606a1236cd24b6aa5bcf0e8a12594","modified":1603332778153},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1603332778153},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"907636bda4cbf9ca6f4e943bb49f18c282f2786f","modified":1603332778155},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"2e940de1a6261fd378e16e4cd3362a9d69c12f50","modified":1603332778156},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"721b611fda6dcfca8f88b9c7b70fede7b69a516b","modified":1603332778156},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"393a6f9a5dcabe8d96e9b6cb5620c12966dfd37f","modified":1603332778156},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"8af6a22bd598cbb899e3b12bf37ae549f81944a0","modified":1603332778157},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"83cb6ba0d8c913570147b3871c7fc0674dac8cdf","modified":1603332778157},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"b07172d7d11a6bb52e3607e3f434add9001f3e59","modified":1603332778157},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e275297f48503a28792b5c8f9a92492183274f44","modified":1603332778157},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"2b78fb1ed7fa91dc0957d025d2e4561522db4d7a","modified":1603332778158},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"66261dbc6a3ff2c943c9ca829a59126f2d8182ec","modified":1603332778158},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"ce316dc8aba2bf5556b9637124b64ef68ad4c6ad","modified":1603332778158},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"69d55a60c51887486cf578e21885092a2755ae14","modified":1603332778165},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"c705c82c8b12ce10aeedc5f29557606d8fed203c","modified":1603332778165},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"58e6ea2055dedc7808f555c8c7d6dcece7c6d9a5","modified":1603332778166},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":1603332778167},{"_id":"themes/butterfly/source/css/_layout/404.styl","hash":"cd930735151d6a1ac41fb44e2907106417c51caa","modified":1603332778167},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"5f83bb79795782d20d7b90f2d98b097864b4a246","modified":1603332778168},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1603332778168},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"8d5f3fee0a85b47e17f298e7342beb830a0f5297","modified":1603332778168},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"fd825c9d71fcd06a7c882850d1db0e9637f84107","modified":1603332778168},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"cbfbc11e50608af5cad0d418f138f12f95f666a3","modified":1603332778168},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":1603332778169},{"_id":"themes/butterfly/source/css/_layout/mobile-sidebar.styl","hash":"d153816b11eb5f5458ce9ceb41e2bba9a2343fad","modified":1603332778169},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"4ae68b64ea0137427edf095190d0b7a6bf72b4a4","modified":1603332778169},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"49b7e06211053011ef5d3fe40acb6be485161041","modified":1603332778169},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"76d67b9a42e8b0c3d17316a6d75c5b5b4c65fb68","modified":1603332778169},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"7bf7af4754baba07edfc614621bdb965442cdc2f","modified":1603332778170},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"6ea8b4142e7d84ed2c99c7ed36d4066c0b8db42e","modified":1603332778170},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"cf322be6e7e20bfe6993ac76143ffc6d4c52b6d4","modified":1603332778170},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"bfc8aa2c65a281ccd9fb000feb370989771aa161","modified":1603332778170},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"e1a6415356f832d06f6c6be84c05d47ec7eb54eb","modified":1603332778170},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"4a0c674840be2ec8096093d71df0a38b2a3e8314","modified":1603332778171},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":1603332778171},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":1603332778171},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"2893c55238723a824cabbb55b172f08ae5071b31","modified":1603332778171},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"43f00986410f3dc0eed9e0bf9478801da32be24f","modified":1603332778171},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"6f2a1688bf873ab738f73a89e1be8f72e18b2a47","modified":1603332778172},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":1603332778172},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"f718eec64b4586db169f566f403c6e5ad5d2af02","modified":1603332778172},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"89e744abc5e41f4855e7b87b13b854f4ec4ffc0e","modified":1603332778172},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"5e9423070e22df2522dac0a8e8be6f40ecae507a","modified":1603332778172},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"a7fc7624a8d893bdf9444f14154484c29c790e99","modified":1603332778173},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"6e74130e3cc5598d15a2f37fc558cc0086c11c66","modified":1603332778173},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":1603332778173},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"41a92e96c66dececcad050ada2201de196f5f697","modified":1603332778173},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":1603332778174},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":1603332778174},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1603332778174},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"99bc7ef172e9af332d652e92c5ec8b9ec1481434","modified":1603332778180},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"5fc2736b91ddfac0292582af6595a724d33dbd92","modified":1603332778180},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1603332778145},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1603332778146},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1603332778146},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1603332778146},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1603332778147},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1603332778147},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f617cacf5d1e8335abba96ee1ce4b79c17411e1e","modified":1603332778147},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"5e6c64f197a9992acbad385018bad7b74e7b3399","modified":1603332778148},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"b579b947a87da500a4f3abbdf870fb5a6f2a5a79","modified":1603332778148},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"4e6bf11006e4260e85cc02dca330b6c76abd6016","modified":1603332778148},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"71cf3d056b1a11e8a5e2980979af1c6b0248d762","modified":1603332778148},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"a42ee0f5a7f606d752f7b9dd92b6234d991f518d","modified":1603332778149},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1603332778149},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":1603332778149},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"bd613894fe4761898b846abfdec81d544c45eb6a","modified":1603332778150},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"53af4ffa8119c7bbba3f066de74845be91400b5b","modified":1603332778150},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"73356f1068c7426597e268d6c4aefa2b0ac3a1d9","modified":1603332778150},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"b1ae0c11a1ec73273cb55d7e2f9506f038633937","modified":1603332778151},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"1310800bc30b4e1cad93982991041589ee70ffef","modified":1603332778151},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"9cad8dccda6a64938d1dedc85e860514d13c3b4d","modified":1603332778151},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"e529ef34ac60335b21d9fc2cdaa8b1e2b57e665c","modified":1603332778152},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"e67a95ca1034023fd8151ca901eafced8ff50c87","modified":1603332778152},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/leancloud.pug","hash":"c002c905b338fc5ab567ceb0a42284a11638381e","modified":1603332778152},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"debc2e0a4747dc821df9ee99c341230cf20916c2","modified":1603332778153},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1603332778154},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"a623a9b495ff13485d73acc51541085776dd04d2","modified":1603332778154},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1603332778154},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1603332778155},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"c40f7d6973811e53fcfbe881174ab373b4ea03ad","modified":1603332778155},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"368f5f75c506db77e4e1a20c29e9a3e2b4c3d783","modified":1603332778155},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"3bcd66576d13db8f93fa5b799a973d55e060a708","modified":1603332778166},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"13d92a9dbba94fd2cf2608dfffb6e029fa47d2a5","modified":1603332778166},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1603332778167},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"7574576b27d55d2281e67072981a1c3d0ad6a15f","modified":1603332778167},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"d40f1baec16c4a62e4a3a9a0379d1ca3ac6746b2","modified":1603332778167},{"_id":"themes/butterfly/source/img/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1603332778175},{"_id":"themes/butterfly/source/img/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1603332778176},{"_id":"themes/butterfly/source/img/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1603332778177},{"_id":"themes/butterfly/source/img/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1603332778176},{"_id":"themes/butterfly/source/img/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1603332778178},{"_id":"themes/butterfly/source/img/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1603332778179},{"_id":"themes/butterfly/source/img/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1603332778177},{"_id":"public/atom.xml","hash":"538d18a874d08fabfe1f8580916bc957d0b4b97d","modified":1608450812669},{"_id":"public/podcast.xml","hash":"e4e5affc61d165e16f9777fcdad0b008071b77fe","modified":1603335350330},{"_id":"public/search.xml","hash":"f2660d91a696b80751949860544e0a25b45409db","modified":1608450812669},{"_id":"public/about/index.html","hash":"c1fec3a929b1f8240e663c0ff1c28e625e774efd","modified":1611473626920},{"_id":"public/tags/index.html","hash":"c8ea7393fac2ea071cdde8bbae19736c357f18d9","modified":1611473626920},{"_id":"public/categories/index.html","hash":"133949d9f2682ce4c4115a8d91914d29cc07f1c1","modified":1611473626920},{"_id":"public/contact/index.html","hash":"3cf7583b805e51fe23bc4400f633f921dc00870c","modified":1611473626920},{"_id":"public/2020/04/09/liao-yi-liao-yi-zhi-xing-hua-ti/index.html","hash":"0cf26c354a29d191e6dee581d04356b1b2cf0587","modified":1611473626920},{"_id":"public/2020/04/02/rang-wo-men-shi-xian-yi-xie-fu-zai-jun-heng-suan-fa/index.html","hash":"fa020d3abf75af78411f663f1ba6f226a05e929d","modified":1611473626920},{"_id":"public/2020/03/24/redis-ji-ben-shu-ju-jie-gou/index.html","hash":"bf53a8cc6ded212652c784dcea0562ae3b2c88ad","modified":1611473626920},{"_id":"public/2020/03/14/java-ji-he/index.html","hash":"adbf80f680036a33b6691ece089c3b0425f7462f","modified":1611473626920},{"_id":"public/2020/02/18/cmake-xue-xi-bi-ji/index.html","hash":"6723c9dbb0475163862b146ec5cd412a6cb2d98a","modified":1611473626920},{"_id":"public/2020/02/17/tcp-ip-yue-du-bi-ji-2-jia-mi/index.html","hash":"abf062224c9e57bdb43eccab6bc495bb71e8a33b","modified":1611473626920},{"_id":"public/2020/02/17/chu-tan-anna/index.html","hash":"ca6ec0e1aa940150852388bdf9c9dd396b006516","modified":1611473626920},{"_id":"public/2020/01/15/bei-bao-wen-ti/index.html","hash":"f782bef296eaa67d5bf71634430d5997f77f1d5b","modified":1611473626920},{"_id":"public/2020/01/15/c-xin-te-xing/index.html","hash":"a47e1fdf16e26e7af249e9d6260b725350ae1e74","modified":1611473626920},{"_id":"public/2019/12/22/za-tan-ji-xie-tie/index.html","hash":"49ea35c05fc34679bdb084850214fae7f0916aa2","modified":1611473626920},{"_id":"public/2019/12/14/tcp-ip-yue-du-bi-ji-1/index.html","hash":"90c4436ca5a6c0fcbfdfab4f41f780f41e593b1c","modified":1611473626920},{"_id":"public/2019/12/07/she-ji-mo-shi-dan-li/index.html","hash":"dcc9444df0459b907d77245e93cd1166c7acc7db","modified":1611473626920},{"_id":"public/2019/12/05/shu-ju-ku-zheng-li-suo-yin/index.html","hash":"b1722189b44f02e0190f93f4d7af592d863b54e9","modified":1611473626920},{"_id":"public/2019/10/08/leetcode-zhou-sai-20191005/index.html","hash":"8734ca5b17a7407966a480786b720386e53f0d30","modified":1611473626920},{"_id":"public/2019/09/15/lc-zhou-sai-2019-09-15/index.html","hash":"ff634e66eb12744aa3a79fef95fb3ac224359285","modified":1611473626920},{"_id":"public/2019/09/12/kebernets-jin-xing-ji-qun-bu-shu/index.html","hash":"9fd50a3ae04c4b3913a7cdf5c6c4d563617b18dd","modified":1611473626920},{"_id":"public/archives/index.html","hash":"28012b2bb73e5c7de4dc5a1a3c5d00bceae7da77","modified":1611473626920},{"_id":"public/archives/page/2/index.html","hash":"e4beafaa8d18c5a30f5068432e6e2abfd7dbfcdc","modified":1611473626920},{"_id":"public/archives/2019/index.html","hash":"c63e1170a1edf26efaaa5db2361bae03432e5210","modified":1611473626920},{"_id":"public/archives/2019/09/index.html","hash":"b43cf1164a3091a7193ec4faa8a4eade88978c91","modified":1611473626920},{"_id":"public/archives/2019/10/index.html","hash":"ab50fd8243acda8bebf242883b0b8cfdbc9bd0d1","modified":1611473626920},{"_id":"public/archives/2019/12/index.html","hash":"c1423e14a5ff3a5f16d1f03a286a7f06432275ac","modified":1611473626920},{"_id":"public/archives/2020/index.html","hash":"75ef608724958dc9167a6cf9a955eae364adce06","modified":1611473626920},{"_id":"public/archives/2020/01/index.html","hash":"79c51133b3911fcab39cb9434978c93fd3125172","modified":1611473626920},{"_id":"public/archives/2020/02/index.html","hash":"0af1cabac5340ca409f5d0cd7f1a44c17029c0e5","modified":1611473626920},{"_id":"public/archives/2020/03/index.html","hash":"3d5283adcfe0283a843618ac84da2a7836ac4401","modified":1611473626920},{"_id":"public/archives/2020/04/index.html","hash":"42f1057ee37c3faeeea122ffed1b98727ac41854","modified":1611473626920},{"_id":"public/categories/服务/index.html","hash":"8a1a94f285d575392776b6c10246f0cfb6ab5c82","modified":1611473626920},{"_id":"public/categories/算法/index.html","hash":"ee2c9392162a4da6835f1c4f4b6000190816be01","modified":1611473626920},{"_id":"public/categories/笔记/index.html","hash":"4a693a783d96de729a8396a3f55dbf908dc75bab","modified":1611473626920},{"_id":"public/categories/杂谈/index.html","hash":"b32362c129f538e3f2809bf133e30ab8ad084d75","modified":1611473626920},{"_id":"public/index.html","hash":"27039c1f79d30ec4130ff36b5746397f90d79307","modified":1611473626920},{"_id":"public/page/2/index.html","hash":"3e93b020018d1b1ea72b1fcb16b1273d235b345d","modified":1611473626920},{"_id":"public/tags/K8S/index.html","hash":"9cb05f9435496615cebbe8488c5f9040481f6d00","modified":1611473626920},{"_id":"public/tags/competition/index.html","hash":"061eebc2ab81beba7a93219bd712eb8856d4a82b","modified":1611473626920},{"_id":"public/tags/笔记/index.html","hash":"734feeb0796f79b1c2effe65a59d283b6a5a95be","modified":1611473626920},{"_id":"public/tags/读书笔记/index.html","hash":"781c1a0ff1b9ec9e4cd049b2fb4c8741b1267528","modified":1611473626920},{"_id":"public/tags/整理/index.html","hash":"2d1658206d1646a5eac7d792b50a69f8563298a4","modified":1611473626920},{"_id":"public/tags/UpUp/index.html","hash":"960665f149bcccd4f8ab6afa98c5d9f43d9df721","modified":1611473626920},{"_id":"public/tags/算法/index.html","hash":"7c2db1b3982009eba0322a58988185c01aab8ac0","modified":1611473626920},{"_id":"public/tags/coding/index.html","hash":"da54604c4c09f34ed230fa279656fad478f7c085","modified":1611473626920},{"_id":"public/tags/设计模式/index.html","hash":"be717dccd59b404800c6786912aa69597f884fd9","modified":1611473626920},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1603335350330},{"_id":"public/CNAME","hash":"ff74ab460003c974a47eb2387a2e45399e67a171","modified":1603335350330},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1603335350330},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1603335350330},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1603335350330},{"_id":"public/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1603335350330},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1603335350330},{"_id":"public/css/prism-tomorrow.css","hash":"3b99487dfc9b4e51e9105a93743b92a761840e34","modified":1603335350330},{"_id":"public/img/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1603335350330},{"_id":"public/img/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1603335350330},{"_id":"public/img/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1603335350330},{"_id":"public/img/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1603335350330},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1603335350330},{"_id":"public/js/utils.js","hash":"f24426cd3c20057ecf46a872f748bece3fb9653a","modified":1603335350330},{"_id":"public/js/search/local-search.js","hash":"5fc2736b91ddfac0292582af6595a724d33dbd92","modified":1603335350330},{"_id":"public/js/search/algolia.js","hash":"99bc7ef172e9af332d652e92c5ec8b9ec1481434","modified":1603335350330},{"_id":"public/css/index.css","hash":"51dd24b1571c60cc3b4d0f6eab97087bd00dd22f","modified":1603335350330},{"_id":"public/img/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1603335350330},{"_id":"public/js/main.js","hash":"6d21e93b56da9b749d517bf61ebbf08d89d0ab7a","modified":1603335350330},{"_id":"public/js/tw_cn.js","hash":"2eafc44f4a5b24bef836b00dfc4360a84edb8dcc","modified":1603335350330},{"_id":"public/img/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1603335350330},{"_id":"public/img/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1603335350330},{"_id":"source/_posts/论文笔记-FlexSC.md","hash":"8d332dfaa1e466f43f304c338265847493f65b46","modified":1608450797225},{"_id":"public/2020/12/03/lun-wen-bi-ji-flexsc/index.html","hash":"13f2056e81e40a49d197edcbe46c2a7ffa524c02","modified":1611473626920},{"_id":"public/archives/2020/12/index.html","hash":"6e0266cb6ba724493795edcf4895782a97badbe1","modified":1611473626920},{"_id":"source/_posts/2020-小结.md","hash":"f62b31a01740d60ab605252b6afccbe13a361184","modified":1611473729440}],"Category":[{"name":"服务","_id":"ckgk7k80d000406me7ucohizs"},{"name":"算法","_id":"ckgk7k80h000b06meblnh3tlv"},{"name":"笔记","_id":"ckgk7k80o000s06me3seg0wpf"},{"name":"杂谈","_id":"ckgk7k80s001106me5h3ocrgn"}],"Data":[],"Page":[{"title":"关于我","type":"about","_content":"\n### About Myself\n\n- 来自南京\n- 学学摄影，搞搞编程\n- 兴趣是人最大的动力，不忘记拾起自己的童心\n","source":"about/index.md","raw":"---\ntitle: 关于我\ntype: \"about\"\n---\n\n### About Myself\n\n- 来自南京\n- 学学摄影，搞搞编程\n- 兴趣是人最大的动力，不忘记拾起自己的童心\n","date":"2020-10-22T02:12:58.120Z","updated":"2020-10-22T02:12:58.120Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckgk7k806000006me9h7s57wc","content":"<h3 id=\"about-myself\"><a class=\"markdownIt-Anchor\" href=\"#about-myself\"></a> About Myself</h3>\n<ul>\n<li>来自南京</li>\n<li>学学摄影，搞搞编程</li>\n<li>兴趣是人最大的动力，不忘记拾起自己的童心</li>\n</ul>\n","site":{"data":{}},"cover":"https://images.unsplash.com/photo-1593642634315-48f5414c3ad9?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80","excerpt":"","more":"<h3 id=\"about-myself\"><a class=\"markdownIt-Anchor\" href=\"#about-myself\"></a> About Myself</h3>\n<ul>\n<li>来自南京</li>\n<li>学学摄影，搞搞编程</li>\n<li>兴趣是人最大的动力，不忘记拾起自己的童心</li>\n</ul>\n"},{"title":"tags","date":"2019-09-01T13:26:03.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-09-01 21:26:03\ntype: \"tags\"\n---\n","updated":"2020-10-22T02:12:58.121Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckgk7k80b000206me7ffs2kb1","content":"","site":{"data":{}},"cover":"https://images.unsplash.com/photo-1603231320933-cdd361afc4f0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80","excerpt":"","more":""},{"title":"categories","date":"2019-09-01T13:26:04.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-09-01 21:26:04\ntype: \"categories\"\n---\n","updated":"2020-10-22T02:12:58.121Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckgk7k80e000606me43d7c6li","content":"","site":{"data":{}},"cover":"https://images.unsplash.com/photo-1603194477925-b65a2d92d015?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80","excerpt":"","more":""},{"title":"contact","date":"2020-10-21T08:34:32.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2020-10-21 16:34:32\ntype: \"contact\"\nlayout: \"contact\"\n---\n","updated":"2020-10-22T02:12:58.121Z","path":"contact/index.html","comments":1,"_id":"ckgk7k80g000806me4nl86kt7","content":"","site":{"data":{}},"cover":"https://images.unsplash.com/photo-1603060044864-9c8826fb35af?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80","excerpt":"","more":""}],"Post":[{"title":"Kubernets 进行集群部署","date":"2019-09-12T15:23:08.000Z","description":"一条从Spring Cloud向K8S的路,循循善诱.","cover_img":"https://images.unsplash.com/photo-1429667947446-3c93a979b7e0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80","cover":"https://images.unsplash.com/photo-1429667947446-3c93a979b7e0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80","feature_img":"https://images.unsplash.com/photo-1543872084-c7bd3822856f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80","_content":"\n## Kubernets 进行集群部署\n\n### 关键定义\n\n- ##### Pod\n\n运行在Node节点上的若干个容器集合，是一个在容器基础上的更高的抽象。主要由 `master` 节点进行调度，将生成实例化的 Pod 调度到某一个 Node 上进行绑定；\n\n当某一个 Node 宕机，可以进行重新调度，将 Pod 调度到其他的 Node 节点上.\n- #####  Replication Controller\n\n我们一般不会手动自己创建Pod，这样很难管理。利用Replication Controller，可以定义Pod运行内容，副本的个数等信息，它的升级版本是 ReplicaSet。现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。\n\n- ##### Service\n\n可以把一组Pod组成服务 Service，Service有一个虚拟的ClusterIP，服务访问可以通过ClusterIP作为统一请求入口，因为一个 Service 对应一组Pod，所以可以做到负载均衡。服务可以通过 NodePort，LoadBalancer的方式暴露对外服务。注意 type = LoadBalancer需要云服务平台提供基础的服务，自建的K8S集群默认是没有这个东西的。如果在阿里云上定义服务 type = LoadBalancer 后，你会发现，在管理后台的负载均衡页面，会增加一个负载均衡器\n\n\n\n从以上的定义中看出, 一个Node可以认为是一台主机, 而Service作为一个服务提供者, 下包含了多个冗余Node. 能够在某一个Node宕机时及时进行其他备用节点的替补. \n\n我们需要把docker镜像push到远端的某一个镜像管理平台，而后通过配置文件的形式来定义Pod和Service的内容,实现分布式部署.\n\n### K8s YAML配置文件\n\n```\n# yaml格式的pod定义文件完整内容：\napiVersion: v1       #必选，版本号，例如v1\nkind: Pod       #必选，Pod\nmetadata:       #必选，元数据\n  name: string       #必选，Pod名称\n  namespace: string    #必选，Pod所属的命名空间\n  labels:      #自定义标签\n    - name: string     #自定义标签名字\n  annotations:       #自定义注释列表\n    - name: string\nspec:         #必选，Pod中容器的详细定义\n  containers:      #必选，Pod中容器列表\n  - name: string     #必选，容器名称\n    image: string    #必选，容器的镜像名称\n    imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像\n    command: [string]    #容器的启动命令列表，如不指定，使用打包时使用的启动命令\n    args: [string]     #容器的启动命令参数列表\n    workingDir: string     #容器的工作目录\n    volumeMounts:    #挂载到容器内部的存储卷配置\n    - name: string     #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名\n      mountPath: string    #存储卷在容器内mount的绝对路径，应少于512字符\n      readOnly: boolean    #是否为只读模式\n    ports:       #需要暴露的端口库号列表\n    - name: string     #端口号名称\n      containerPort: int   #容器需要监听的端口号\n      hostPort: int    #容器所在主机需要监听的端口号，默认与Container相同\n      protocol: string     #端口协议，支持TCP和UDP，默认TCP\n    env:       #容器运行前需设置的环境变量列表\n    - name: string     #环境变量名称\n      value: string    #环境变量的值\n    resources:       #资源限制和请求的设置\n      limits:      #资源限制的设置\n        cpu: string    #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数\n        memory: string     #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数\n      requests:      #资源请求的设置\n        cpu: string    #Cpu请求，容器启动的初始可用数量\n        memory: string     #内存清楚，容器启动的初始可用数量\n    livenessProbe:     #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可\n      exec:      #对Pod容器内检查方式设置为exec方式\n        command: [string]  #exec方式需要制定的命令或脚本\n      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port\n        path: string\n        port: number\n        host: string\n        scheme: string\n        HttpHeaders:\n        - name: string\n          value: string\n      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式\n         port: number\n       initialDelaySeconds: 0  #容器启动完成后首次探测的时间，单位为秒\n       timeoutSeconds: 0   #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒\n       periodSeconds: 0    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次\n       successThreshold: 0\n       failureThreshold: 0\n       securityContext:\n         privileged:false\n    restartPolicy: [Always | Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod\n    nodeSelector: obeject  #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定\n    imagePullSecrets:    #Pull镜像时使用的secret名称，以key：secretkey格式指定\n    - name: string\n    hostNetwork:false      #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络\n    volumes:       #在该pod上定义共享存储卷列表\n    - name: string     #共享存储卷名称 （volumes类型有很多种）\n      emptyDir: {}     #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值\n      hostPath: string     #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录\n        path: string     #Pod所在宿主机的目录，将被用于同期中mount的目录\n      secret:      #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部\n        scretname: string  \n        items:     \n        - key: string\n          path: string\n      configMap:     #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部\n        name: string\n        items:\n        - key: string\n\n```\n\n### 端口和IP\n\n和docker的内网环境类似，k8s也具有集群内部网络和外部网络.\n\n#### 1. nodePort\n\n外部流量访问k8s集群中service入口的一种方式（另一种方式是LoadBalancer），即nodeIP:nodePort是提供给外部流量访问k8s集群中service的入口。\n\n比如外部用户要访问k8s集群中的一个Web应用，那么我们可以配置对应service的**type=NodePort**，nodePort=30001。其他用户就可以通过浏览器http://node:30001访问到该web服务。\n\n而数据库等服务可能不需要被外界访问，只需被内部服务访问即可，那么我们就不必设置service的NodePort。\n\n\n\n#### 2. port\nk8s集群内部服务之间访问**service**的入口。即**clusterIP:port**是service暴露在clusterIP上的端口。\n\n- mysql容器暴露了3306端口（参考DockerFile），集群内其他容器通过33306端口访问mysql服务，但是**外部流量不能访问mysql服务**，因为mysql服务没有配置NodePort。对应的service.yaml如下：\n\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n name: mysql-service\nspec:\n ports:\n - port: 33306\n   targetPort: 3306\n selector:\n  name: mysql-pod\n```\n\n\n\n#### 3. targetPort\n\n容器的端口（最终的流量端口）。targetPort是pod上的端口，从port和nodePort上来的流量，经过kube-proxy流入到后端pod的targetPort上，最后进入容器。\n\n与**制作容器时暴露的端口一致**（使用DockerFile中的**EXPOSE**），例如官方的nginx（参考DockerFile）暴露80端口。 对应的service.yaml如下：\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n name: nginx-service\nspec:\n type: NodePort         // 有配置NodePort，外部流量可访问k8s中的服务\n ports:\n - port: 30080          // 服务访问端口\n   targetPort: 80       // 容器端口\n   nodePort: 30001      // NodePort\n selector:\n  name: nginx-pod\n```\n\n总的来说\n\n- port和nodePort都是service的端口，前者暴露给k8s集群内部服务访问，后者暴露给k8s集群外部流量访问。\n- 从上两个端口过来的数据都需要经过反向代理kube-proxy，流入后端pod的targetPort上，最后到达pod内的容器。","source":"_posts/Kebernets 进行集群部署.md","raw":"---\ntitle: Kubernets 进行集群部署\ndate: 2019-09-12 23:23:08\ntags: \n  - K8S\ncategories: \n  - 服务\ndescription: 一条从Spring Cloud向K8S的路,循循善诱.\ncover_img: https://images.unsplash.com/photo-1429667947446-3c93a979b7e0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80\ncover: https://images.unsplash.com/photo-1429667947446-3c93a979b7e0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80\nfeature_img: https://images.unsplash.com/photo-1543872084-c7bd3822856f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80\n---\n\n## Kubernets 进行集群部署\n\n### 关键定义\n\n- ##### Pod\n\n运行在Node节点上的若干个容器集合，是一个在容器基础上的更高的抽象。主要由 `master` 节点进行调度，将生成实例化的 Pod 调度到某一个 Node 上进行绑定；\n\n当某一个 Node 宕机，可以进行重新调度，将 Pod 调度到其他的 Node 节点上.\n- #####  Replication Controller\n\n我们一般不会手动自己创建Pod，这样很难管理。利用Replication Controller，可以定义Pod运行内容，副本的个数等信息，它的升级版本是 ReplicaSet。现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。\n\n- ##### Service\n\n可以把一组Pod组成服务 Service，Service有一个虚拟的ClusterIP，服务访问可以通过ClusterIP作为统一请求入口，因为一个 Service 对应一组Pod，所以可以做到负载均衡。服务可以通过 NodePort，LoadBalancer的方式暴露对外服务。注意 type = LoadBalancer需要云服务平台提供基础的服务，自建的K8S集群默认是没有这个东西的。如果在阿里云上定义服务 type = LoadBalancer 后，你会发现，在管理后台的负载均衡页面，会增加一个负载均衡器\n\n\n\n从以上的定义中看出, 一个Node可以认为是一台主机, 而Service作为一个服务提供者, 下包含了多个冗余Node. 能够在某一个Node宕机时及时进行其他备用节点的替补. \n\n我们需要把docker镜像push到远端的某一个镜像管理平台，而后通过配置文件的形式来定义Pod和Service的内容,实现分布式部署.\n\n### K8s YAML配置文件\n\n```\n# yaml格式的pod定义文件完整内容：\napiVersion: v1       #必选，版本号，例如v1\nkind: Pod       #必选，Pod\nmetadata:       #必选，元数据\n  name: string       #必选，Pod名称\n  namespace: string    #必选，Pod所属的命名空间\n  labels:      #自定义标签\n    - name: string     #自定义标签名字\n  annotations:       #自定义注释列表\n    - name: string\nspec:         #必选，Pod中容器的详细定义\n  containers:      #必选，Pod中容器列表\n  - name: string     #必选，容器名称\n    image: string    #必选，容器的镜像名称\n    imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像\n    command: [string]    #容器的启动命令列表，如不指定，使用打包时使用的启动命令\n    args: [string]     #容器的启动命令参数列表\n    workingDir: string     #容器的工作目录\n    volumeMounts:    #挂载到容器内部的存储卷配置\n    - name: string     #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名\n      mountPath: string    #存储卷在容器内mount的绝对路径，应少于512字符\n      readOnly: boolean    #是否为只读模式\n    ports:       #需要暴露的端口库号列表\n    - name: string     #端口号名称\n      containerPort: int   #容器需要监听的端口号\n      hostPort: int    #容器所在主机需要监听的端口号，默认与Container相同\n      protocol: string     #端口协议，支持TCP和UDP，默认TCP\n    env:       #容器运行前需设置的环境变量列表\n    - name: string     #环境变量名称\n      value: string    #环境变量的值\n    resources:       #资源限制和请求的设置\n      limits:      #资源限制的设置\n        cpu: string    #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数\n        memory: string     #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数\n      requests:      #资源请求的设置\n        cpu: string    #Cpu请求，容器启动的初始可用数量\n        memory: string     #内存清楚，容器启动的初始可用数量\n    livenessProbe:     #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可\n      exec:      #对Pod容器内检查方式设置为exec方式\n        command: [string]  #exec方式需要制定的命令或脚本\n      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port\n        path: string\n        port: number\n        host: string\n        scheme: string\n        HttpHeaders:\n        - name: string\n          value: string\n      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式\n         port: number\n       initialDelaySeconds: 0  #容器启动完成后首次探测的时间，单位为秒\n       timeoutSeconds: 0   #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒\n       periodSeconds: 0    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次\n       successThreshold: 0\n       failureThreshold: 0\n       securityContext:\n         privileged:false\n    restartPolicy: [Always | Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod\n    nodeSelector: obeject  #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定\n    imagePullSecrets:    #Pull镜像时使用的secret名称，以key：secretkey格式指定\n    - name: string\n    hostNetwork:false      #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络\n    volumes:       #在该pod上定义共享存储卷列表\n    - name: string     #共享存储卷名称 （volumes类型有很多种）\n      emptyDir: {}     #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值\n      hostPath: string     #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录\n        path: string     #Pod所在宿主机的目录，将被用于同期中mount的目录\n      secret:      #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部\n        scretname: string  \n        items:     \n        - key: string\n          path: string\n      configMap:     #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部\n        name: string\n        items:\n        - key: string\n\n```\n\n### 端口和IP\n\n和docker的内网环境类似，k8s也具有集群内部网络和外部网络.\n\n#### 1. nodePort\n\n外部流量访问k8s集群中service入口的一种方式（另一种方式是LoadBalancer），即nodeIP:nodePort是提供给外部流量访问k8s集群中service的入口。\n\n比如外部用户要访问k8s集群中的一个Web应用，那么我们可以配置对应service的**type=NodePort**，nodePort=30001。其他用户就可以通过浏览器http://node:30001访问到该web服务。\n\n而数据库等服务可能不需要被外界访问，只需被内部服务访问即可，那么我们就不必设置service的NodePort。\n\n\n\n#### 2. port\nk8s集群内部服务之间访问**service**的入口。即**clusterIP:port**是service暴露在clusterIP上的端口。\n\n- mysql容器暴露了3306端口（参考DockerFile），集群内其他容器通过33306端口访问mysql服务，但是**外部流量不能访问mysql服务**，因为mysql服务没有配置NodePort。对应的service.yaml如下：\n\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n name: mysql-service\nspec:\n ports:\n - port: 33306\n   targetPort: 3306\n selector:\n  name: mysql-pod\n```\n\n\n\n#### 3. targetPort\n\n容器的端口（最终的流量端口）。targetPort是pod上的端口，从port和nodePort上来的流量，经过kube-proxy流入到后端pod的targetPort上，最后进入容器。\n\n与**制作容器时暴露的端口一致**（使用DockerFile中的**EXPOSE**），例如官方的nginx（参考DockerFile）暴露80端口。 对应的service.yaml如下：\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n name: nginx-service\nspec:\n type: NodePort         // 有配置NodePort，外部流量可访问k8s中的服务\n ports:\n - port: 30080          // 服务访问端口\n   targetPort: 80       // 容器端口\n   nodePort: 30001      // NodePort\n selector:\n  name: nginx-pod\n```\n\n总的来说\n\n- port和nodePort都是service的端口，前者暴露给k8s集群内部服务访问，后者暴露给k8s集群外部流量访问。\n- 从上两个端口过来的数据都需要经过反向代理kube-proxy，流入后端pod的targetPort上，最后到达pod内的容器。","slug":"Kebernets 进行集群部署","published":1,"updated":"2020-10-22T02:12:58.115Z","_id":"ckgk7k808000106me4nqo0eh0","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"kubernets-进行集群部署\"><a class=\"markdownIt-Anchor\" href=\"#kubernets-进行集群部署\"></a> Kubernets 进行集群部署</h2>\n<h3 id=\"关键定义\"><a class=\"markdownIt-Anchor\" href=\"#关键定义\"></a> 关键定义</h3>\n<ul>\n<li>\n<h5 id=\"pod\"><a class=\"markdownIt-Anchor\" href=\"#pod\"></a> Pod</h5>\n</li>\n</ul>\n<p>运行在Node节点上的若干个容器集合，是一个在容器基础上的更高的抽象。主要由 <code>master</code> 节点进行调度，将生成实例化的 Pod 调度到某一个 Node 上进行绑定；</p>\n<p>当某一个 Node 宕机，可以进行重新调度，将 Pod 调度到其他的 Node 节点上.</p>\n<ul>\n<li>\n<h5 id=\"replication-controller\"><a class=\"markdownIt-Anchor\" href=\"#replication-controller\"></a> Replication Controller</h5>\n</li>\n</ul>\n<p>我们一般不会手动自己创建Pod，这样很难管理。利用Replication Controller，可以定义Pod运行内容，副本的个数等信息，它的升级版本是 ReplicaSet。现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。</p>\n<ul>\n<li>\n<h5 id=\"service\"><a class=\"markdownIt-Anchor\" href=\"#service\"></a> Service</h5>\n</li>\n</ul>\n<p>可以把一组Pod组成服务 Service，Service有一个虚拟的ClusterIP，服务访问可以通过ClusterIP作为统一请求入口，因为一个 Service 对应一组Pod，所以可以做到负载均衡。服务可以通过 NodePort，LoadBalancer的方式暴露对外服务。注意 type = LoadBalancer需要云服务平台提供基础的服务，自建的K8S集群默认是没有这个东西的。如果在阿里云上定义服务 type = LoadBalancer 后，你会发现，在管理后台的负载均衡页面，会增加一个负载均衡器</p>\n<p>从以上的定义中看出, 一个Node可以认为是一台主机, 而Service作为一个服务提供者, 下包含了多个冗余Node. 能够在某一个Node宕机时及时进行其他备用节点的替补.</p>\n<p>我们需要把docker镜像push到远端的某一个镜像管理平台，而后通过配置文件的形式来定义Pod和Service的内容,实现分布式部署.</p>\n<h3 id=\"k8s-yaml配置文件\"><a class=\"markdownIt-Anchor\" href=\"#k8s-yaml配置文件\"></a> K8s YAML配置文件</h3>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># yaml格式的pod定义文件完整内容：</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>       <span class=\"comment\">#必选，版本号，例如v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span>       <span class=\"comment\">#必选，Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>       <span class=\"comment\">#必选，元数据</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">string</span>       <span class=\"comment\">#必选，Pod名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">string</span>    <span class=\"comment\">#必选，Pod所属的命名空间</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span>      <span class=\"comment\">#自定义标签</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>     <span class=\"comment\">#自定义标签名字</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span>       <span class=\"comment\">#自定义注释列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>         <span class=\"comment\">#必选，Pod中容器的详细定义</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span>      <span class=\"comment\">#必选，Pod中容器列表</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>     <span class=\"comment\">#必选，容器名称</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">string</span>    <span class=\"comment\">#必选，容器的镜像名称</span></span><br><span class=\"line\">    <span class=\"attr\">imagePullPolicy:</span> [<span class=\"string\">Always</span> <span class=\"string\">|</span> <span class=\"string\">Never</span> <span class=\"string\">|</span> <span class=\"string\">IfNotPresent</span>] <span class=\"comment\">#获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">string</span>]    <span class=\"comment\">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class=\"line\">    <span class=\"attr\">args:</span> [<span class=\"string\">string</span>]     <span class=\"comment\">#容器的启动命令参数列表</span></span><br><span class=\"line\">    <span class=\"attr\">workingDir:</span> <span class=\"string\">string</span>     <span class=\"comment\">#容器的工作目录</span></span><br><span class=\"line\">    <span class=\"attr\">volumeMounts:</span>    <span class=\"comment\">#挂载到容器内部的存储卷配置</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>     <span class=\"comment\">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class=\"line\">      <span class=\"attr\">mountPath:</span> <span class=\"string\">string</span>    <span class=\"comment\">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class=\"line\">      <span class=\"attr\">readOnly:</span> <span class=\"string\">boolean</span>    <span class=\"comment\">#是否为只读模式</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span>       <span class=\"comment\">#需要暴露的端口库号列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>     <span class=\"comment\">#端口号名称</span></span><br><span class=\"line\">      <span class=\"attr\">containerPort:</span> <span class=\"string\">int</span>   <span class=\"comment\">#容器需要监听的端口号</span></span><br><span class=\"line\">      <span class=\"attr\">hostPort:</span> <span class=\"string\">int</span>    <span class=\"comment\">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class=\"line\">      <span class=\"attr\">protocol:</span> <span class=\"string\">string</span>     <span class=\"comment\">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class=\"line\">    <span class=\"attr\">env:</span>       <span class=\"comment\">#容器运行前需设置的环境变量列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>     <span class=\"comment\">#环境变量名称</span></span><br><span class=\"line\">      <span class=\"attr\">value:</span> <span class=\"string\">string</span>    <span class=\"comment\">#环境变量的值</span></span><br><span class=\"line\">    <span class=\"attr\">resources:</span>       <span class=\"comment\">#资源限制和请求的设置</span></span><br><span class=\"line\">      <span class=\"attr\">limits:</span>      <span class=\"comment\">#资源限制的设置</span></span><br><span class=\"line\">        <span class=\"attr\">cpu:</span> <span class=\"string\">string</span>    <span class=\"comment\">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class=\"line\">        <span class=\"attr\">memory:</span> <span class=\"string\">string</span>     <span class=\"comment\">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class=\"line\">      <span class=\"attr\">requests:</span>      <span class=\"comment\">#资源请求的设置</span></span><br><span class=\"line\">        <span class=\"attr\">cpu:</span> <span class=\"string\">string</span>    <span class=\"comment\">#Cpu请求，容器启动的初始可用数量</span></span><br><span class=\"line\">        <span class=\"attr\">memory:</span> <span class=\"string\">string</span>     <span class=\"comment\">#内存清楚，容器启动的初始可用数量</span></span><br><span class=\"line\">    <span class=\"attr\">livenessProbe:</span>     <span class=\"comment\">#对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span></span><br><span class=\"line\">      <span class=\"attr\">exec:</span>      <span class=\"comment\">#对Pod容器内检查方式设置为exec方式</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> [<span class=\"string\">string</span>]  <span class=\"comment\">#exec方式需要制定的命令或脚本</span></span><br><span class=\"line\">      <span class=\"attr\">httpGet:</span>       <span class=\"comment\">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">string</span></span><br><span class=\"line\">        <span class=\"attr\">port:</span> <span class=\"string\">number</span></span><br><span class=\"line\">        <span class=\"attr\">host:</span> <span class=\"string\">string</span></span><br><span class=\"line\">        <span class=\"attr\">scheme:</span> <span class=\"string\">string</span></span><br><span class=\"line\">        <span class=\"attr\">HttpHeaders:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">string</span></span><br><span class=\"line\">      <span class=\"attr\">tcpSocket:</span>     <span class=\"comment\">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class=\"line\">         <span class=\"attr\">port:</span> <span class=\"string\">number</span></span><br><span class=\"line\">       <span class=\"attr\">initialDelaySeconds:</span> <span class=\"number\">0</span>  <span class=\"comment\">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class=\"line\">       <span class=\"attr\">timeoutSeconds:</span> <span class=\"number\">0</span>   <span class=\"comment\">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class=\"line\">       <span class=\"attr\">periodSeconds:</span> <span class=\"number\">0</span>    <span class=\"comment\">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class=\"line\">       <span class=\"attr\">successThreshold:</span> <span class=\"number\">0</span></span><br><span class=\"line\">       <span class=\"attr\">failureThreshold:</span> <span class=\"number\">0</span></span><br><span class=\"line\">       <span class=\"attr\">securityContext:</span></span><br><span class=\"line\">         <span class=\"string\">privileged:false</span></span><br><span class=\"line\">    <span class=\"attr\">restartPolicy:</span> [<span class=\"string\">Always</span> <span class=\"string\">|</span> <span class=\"string\">Never</span> <span class=\"string\">|</span> <span class=\"string\">OnFailure</span>]<span class=\"comment\">#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span></span><br><span class=\"line\">    <span class=\"attr\">nodeSelector:</span> <span class=\"string\">obeject</span>  <span class=\"comment\">#设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span></span><br><span class=\"line\">    <span class=\"attr\">imagePullSecrets:</span>    <span class=\"comment\">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span></span><br><span class=\"line\">    <span class=\"string\">hostNetwork:false</span>      <span class=\"comment\">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span>       <span class=\"comment\">#在该pod上定义共享存储卷列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>     <span class=\"comment\">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class=\"line\">      <span class=\"attr\">emptyDir:</span> &#123;&#125;     <span class=\"comment\">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class=\"line\">      <span class=\"attr\">hostPath:</span> <span class=\"string\">string</span>     <span class=\"comment\">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">string</span>     <span class=\"comment\">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class=\"line\">      <span class=\"attr\">secret:</span>      <span class=\"comment\">#类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span></span><br><span class=\"line\">        <span class=\"attr\">scretname:</span> <span class=\"string\">string</span>  </span><br><span class=\"line\">        <span class=\"attr\">items:</span>     </span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">string</span></span><br><span class=\"line\">          <span class=\"attr\">path:</span> <span class=\"string\">string</span></span><br><span class=\"line\">      <span class=\"attr\">configMap:</span>     <span class=\"comment\">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">string</span></span><br><span class=\"line\">        <span class=\"attr\">items:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">string</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"端口和ip\"><a class=\"markdownIt-Anchor\" href=\"#端口和ip\"></a> 端口和IP</h3>\n<p>和docker的内网环境类似，k8s也具有集群内部网络和外部网络.</p>\n<h4 id=\"1-nodeport\"><a class=\"markdownIt-Anchor\" href=\"#1-nodeport\"></a> 1. nodePort</h4>\n<p>外部流量访问k8s集群中service入口的一种方式（另一种方式是LoadBalancer），即nodeIP:nodePort是提供给外部流量访问k8s集群中service的入口。</p>\n<p>比如外部用户要访问k8s集群中的一个Web应用，那么我们可以配置对应service的<strong>type=NodePort</strong>，nodePort=30001。其他用户就可以通过浏览器http://node:30001访问到该web服务。</p>\n<p>而数据库等服务可能不需要被外界访问，只需被内部服务访问即可，那么我们就不必设置service的NodePort。</p>\n<h4 id=\"2-port\"><a class=\"markdownIt-Anchor\" href=\"#2-port\"></a> 2. port</h4>\n<p>k8s集群内部服务之间访问<strong>service</strong>的入口。即<strong>clusterIP:port</strong>是service暴露在clusterIP上的端口。</p>\n<ul>\n<li>mysql容器暴露了3306端口（参考DockerFile），集群内其他容器通过33306端口访问mysql服务，但是<strong>外部流量不能访问mysql服务</strong>，因为mysql服务没有配置NodePort。对应的service.yaml如下：</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"> <span class=\"attr\">name:</span> <span class=\"string\">mysql-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"> <span class=\"attr\">ports:</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">33306</span></span><br><span class=\"line\">   <span class=\"attr\">targetPort:</span> <span class=\"number\">3306</span></span><br><span class=\"line\"> <span class=\"attr\">selector:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">mysql-pod</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-targetport\"><a class=\"markdownIt-Anchor\" href=\"#3-targetport\"></a> 3. targetPort</h4>\n<p>容器的端口（最终的流量端口）。targetPort是pod上的端口，从port和nodePort上来的流量，经过kube-proxy流入到后端pod的targetPort上，最后进入容器。</p>\n<p>与<strong>制作容器时暴露的端口一致</strong>（使用DockerFile中的<strong>EXPOSE</strong>），例如官方的nginx（参考DockerFile）暴露80端口。 对应的service.yaml如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"> <span class=\"attr\">name:</span> <span class=\"string\">nginx-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"> <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span>         <span class=\"string\">//</span> <span class=\"string\">有配置NodePort，外部流量可访问k8s中的服务</span></span><br><span class=\"line\"> <span class=\"attr\">ports:</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">30080</span>          <span class=\"string\">//</span> <span class=\"string\">服务访问端口</span></span><br><span class=\"line\">   <span class=\"attr\">targetPort:</span> <span class=\"number\">80</span>       <span class=\"string\">//</span> <span class=\"string\">容器端口</span></span><br><span class=\"line\">   <span class=\"attr\">nodePort:</span> <span class=\"number\">30001</span>      <span class=\"string\">//</span> <span class=\"string\">NodePort</span></span><br><span class=\"line\"> <span class=\"attr\">selector:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-pod</span></span><br></pre></td></tr></table></figure>\n<p>总的来说</p>\n<ul>\n<li>port和nodePort都是service的端口，前者暴露给k8s集群内部服务访问，后者暴露给k8s集群外部流量访问。</li>\n<li>从上两个端口过来的数据都需要经过反向代理kube-proxy，流入后端pod的targetPort上，最后到达pod内的容器。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"kubernets-进行集群部署\"><a class=\"markdownIt-Anchor\" href=\"#kubernets-进行集群部署\"></a> Kubernets 进行集群部署</h2>\n<h3 id=\"关键定义\"><a class=\"markdownIt-Anchor\" href=\"#关键定义\"></a> 关键定义</h3>\n<ul>\n<li>\n<h5 id=\"pod\"><a class=\"markdownIt-Anchor\" href=\"#pod\"></a> Pod</h5>\n</li>\n</ul>\n<p>运行在Node节点上的若干个容器集合，是一个在容器基础上的更高的抽象。主要由 <code>master</code> 节点进行调度，将生成实例化的 Pod 调度到某一个 Node 上进行绑定；</p>\n<p>当某一个 Node 宕机，可以进行重新调度，将 Pod 调度到其他的 Node 节点上.</p>\n<ul>\n<li>\n<h5 id=\"replication-controller\"><a class=\"markdownIt-Anchor\" href=\"#replication-controller\"></a> Replication Controller</h5>\n</li>\n</ul>\n<p>我们一般不会手动自己创建Pod，这样很难管理。利用Replication Controller，可以定义Pod运行内容，副本的个数等信息，它的升级版本是 ReplicaSet。现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。</p>\n<ul>\n<li>\n<h5 id=\"service\"><a class=\"markdownIt-Anchor\" href=\"#service\"></a> Service</h5>\n</li>\n</ul>\n<p>可以把一组Pod组成服务 Service，Service有一个虚拟的ClusterIP，服务访问可以通过ClusterIP作为统一请求入口，因为一个 Service 对应一组Pod，所以可以做到负载均衡。服务可以通过 NodePort，LoadBalancer的方式暴露对外服务。注意 type = LoadBalancer需要云服务平台提供基础的服务，自建的K8S集群默认是没有这个东西的。如果在阿里云上定义服务 type = LoadBalancer 后，你会发现，在管理后台的负载均衡页面，会增加一个负载均衡器</p>\n<p>从以上的定义中看出, 一个Node可以认为是一台主机, 而Service作为一个服务提供者, 下包含了多个冗余Node. 能够在某一个Node宕机时及时进行其他备用节点的替补.</p>\n<p>我们需要把docker镜像push到远端的某一个镜像管理平台，而后通过配置文件的形式来定义Pod和Service的内容,实现分布式部署.</p>\n<h3 id=\"k8s-yaml配置文件\"><a class=\"markdownIt-Anchor\" href=\"#k8s-yaml配置文件\"></a> K8s YAML配置文件</h3>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># yaml格式的pod定义文件完整内容：</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>       <span class=\"comment\">#必选，版本号，例如v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span>       <span class=\"comment\">#必选，Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>       <span class=\"comment\">#必选，元数据</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">string</span>       <span class=\"comment\">#必选，Pod名称</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">string</span>    <span class=\"comment\">#必选，Pod所属的命名空间</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span>      <span class=\"comment\">#自定义标签</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>     <span class=\"comment\">#自定义标签名字</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span>       <span class=\"comment\">#自定义注释列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>         <span class=\"comment\">#必选，Pod中容器的详细定义</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span>      <span class=\"comment\">#必选，Pod中容器列表</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>     <span class=\"comment\">#必选，容器名称</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">string</span>    <span class=\"comment\">#必选，容器的镜像名称</span></span><br><span class=\"line\">    <span class=\"attr\">imagePullPolicy:</span> [<span class=\"string\">Always</span> <span class=\"string\">|</span> <span class=\"string\">Never</span> <span class=\"string\">|</span> <span class=\"string\">IfNotPresent</span>] <span class=\"comment\">#获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">string</span>]    <span class=\"comment\">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class=\"line\">    <span class=\"attr\">args:</span> [<span class=\"string\">string</span>]     <span class=\"comment\">#容器的启动命令参数列表</span></span><br><span class=\"line\">    <span class=\"attr\">workingDir:</span> <span class=\"string\">string</span>     <span class=\"comment\">#容器的工作目录</span></span><br><span class=\"line\">    <span class=\"attr\">volumeMounts:</span>    <span class=\"comment\">#挂载到容器内部的存储卷配置</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>     <span class=\"comment\">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class=\"line\">      <span class=\"attr\">mountPath:</span> <span class=\"string\">string</span>    <span class=\"comment\">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class=\"line\">      <span class=\"attr\">readOnly:</span> <span class=\"string\">boolean</span>    <span class=\"comment\">#是否为只读模式</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span>       <span class=\"comment\">#需要暴露的端口库号列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>     <span class=\"comment\">#端口号名称</span></span><br><span class=\"line\">      <span class=\"attr\">containerPort:</span> <span class=\"string\">int</span>   <span class=\"comment\">#容器需要监听的端口号</span></span><br><span class=\"line\">      <span class=\"attr\">hostPort:</span> <span class=\"string\">int</span>    <span class=\"comment\">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class=\"line\">      <span class=\"attr\">protocol:</span> <span class=\"string\">string</span>     <span class=\"comment\">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class=\"line\">    <span class=\"attr\">env:</span>       <span class=\"comment\">#容器运行前需设置的环境变量列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>     <span class=\"comment\">#环境变量名称</span></span><br><span class=\"line\">      <span class=\"attr\">value:</span> <span class=\"string\">string</span>    <span class=\"comment\">#环境变量的值</span></span><br><span class=\"line\">    <span class=\"attr\">resources:</span>       <span class=\"comment\">#资源限制和请求的设置</span></span><br><span class=\"line\">      <span class=\"attr\">limits:</span>      <span class=\"comment\">#资源限制的设置</span></span><br><span class=\"line\">        <span class=\"attr\">cpu:</span> <span class=\"string\">string</span>    <span class=\"comment\">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class=\"line\">        <span class=\"attr\">memory:</span> <span class=\"string\">string</span>     <span class=\"comment\">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class=\"line\">      <span class=\"attr\">requests:</span>      <span class=\"comment\">#资源请求的设置</span></span><br><span class=\"line\">        <span class=\"attr\">cpu:</span> <span class=\"string\">string</span>    <span class=\"comment\">#Cpu请求，容器启动的初始可用数量</span></span><br><span class=\"line\">        <span class=\"attr\">memory:</span> <span class=\"string\">string</span>     <span class=\"comment\">#内存清楚，容器启动的初始可用数量</span></span><br><span class=\"line\">    <span class=\"attr\">livenessProbe:</span>     <span class=\"comment\">#对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span></span><br><span class=\"line\">      <span class=\"attr\">exec:</span>      <span class=\"comment\">#对Pod容器内检查方式设置为exec方式</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> [<span class=\"string\">string</span>]  <span class=\"comment\">#exec方式需要制定的命令或脚本</span></span><br><span class=\"line\">      <span class=\"attr\">httpGet:</span>       <span class=\"comment\">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">string</span></span><br><span class=\"line\">        <span class=\"attr\">port:</span> <span class=\"string\">number</span></span><br><span class=\"line\">        <span class=\"attr\">host:</span> <span class=\"string\">string</span></span><br><span class=\"line\">        <span class=\"attr\">scheme:</span> <span class=\"string\">string</span></span><br><span class=\"line\">        <span class=\"attr\">HttpHeaders:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">string</span></span><br><span class=\"line\">      <span class=\"attr\">tcpSocket:</span>     <span class=\"comment\">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class=\"line\">         <span class=\"attr\">port:</span> <span class=\"string\">number</span></span><br><span class=\"line\">       <span class=\"attr\">initialDelaySeconds:</span> <span class=\"number\">0</span>  <span class=\"comment\">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class=\"line\">       <span class=\"attr\">timeoutSeconds:</span> <span class=\"number\">0</span>   <span class=\"comment\">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class=\"line\">       <span class=\"attr\">periodSeconds:</span> <span class=\"number\">0</span>    <span class=\"comment\">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class=\"line\">       <span class=\"attr\">successThreshold:</span> <span class=\"number\">0</span></span><br><span class=\"line\">       <span class=\"attr\">failureThreshold:</span> <span class=\"number\">0</span></span><br><span class=\"line\">       <span class=\"attr\">securityContext:</span></span><br><span class=\"line\">         <span class=\"string\">privileged:false</span></span><br><span class=\"line\">    <span class=\"attr\">restartPolicy:</span> [<span class=\"string\">Always</span> <span class=\"string\">|</span> <span class=\"string\">Never</span> <span class=\"string\">|</span> <span class=\"string\">OnFailure</span>]<span class=\"comment\">#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span></span><br><span class=\"line\">    <span class=\"attr\">nodeSelector:</span> <span class=\"string\">obeject</span>  <span class=\"comment\">#设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span></span><br><span class=\"line\">    <span class=\"attr\">imagePullSecrets:</span>    <span class=\"comment\">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span></span><br><span class=\"line\">    <span class=\"string\">hostNetwork:false</span>      <span class=\"comment\">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span>       <span class=\"comment\">#在该pod上定义共享存储卷列表</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">string</span>     <span class=\"comment\">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class=\"line\">      <span class=\"attr\">emptyDir:</span> &#123;&#125;     <span class=\"comment\">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class=\"line\">      <span class=\"attr\">hostPath:</span> <span class=\"string\">string</span>     <span class=\"comment\">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">string</span>     <span class=\"comment\">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class=\"line\">      <span class=\"attr\">secret:</span>      <span class=\"comment\">#类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span></span><br><span class=\"line\">        <span class=\"attr\">scretname:</span> <span class=\"string\">string</span>  </span><br><span class=\"line\">        <span class=\"attr\">items:</span>     </span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">string</span></span><br><span class=\"line\">          <span class=\"attr\">path:</span> <span class=\"string\">string</span></span><br><span class=\"line\">      <span class=\"attr\">configMap:</span>     <span class=\"comment\">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">string</span></span><br><span class=\"line\">        <span class=\"attr\">items:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">string</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"端口和ip\"><a class=\"markdownIt-Anchor\" href=\"#端口和ip\"></a> 端口和IP</h3>\n<p>和docker的内网环境类似，k8s也具有集群内部网络和外部网络.</p>\n<h4 id=\"1-nodeport\"><a class=\"markdownIt-Anchor\" href=\"#1-nodeport\"></a> 1. nodePort</h4>\n<p>外部流量访问k8s集群中service入口的一种方式（另一种方式是LoadBalancer），即nodeIP:nodePort是提供给外部流量访问k8s集群中service的入口。</p>\n<p>比如外部用户要访问k8s集群中的一个Web应用，那么我们可以配置对应service的<strong>type=NodePort</strong>，nodePort=30001。其他用户就可以通过浏览器http://node:30001访问到该web服务。</p>\n<p>而数据库等服务可能不需要被外界访问，只需被内部服务访问即可，那么我们就不必设置service的NodePort。</p>\n<h4 id=\"2-port\"><a class=\"markdownIt-Anchor\" href=\"#2-port\"></a> 2. port</h4>\n<p>k8s集群内部服务之间访问<strong>service</strong>的入口。即<strong>clusterIP:port</strong>是service暴露在clusterIP上的端口。</p>\n<ul>\n<li>mysql容器暴露了3306端口（参考DockerFile），集群内其他容器通过33306端口访问mysql服务，但是<strong>外部流量不能访问mysql服务</strong>，因为mysql服务没有配置NodePort。对应的service.yaml如下：</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"> <span class=\"attr\">name:</span> <span class=\"string\">mysql-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"> <span class=\"attr\">ports:</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">33306</span></span><br><span class=\"line\">   <span class=\"attr\">targetPort:</span> <span class=\"number\">3306</span></span><br><span class=\"line\"> <span class=\"attr\">selector:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">mysql-pod</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-targetport\"><a class=\"markdownIt-Anchor\" href=\"#3-targetport\"></a> 3. targetPort</h4>\n<p>容器的端口（最终的流量端口）。targetPort是pod上的端口，从port和nodePort上来的流量，经过kube-proxy流入到后端pod的targetPort上，最后进入容器。</p>\n<p>与<strong>制作容器时暴露的端口一致</strong>（使用DockerFile中的<strong>EXPOSE</strong>），例如官方的nginx（参考DockerFile）暴露80端口。 对应的service.yaml如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"> <span class=\"attr\">name:</span> <span class=\"string\">nginx-service</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"> <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span>         <span class=\"string\">//</span> <span class=\"string\">有配置NodePort，外部流量可访问k8s中的服务</span></span><br><span class=\"line\"> <span class=\"attr\">ports:</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">30080</span>          <span class=\"string\">//</span> <span class=\"string\">服务访问端口</span></span><br><span class=\"line\">   <span class=\"attr\">targetPort:</span> <span class=\"number\">80</span>       <span class=\"string\">//</span> <span class=\"string\">容器端口</span></span><br><span class=\"line\">   <span class=\"attr\">nodePort:</span> <span class=\"number\">30001</span>      <span class=\"string\">//</span> <span class=\"string\">NodePort</span></span><br><span class=\"line\"> <span class=\"attr\">selector:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-pod</span></span><br></pre></td></tr></table></figure>\n<p>总的来说</p>\n<ul>\n<li>port和nodePort都是service的端口，前者暴露给k8s集群内部服务访问，后者暴露给k8s集群外部流量访问。</li>\n<li>从上两个端口过来的数据都需要经过反向代理kube-proxy，流入后端pod的targetPort上，最后到达pod内的容器。</li>\n</ul>\n"},{"title":"LC周赛 2019-09-15","date":"2019-09-15T08:41:44.000Z","description":"20190915周赛记录","cover_img":"https://images.unsplash.com/photo-1516575448682-93a05df8bf59?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80","cover":"https://images.unsplash.com/photo-1516575448682-93a05df8bf59?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80","feature_img":"https://images.unsplash.com/photo-1484278786775-527ac0d0b608?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=956&q=80","_content":"\n## 1. 寻找字符串中Balloon个数\n\n给你一个字符串 `text`，你需要使用 `text` 中的字母来拼凑尽可能多的单词 **\"balloon\"（气球）**。\n\n字符串 `text` 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 **\"balloon\"**。\n\n### 思路：\n\n很快可以通过哈希表来建立一个 `字符到字符在text中出现次数`的映射, 然后根据`ballon ` 来进行对照得出最终结果: 一定是 { `b` 出现次数 , `a` 出现次数 , `n` 出现次数 , `l` 出现次数的一半 , `o` 出现次数的一半 } 中的最小值, 即满足\n\n\n\n```java\npublic int maxNumberOfBalloons(String text) {\n        Map<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < text.length(); ++i) {\n            map.put(text.charAt(i), map.getOrDefault(text.charAt(i), 0) + 1);\n        }\n        int b = map.getOrDefault('b', 0),\n                a = map.getOrDefault('a', 0),\n                l = map.getOrDefault('l', 0) / 2,\n                o = map.getOrDefault('o', 0) / 2,\n                n = map.getOrDefault('n', 0);\n        return Math.min(b, Math.min(a, Math.min(l, Math.min(o, n))));\n    }\n```\n\n##  2. 反转每对括号间的子串\n\n给出一个字符串 `s`（仅含有小写英文字母和括号）。\n\n请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。\n\n注意，您的结果中 **不应** 包含任何括号。\n\n### 思路：\n\n很明显这是一个 **递归** 问题. 举例说明\n\n```\n输入：s = \"(u(love)i)\"\n```\n\n我们需要先找出 **最小匹配括号子串** , 将其翻转之后, 再对其父级的子串进行翻转. \n\n\n\n但是有一个比较坑的点, 测试用例里面有这样的 `a()b(((c)))de` ， 也就是说，可以存在平级的括号. 这一点当时没想到. 从这里我们需要改变想法：\n\n- 当遇到同级的括号，先处理过当前的 `()` 对，然后继续使用 ReverseParentheses 来对后续同级括号进行翻转. 这个属于迭代式的处理\n- 当遇到子级括号, 也就是正常的 `(d(c))`这样的情况，就使用递归函数解决\n\n```java\n    public String reverseParentheses(String s) {\n        int begin = 0;\n        int end;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(')\n                begin = i;\n            if (s.charAt(i) == ')') {\n                end = i;\n                String temp = s.substring(begin + 1, end);//最小 ()\n                return reverseParentheses(s.substring(0, begin) + reverseString(temp) + s.substring(end + 1));\n            }\n        }\n        return s;\n    }\n\n    String reverseString(String s) {\n        char[] temp = s.toCharArray();\n        StringBuilder r = new StringBuilder();\n        for (int i = temp.length - 1; i >= 0; i--)\n            r.append(temp[i]);\n\n        return r.toString();\n    }\n```\n\n## 3. k次串联数组之后的最大子数组之和\n\n给你一个整数数组 `arr` 和一个整数 `k`。\n\n首先，我们要对该数组进行修改，即把原数组 `arr` 重复 `k` 次。\n\n> 举个例子，如果 `arr = [1, 2]` 且 `k = 3`，那么修改后的数组就是 `[1, 2, 1, 2, 1, 2]`。\n\n然后，请你返回修改后的数组中的最大的子数组之和。\n\n注意，子数组长度可以是 `0`，在这种情况下它的总和也是 `0`。\n\n由于 **结果可能会很大**，所以需要 **模（mod）** `10^9 + 7` 后再返回。 \n\n### 思路：\n\n一看，这个不就是最大子数组的翻版吗 hhh , 那么直接贪心上啊 \n\n```java\nprivate static final long MOD = 1000_000_007;\n\nprivate int sumHelper(int[] arr, int k) {\n        int totalLen = arr.length * k;\n        int max = 0;\n        int sum = 0;\n        for (int i = 0; i < totalLen; ++i) {\n            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);\n            if (sum < 0) {\n                sum = 0;\n            } else {\n                max = Math.max(sum, max);\n            }\n        }\n        return max;\n    }\n```\n\n那么问题来了，**TLE** 了. 也就是说，这个算法不容忍 **O(N)** 的时间复杂度. 我们需要找到数组在进行串联的时候的一个和数关系来进行快速获取答案.\n\n#### 分析：\n\n前缀和判断，一共如下可能\n\n- 答案为 0\n\n- 答案仅从当前不串联的数组中得到, 即 k = 1时的最大子数组和\n\n- 答案从 k = 2 的串联结果得到，第一部分的后缀和的最大值加上第二部分的前缀和的最大值。\n\n- 答案从整个串联 k > 2 次后的结果得到，且一定是第一部分的后缀和的最大值，中间部分的总和，加上最后一部分的前缀和的最大值。\n\n第二种可能从**当前前缀和**减去**当前前缀和的最小值**得到。\n\n前缀和的最大值直接可以维护出来，后缀和的最大值可以通过总和减去前缀和的最小值得到。\n\n#### 实现\n\n需要维护数组的 **总和**, **最大前缀和** , **最小前缀和**\n\n```java\n    private static final long MOD = 1000_000_007;\n\n    public int kConcatenationMaxSum(int[] arr, int k) {\n        int n = arr.length;\n        if (k == 1)\n            return sumHelper(arr);\n        long[] sum = new long[n + 1];\n        long[] maxL = new long[n + 1];\n        long[] minL = new long[n + 1];\n        for (int i = 1; i < n + 1; ++i) {\n            sum[i] = sum[i - 1] + arr[i];\n            maxL[i] = Math.max(maxL[i - 1], sum[i]);\n            minL[i] = Math.min(minL[i - 1], sum[i]);\n        }\n        long ans = 0;\n        return (int) (Math.max(ans,\n                Math.max(\n                        sum[n] - minL[n] + maxL[n],\n                        sum[n] - minL[n] + maxL[n] + sum[n] * (k - 2)\n                )\n        ) % MOD);\n    }\n\n    private int sumHelper(int[] arr) {\n        int totalLen = arr.length;\n        int max = 0;\n        int sum = 0;\n        for (int i = 0; i < totalLen; ++i) {\n            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);\n            if (sum < 0) {\n                sum = 0;\n            } else {\n                max = Math.max(sum, max);\n            }\n        }\n        return max;\n    }\n```\n\n## 4. 查找集群内的「关键连接」\n\n力扣数据中心有 `n` 台服务器，分别按从 `0` 到 `n-1` 的方式进行了编号。\n\n它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 `connections` 是无向的。\n\n从形式上讲，`connections[i] = [a, b]` 表示服务器 `a` 和 `b` 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。\n\n「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。\n\n请你以任意顺序返回该集群内的所有 「关键连接」。\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png)","source":"_posts/LC周赛-2019-09-15.md","raw":"---\ntitle: LC周赛 2019-09-15\ndate: 2019-09-15 16:41:44\ntags: \n  - competition\ncategories: \n  - 算法\ndescription: 20190915周赛记录\ncover_img: https://images.unsplash.com/photo-1516575448682-93a05df8bf59?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80\ncover: https://images.unsplash.com/photo-1516575448682-93a05df8bf59?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80\nfeature_img: https://images.unsplash.com/photo-1484278786775-527ac0d0b608?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=956&q=80\n---\n\n## 1. 寻找字符串中Balloon个数\n\n给你一个字符串 `text`，你需要使用 `text` 中的字母来拼凑尽可能多的单词 **\"balloon\"（气球）**。\n\n字符串 `text` 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 **\"balloon\"**。\n\n### 思路：\n\n很快可以通过哈希表来建立一个 `字符到字符在text中出现次数`的映射, 然后根据`ballon ` 来进行对照得出最终结果: 一定是 { `b` 出现次数 , `a` 出现次数 , `n` 出现次数 , `l` 出现次数的一半 , `o` 出现次数的一半 } 中的最小值, 即满足\n\n\n\n```java\npublic int maxNumberOfBalloons(String text) {\n        Map<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < text.length(); ++i) {\n            map.put(text.charAt(i), map.getOrDefault(text.charAt(i), 0) + 1);\n        }\n        int b = map.getOrDefault('b', 0),\n                a = map.getOrDefault('a', 0),\n                l = map.getOrDefault('l', 0) / 2,\n                o = map.getOrDefault('o', 0) / 2,\n                n = map.getOrDefault('n', 0);\n        return Math.min(b, Math.min(a, Math.min(l, Math.min(o, n))));\n    }\n```\n\n##  2. 反转每对括号间的子串\n\n给出一个字符串 `s`（仅含有小写英文字母和括号）。\n\n请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。\n\n注意，您的结果中 **不应** 包含任何括号。\n\n### 思路：\n\n很明显这是一个 **递归** 问题. 举例说明\n\n```\n输入：s = \"(u(love)i)\"\n```\n\n我们需要先找出 **最小匹配括号子串** , 将其翻转之后, 再对其父级的子串进行翻转. \n\n\n\n但是有一个比较坑的点, 测试用例里面有这样的 `a()b(((c)))de` ， 也就是说，可以存在平级的括号. 这一点当时没想到. 从这里我们需要改变想法：\n\n- 当遇到同级的括号，先处理过当前的 `()` 对，然后继续使用 ReverseParentheses 来对后续同级括号进行翻转. 这个属于迭代式的处理\n- 当遇到子级括号, 也就是正常的 `(d(c))`这样的情况，就使用递归函数解决\n\n```java\n    public String reverseParentheses(String s) {\n        int begin = 0;\n        int end;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(')\n                begin = i;\n            if (s.charAt(i) == ')') {\n                end = i;\n                String temp = s.substring(begin + 1, end);//最小 ()\n                return reverseParentheses(s.substring(0, begin) + reverseString(temp) + s.substring(end + 1));\n            }\n        }\n        return s;\n    }\n\n    String reverseString(String s) {\n        char[] temp = s.toCharArray();\n        StringBuilder r = new StringBuilder();\n        for (int i = temp.length - 1; i >= 0; i--)\n            r.append(temp[i]);\n\n        return r.toString();\n    }\n```\n\n## 3. k次串联数组之后的最大子数组之和\n\n给你一个整数数组 `arr` 和一个整数 `k`。\n\n首先，我们要对该数组进行修改，即把原数组 `arr` 重复 `k` 次。\n\n> 举个例子，如果 `arr = [1, 2]` 且 `k = 3`，那么修改后的数组就是 `[1, 2, 1, 2, 1, 2]`。\n\n然后，请你返回修改后的数组中的最大的子数组之和。\n\n注意，子数组长度可以是 `0`，在这种情况下它的总和也是 `0`。\n\n由于 **结果可能会很大**，所以需要 **模（mod）** `10^9 + 7` 后再返回。 \n\n### 思路：\n\n一看，这个不就是最大子数组的翻版吗 hhh , 那么直接贪心上啊 \n\n```java\nprivate static final long MOD = 1000_000_007;\n\nprivate int sumHelper(int[] arr, int k) {\n        int totalLen = arr.length * k;\n        int max = 0;\n        int sum = 0;\n        for (int i = 0; i < totalLen; ++i) {\n            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);\n            if (sum < 0) {\n                sum = 0;\n            } else {\n                max = Math.max(sum, max);\n            }\n        }\n        return max;\n    }\n```\n\n那么问题来了，**TLE** 了. 也就是说，这个算法不容忍 **O(N)** 的时间复杂度. 我们需要找到数组在进行串联的时候的一个和数关系来进行快速获取答案.\n\n#### 分析：\n\n前缀和判断，一共如下可能\n\n- 答案为 0\n\n- 答案仅从当前不串联的数组中得到, 即 k = 1时的最大子数组和\n\n- 答案从 k = 2 的串联结果得到，第一部分的后缀和的最大值加上第二部分的前缀和的最大值。\n\n- 答案从整个串联 k > 2 次后的结果得到，且一定是第一部分的后缀和的最大值，中间部分的总和，加上最后一部分的前缀和的最大值。\n\n第二种可能从**当前前缀和**减去**当前前缀和的最小值**得到。\n\n前缀和的最大值直接可以维护出来，后缀和的最大值可以通过总和减去前缀和的最小值得到。\n\n#### 实现\n\n需要维护数组的 **总和**, **最大前缀和** , **最小前缀和**\n\n```java\n    private static final long MOD = 1000_000_007;\n\n    public int kConcatenationMaxSum(int[] arr, int k) {\n        int n = arr.length;\n        if (k == 1)\n            return sumHelper(arr);\n        long[] sum = new long[n + 1];\n        long[] maxL = new long[n + 1];\n        long[] minL = new long[n + 1];\n        for (int i = 1; i < n + 1; ++i) {\n            sum[i] = sum[i - 1] + arr[i];\n            maxL[i] = Math.max(maxL[i - 1], sum[i]);\n            minL[i] = Math.min(minL[i - 1], sum[i]);\n        }\n        long ans = 0;\n        return (int) (Math.max(ans,\n                Math.max(\n                        sum[n] - minL[n] + maxL[n],\n                        sum[n] - minL[n] + maxL[n] + sum[n] * (k - 2)\n                )\n        ) % MOD);\n    }\n\n    private int sumHelper(int[] arr) {\n        int totalLen = arr.length;\n        int max = 0;\n        int sum = 0;\n        for (int i = 0; i < totalLen; ++i) {\n            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);\n            if (sum < 0) {\n                sum = 0;\n            } else {\n                max = Math.max(sum, max);\n            }\n        }\n        return max;\n    }\n```\n\n## 4. 查找集群内的「关键连接」\n\n力扣数据中心有 `n` 台服务器，分别按从 `0` 到 `n-1` 的方式进行了编号。\n\n它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 `connections` 是无向的。\n\n从形式上讲，`connections[i] = [a, b]` 表示服务器 `a` 和 `b` 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。\n\n「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。\n\n请你以任意顺序返回该集群内的所有 「关键连接」。\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png)","slug":"LC周赛-2019-09-15","published":1,"updated":"2020-10-22T02:12:58.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgk7k80b000306mefb3td4ie","content":"<h2 id=\"1-寻找字符串中balloon个数\"><a class=\"markdownIt-Anchor\" href=\"#1-寻找字符串中balloon个数\"></a> 1. 寻找字符串中Balloon个数</h2>\n<p>给你一个字符串 <code>text</code>，你需要使用 <code>text</code> 中的字母来拼凑尽可能多的单词 <strong>“balloon”（气球）</strong>。</p>\n<p>字符串 <code>text</code> 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 <strong>“balloon”</strong>。</p>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路：</h3>\n<p>很快可以通过哈希表来建立一个 <code>字符到字符在text中出现次数</code>的映射, 然后根据<code>ballon</code> 来进行对照得出最终结果: 一定是 { <code>b</code> 出现次数 , <code>a</code> 出现次数 , <code>n</code> 出现次数 , <code>l</code> 出现次数的一半 , <code>o</code> 出现次数的一半 } 中的最小值, 即满足</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxNumberOfBalloons</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; text.length(); ++i) &#123;</span><br><span class=\"line\">            map.put(text.charAt(i), map.getOrDefault(text.charAt(i), <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = map.getOrDefault(<span class=\"string\">&#x27;b&#x27;</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">                a = map.getOrDefault(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">                l = map.getOrDefault(<span class=\"string\">&#x27;l&#x27;</span>, <span class=\"number\">0</span>) / <span class=\"number\">2</span>,</span><br><span class=\"line\">                o = map.getOrDefault(<span class=\"string\">&#x27;o&#x27;</span>, <span class=\"number\">0</span>) / <span class=\"number\">2</span>,</span><br><span class=\"line\">                n = map.getOrDefault(<span class=\"string\">&#x27;n&#x27;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.min(b, Math.min(a, Math.min(l, Math.min(o, n))));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-反转每对括号间的子串\"><a class=\"markdownIt-Anchor\" href=\"#2-反转每对括号间的子串\"></a> 2. 反转每对括号间的子串</h2>\n<p>给出一个字符串 <code>s</code>（仅含有小写英文字母和括号）。</p>\n<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>\n<p>注意，您的结果中 <strong>不应</strong> 包含任何括号。</p>\n<h3 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\"></a> 思路：</h3>\n<p>很明显这是一个 <strong>递归</strong> 问题. 举例说明</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"attr\">s</span> = <span class=\"string\">&quot;(u(love)i)&quot;</span></span><br></pre></td></tr></table></figure>\n<p>我们需要先找出 <strong>最小匹配括号子串</strong> , 将其翻转之后, 再对其父级的子串进行翻转.</p>\n<p>但是有一个比较坑的点, 测试用例里面有这样的 <code>a()b(((c)))de</code> ， 也就是说，可以存在平级的括号. 这一点当时没想到. 从这里我们需要改变想法：</p>\n<ul>\n<li>当遇到同级的括号，先处理过当前的 <code>()</code> 对，然后继续使用 ReverseParentheses 来对后续同级括号进行翻转. 这个属于迭代式的处理</li>\n<li>当遇到子级括号, 也就是正常的 <code>(d(c))</code>这样的情况，就使用递归函数解决</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">reverseParentheses</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> begin = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(i) == <span class=\"string\">&#x27;(&#x27;</span>)</span><br><span class=\"line\">            begin = i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(i) == <span class=\"string\">&#x27;)&#x27;</span>) &#123;</span><br><span class=\"line\">            end = i;</span><br><span class=\"line\">            String temp = s.substring(begin + <span class=\"number\">1</span>, end);<span class=\"comment\">//最小 ()</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> reverseParentheses(s.substring(<span class=\"number\">0</span>, begin) + reverseString(temp) + s.substring(end + <span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">String <span class=\"title\">reverseString</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] temp = s.toCharArray();</span><br><span class=\"line\">    StringBuilder r = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = temp.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        r.append(temp[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-k次串联数组之后的最大子数组之和\"><a class=\"markdownIt-Anchor\" href=\"#3-k次串联数组之后的最大子数组之和\"></a> 3. k次串联数组之后的最大子数组之和</h2>\n<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code>。</p>\n<p>首先，我们要对该数组进行修改，即把原数组 <code>arr</code> 重复 <code>k</code> 次。</p>\n<blockquote>\n<p>举个例子，如果 <code>arr = [1, 2]</code> 且 <code>k = 3</code>，那么修改后的数组就是 <code>[1, 2, 1, 2, 1, 2]</code>。</p>\n</blockquote>\n<p>然后，请你返回修改后的数组中的最大的子数组之和。</p>\n<p>注意，子数组长度可以是 <code>0</code>，在这种情况下它的总和也是 <code>0</code>。</p>\n<p>由于 <strong>结果可能会很大</strong>，所以需要 <strong>模（mod）</strong> <code>10^9 + 7</code> 后再返回。</p>\n<h3 id=\"思路-3\"><a class=\"markdownIt-Anchor\" href=\"#思路-3\"></a> 思路：</h3>\n<p>一看，这个不就是最大子数组的翻版吗 hhh , 那么直接贪心上啊</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> MOD = <span class=\"number\">1000_000_007</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">sumHelper</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalLen = arr.length * k;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; totalLen; ++i) &#123;</span><br><span class=\"line\">            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                max = Math.max(sum, max);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>那么问题来了，<strong>TLE</strong> 了. 也就是说，这个算法不容忍 <strong>O(N)</strong> 的时间复杂度. 我们需要找到数组在进行串联的时候的一个和数关系来进行快速获取答案.</p>\n<h4 id=\"分析\"><a class=\"markdownIt-Anchor\" href=\"#分析\"></a> 分析：</h4>\n<p>前缀和判断，一共如下可能</p>\n<ul>\n<li>\n<p>答案为 0</p>\n</li>\n<li>\n<p>答案仅从当前不串联的数组中得到, 即 k = 1时的最大子数组和</p>\n</li>\n<li>\n<p>答案从 k = 2 的串联结果得到，第一部分的后缀和的最大值加上第二部分的前缀和的最大值。</p>\n</li>\n<li>\n<p>答案从整个串联 k &gt; 2 次后的结果得到，且一定是第一部分的后缀和的最大值，中间部分的总和，加上最后一部分的前缀和的最大值。</p>\n</li>\n</ul>\n<p>第二种可能从<strong>当前前缀和</strong>减去<strong>当前前缀和的最小值</strong>得到。</p>\n<p>前缀和的最大值直接可以维护出来，后缀和的最大值可以通过总和减去前缀和的最小值得到。</p>\n<h4 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\"></a> 实现</h4>\n<p>需要维护数组的 <strong>总和</strong>, <strong>最大前缀和</strong> , <strong>最小前缀和</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> MOD = <span class=\"number\">1000_000_007</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kConcatenationMaxSum</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sumHelper(arr);</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] sum = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] maxL = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] minL = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n + <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">        sum[i] = sum[i - <span class=\"number\">1</span>] + arr[i];</span><br><span class=\"line\">        maxL[i] = Math.max(maxL[i - <span class=\"number\">1</span>], sum[i]);</span><br><span class=\"line\">        minL[i] = Math.min(minL[i - <span class=\"number\">1</span>], sum[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) (Math.max(ans,</span><br><span class=\"line\">            Math.max(</span><br><span class=\"line\">                    sum[n] - minL[n] + maxL[n],</span><br><span class=\"line\">                    sum[n] - minL[n] + maxL[n] + sum[n] * (k - <span class=\"number\">2</span>)</span><br><span class=\"line\">            )</span><br><span class=\"line\">    ) % MOD);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">sumHelper</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> totalLen = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; totalLen; ++i) &#123;</span><br><span class=\"line\">        sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            max = Math.max(sum, max);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-查找集群内的关键连接\"><a class=\"markdownIt-Anchor\" href=\"#4-查找集群内的关键连接\"></a> 4. 查找集群内的「关键连接」</h2>\n<p>力扣数据中心有 <code>n</code> 台服务器，分别按从 <code>0</code> 到 <code>n-1</code> 的方式进行了编号。</p>\n<p>它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 <code>connections</code> 是无向的。</p>\n<p>从形式上讲，<code>connections[i] = [a, b]</code> 表示服务器 <code>a</code> 和 <code>b</code> 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。</p>\n<p>「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。</p>\n<p>请你以任意顺序返回该集群内的所有 「关键连接」。</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png\" alt=\"img\" /></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-寻找字符串中balloon个数\"><a class=\"markdownIt-Anchor\" href=\"#1-寻找字符串中balloon个数\"></a> 1. 寻找字符串中Balloon个数</h2>\n<p>给你一个字符串 <code>text</code>，你需要使用 <code>text</code> 中的字母来拼凑尽可能多的单词 <strong>“balloon”（气球）</strong>。</p>\n<p>字符串 <code>text</code> 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 <strong>“balloon”</strong>。</p>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路：</h3>\n<p>很快可以通过哈希表来建立一个 <code>字符到字符在text中出现次数</code>的映射, 然后根据<code>ballon</code> 来进行对照得出最终结果: 一定是 { <code>b</code> 出现次数 , <code>a</code> 出现次数 , <code>n</code> 出现次数 , <code>l</code> 出现次数的一半 , <code>o</code> 出现次数的一半 } 中的最小值, 即满足</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxNumberOfBalloons</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; text.length(); ++i) &#123;</span><br><span class=\"line\">            map.put(text.charAt(i), map.getOrDefault(text.charAt(i), <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = map.getOrDefault(<span class=\"string\">&#x27;b&#x27;</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">                a = map.getOrDefault(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">                l = map.getOrDefault(<span class=\"string\">&#x27;l&#x27;</span>, <span class=\"number\">0</span>) / <span class=\"number\">2</span>,</span><br><span class=\"line\">                o = map.getOrDefault(<span class=\"string\">&#x27;o&#x27;</span>, <span class=\"number\">0</span>) / <span class=\"number\">2</span>,</span><br><span class=\"line\">                n = map.getOrDefault(<span class=\"string\">&#x27;n&#x27;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.min(b, Math.min(a, Math.min(l, Math.min(o, n))));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-反转每对括号间的子串\"><a class=\"markdownIt-Anchor\" href=\"#2-反转每对括号间的子串\"></a> 2. 反转每对括号间的子串</h2>\n<p>给出一个字符串 <code>s</code>（仅含有小写英文字母和括号）。</p>\n<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>\n<p>注意，您的结果中 <strong>不应</strong> 包含任何括号。</p>\n<h3 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\"></a> 思路：</h3>\n<p>很明显这是一个 <strong>递归</strong> 问题. 举例说明</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"attr\">s</span> = <span class=\"string\">&quot;(u(love)i)&quot;</span></span><br></pre></td></tr></table></figure>\n<p>我们需要先找出 <strong>最小匹配括号子串</strong> , 将其翻转之后, 再对其父级的子串进行翻转.</p>\n<p>但是有一个比较坑的点, 测试用例里面有这样的 <code>a()b(((c)))de</code> ， 也就是说，可以存在平级的括号. 这一点当时没想到. 从这里我们需要改变想法：</p>\n<ul>\n<li>当遇到同级的括号，先处理过当前的 <code>()</code> 对，然后继续使用 ReverseParentheses 来对后续同级括号进行翻转. 这个属于迭代式的处理</li>\n<li>当遇到子级括号, 也就是正常的 <code>(d(c))</code>这样的情况，就使用递归函数解决</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">reverseParentheses</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> begin = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(i) == <span class=\"string\">&#x27;(&#x27;</span>)</span><br><span class=\"line\">            begin = i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(i) == <span class=\"string\">&#x27;)&#x27;</span>) &#123;</span><br><span class=\"line\">            end = i;</span><br><span class=\"line\">            String temp = s.substring(begin + <span class=\"number\">1</span>, end);<span class=\"comment\">//最小 ()</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> reverseParentheses(s.substring(<span class=\"number\">0</span>, begin) + reverseString(temp) + s.substring(end + <span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">String <span class=\"title\">reverseString</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] temp = s.toCharArray();</span><br><span class=\"line\">    StringBuilder r = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = temp.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        r.append(temp[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-k次串联数组之后的最大子数组之和\"><a class=\"markdownIt-Anchor\" href=\"#3-k次串联数组之后的最大子数组之和\"></a> 3. k次串联数组之后的最大子数组之和</h2>\n<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code>。</p>\n<p>首先，我们要对该数组进行修改，即把原数组 <code>arr</code> 重复 <code>k</code> 次。</p>\n<blockquote>\n<p>举个例子，如果 <code>arr = [1, 2]</code> 且 <code>k = 3</code>，那么修改后的数组就是 <code>[1, 2, 1, 2, 1, 2]</code>。</p>\n</blockquote>\n<p>然后，请你返回修改后的数组中的最大的子数组之和。</p>\n<p>注意，子数组长度可以是 <code>0</code>，在这种情况下它的总和也是 <code>0</code>。</p>\n<p>由于 <strong>结果可能会很大</strong>，所以需要 <strong>模（mod）</strong> <code>10^9 + 7</code> 后再返回。</p>\n<h3 id=\"思路-3\"><a class=\"markdownIt-Anchor\" href=\"#思路-3\"></a> 思路：</h3>\n<p>一看，这个不就是最大子数组的翻版吗 hhh , 那么直接贪心上啊</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> MOD = <span class=\"number\">1000_000_007</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">sumHelper</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalLen = arr.length * k;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; totalLen; ++i) &#123;</span><br><span class=\"line\">            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                max = Math.max(sum, max);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>那么问题来了，<strong>TLE</strong> 了. 也就是说，这个算法不容忍 <strong>O(N)</strong> 的时间复杂度. 我们需要找到数组在进行串联的时候的一个和数关系来进行快速获取答案.</p>\n<h4 id=\"分析\"><a class=\"markdownIt-Anchor\" href=\"#分析\"></a> 分析：</h4>\n<p>前缀和判断，一共如下可能</p>\n<ul>\n<li>\n<p>答案为 0</p>\n</li>\n<li>\n<p>答案仅从当前不串联的数组中得到, 即 k = 1时的最大子数组和</p>\n</li>\n<li>\n<p>答案从 k = 2 的串联结果得到，第一部分的后缀和的最大值加上第二部分的前缀和的最大值。</p>\n</li>\n<li>\n<p>答案从整个串联 k &gt; 2 次后的结果得到，且一定是第一部分的后缀和的最大值，中间部分的总和，加上最后一部分的前缀和的最大值。</p>\n</li>\n</ul>\n<p>第二种可能从<strong>当前前缀和</strong>减去<strong>当前前缀和的最小值</strong>得到。</p>\n<p>前缀和的最大值直接可以维护出来，后缀和的最大值可以通过总和减去前缀和的最小值得到。</p>\n<h4 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\"></a> 实现</h4>\n<p>需要维护数组的 <strong>总和</strong>, <strong>最大前缀和</strong> , <strong>最小前缀和</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> MOD = <span class=\"number\">1000_000_007</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kConcatenationMaxSum</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sumHelper(arr);</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] sum = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] maxL = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] minL = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n + <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">        sum[i] = sum[i - <span class=\"number\">1</span>] + arr[i];</span><br><span class=\"line\">        maxL[i] = Math.max(maxL[i - <span class=\"number\">1</span>], sum[i]);</span><br><span class=\"line\">        minL[i] = Math.min(minL[i - <span class=\"number\">1</span>], sum[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) (Math.max(ans,</span><br><span class=\"line\">            Math.max(</span><br><span class=\"line\">                    sum[n] - minL[n] + maxL[n],</span><br><span class=\"line\">                    sum[n] - minL[n] + maxL[n] + sum[n] * (k - <span class=\"number\">2</span>)</span><br><span class=\"line\">            )</span><br><span class=\"line\">    ) % MOD);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">sumHelper</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> totalLen = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; totalLen; ++i) &#123;</span><br><span class=\"line\">        sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            max = Math.max(sum, max);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-查找集群内的关键连接\"><a class=\"markdownIt-Anchor\" href=\"#4-查找集群内的关键连接\"></a> 4. 查找集群内的「关键连接」</h2>\n<p>力扣数据中心有 <code>n</code> 台服务器，分别按从 <code>0</code> 到 <code>n-1</code> 的方式进行了编号。</p>\n<p>它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 <code>connections</code> 是无向的。</p>\n<p>从形式上讲，<code>connections[i] = [a, b]</code> 表示服务器 <code>a</code> 和 <code>b</code> 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。</p>\n<p>「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。</p>\n<p>请你以任意顺序返回该集群内的所有 「关键连接」。</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png\" alt=\"img\" /></p>\n"},{"title":"Redis-基本数据结构","date":"2020-03-24T02:03:53.000Z","cover_img":"https://images.unsplash.com/photo-1522968941782-e27ac665baa3?ixlib=rb-1.2.1&auto=format&fit=crop&w=634&q=80","cover":"https://images.unsplash.com/photo-1522968941782-e27ac665baa3?ixlib=rb-1.2.1&auto=format&fit=crop&w=634&q=80","feature_img":"https://images.unsplash.com/photo-1518976024611-28bf4b48222e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=632&q=80","description":null,"keywords":"Redis","_content":"\n## Redis 基本数据结构\n\n> *Redis* 的数据类型有五大类，分别是 **列表、字符串、哈希表、有序集合、无序集合**\n>\n> 字符串底层：SDS\n>\n> 列表底层：链表或者是 *ziplist* 压缩列表\n>\n> 哈希对象：ziplist 或者是 hashtable\n>\n> 集合：*intset* 或 *hashtable*\n>\n> 有序集合：*ziplist* 或 *skiplist & dictionary*\n\n底层的数据结构实现讲解\n\n### 简单动态字符串 SDS\n\n#### 涉及数据结构\n\n```c\nstruct sdshdr\n{\n\n    // buf 中已占用空间的长度\n    int len;\n\n    // buf 中剩余可用空间的长度\n    int free;\n\n    // 数据空间\n    char buf[];\n};\n```\n\n#### 空间预加载策略\n\n当我们进行 `sdscat(sds s1 , const char* t)` 的时候，**可能** 会引发空间重新分配\n\n- 如果 **free space** 足够，那么不进行分配\n- 如果不够，看 **t** 的大小是不是超过 1M (`SDS_MAX_PREALLOC`- $1024\\times 1024$) \n  - 超过 **1M** ，直接 `newLen + SDS_MAX_PREALLOC`\n  - 否则 `newLen = newLen * 2`\n\n```c\nsds sdsMakeRoomFor(sds s, size_t addlen) {\n\n    struct sdshdr *sh, *newsh;\n\n    // 获取 s 目前的空余空间长度\n    size_t free = sdsavail(s);\n\n    size_t len, newlen;\n\n    // s 目前的空余空间已经足够，无须再进行扩展，直接返回\n    if (free >= addlen) return s;\n\n    // 获取 s 目前已占用空间的长度\n    len = sdslen(s);\n    sh = (void*) (s-(sizeof(struct sdshdr)));\n\n    // s 最少需要的长度\n    newlen = (len+addlen);\n\n    // 根据新长度，为 s 分配新空间所需的大小\n    if (newlen < SDS_MAX_PREALLOC)\n        // 如果新长度小于 SDS_MAX_PREALLOC \n        // 那么为它分配两倍于所需长度的空间\n        newlen *= 2;\n    else\n        // 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC\n        newlen += SDS_MAX_PREALLOC;\n    // T = O(N)\n    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);\n\n    // 内存不足，分配失败，返回\n    if (newsh == NULL) return NULL;\n\n    // 更新 sds 的空余长度\n    newsh->free = newlen - len;\n\n    // 返回 sds\n    return newsh->buf;\n}\n```\n\n#### 空间懒释放策略\n\n`sdstrim(sds s, const char*)` 会削减掉 **s** 两边的字符\n\n去掉之后，我们不改变 **len** , 而是作为 **free space** 进行了保留\n\n#### 二进制安全\n\n对于普通的 **C** 字符串，由于是按照空串 `\\0` 来作为结束标志\n\n而对于 **SDS** ，它使用的 **len** 字段就可以避免这一点\n\n\n\n### 链表\n\n基本的数据结构——双向链表\n\n```c\n/*\n * 双端链表节点\n */\ntypedef struct listNode {\n\n    // 前置节点\n    struct listNode *prev;\n\n    // 后置节点\n    struct listNode *next;\n\n    // 节点的值\n    void *value;\n\n} listNode;\n\n/*\n * 双端链表迭代器\n */\ntypedef struct listIter {\n\n    // **当前**迭代到的节点\n    listNode *next;\n\n    // 迭代的方向\n    int direction;\n\n} listIter;\n\n/*\n * 双端链表结构\n */\ntypedef struct list {\n\n    // 表头节点\n    listNode *head;\n\n    // 表尾节点\n    listNode *tail;\n\n    // 节点值复制函数\n    void *(*dup)(void *ptr);\n\n    // 节点值释放函数\n    void (*free)(void *ptr);\n\n    // 节点值对比函数\n    int (*match)(void *ptr, void *key);\n\n    // 链表所包含的节点数量\n    unsigned long len;\n\n} list;\n\n```\n\n可以看出，**Redis**中的list采取了双端链表来进行实现。结构体内部包含了：\n\n- 头结点、尾结点\n- 链表长度\n- 三个支持多态的函数指针\n\n\n\n### 字典 hash\n\nRedis中称作 **字典**。它的实现上都是采取了 **链地址法** 的哈希表结构。\n\n> *redis* 后续还引入了 *zipmap* 来作为 `字符串到字符串`的小*hash* 底层数据结构\n\n### 主要数据结构\n\n```C\n/*\n * 哈希表节点\n */\ntypedef struct dictEntry {\n    \n    // 键\n    void *key;\n\n    // 值\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v;\n\n    // 指向下个哈希表节点，形成链表\n    struct dictEntry *next;\n\n} dictEntry;\n\n\n/*\n * 哈希表\n *\n * 每个字典都使用**两个**哈希表，从而实现渐进式 rehash 。\n */\ntypedef struct dictht {\n    \n    // 哈希表数组\n    dictEntry **table;\n\n    // 哈希表大小\n    unsigned long size;\n    \n    // 哈希表大小掩码，用于计算索引值\n    // 总是等于 size - 1\n    unsigned long sizemask;\n\n    // 该哈希表已有节点的数量\n    unsigned long used;\n\n} dictht;\n//=======================================\n/*\n * 字典\n */\ntypedef struct dict {\n\n    // 类型特定函数\n    dictType *type;\n\n    // 私有数据\n    void *privdata;\n\n    // 哈希表\n    dictht ht[2];\n\n    // rehash 索引\n    // 当 rehash 不在进行时，值为 -1\n    int rehashidx; /* rehashing not in progress if rehashidx == -1 */\n\n    // 目前正在运行的安全迭代器的数量\n    int iterators; /* number of iterators currently running */\n\n} dict;\n```\n\n可以看出，**Entry** 作为节点，维护了 `K,V` 关系；哈希表维护了基本的**哈希表大小**和**已占用Hash数量**。\n\n#### 哈希算法\n\n根据 `hashFunc(key)` 可以得到哈希值 **hash** 。但是这个值往往很大，需要规整到 `[0,size-1]` 范围内，所以我们使用 `hash & mask` 来进行 **模计算**。这里的 **mask** 为 `size - 1` \n\n##### 再哈希\n\n> 大多数的哈希表实现思路类似——**size**都需要是 **2的幂次**，便于进行和掩码的与运算\n\n`dict` 结构中，采用了 `dictht ht[2];` 两个哈希表来进行。一般 `ht[0]` 存储数据，当要进行再哈希的时候，先给 `ht[1]` 分配一定的空间，随后把 `ht[0] ` 的数据再哈希到 `ht[1]` 当中。完成之后，释放 `ht[0]` 空间，调换两个指针 (类似*JVM* *survivor0，1* 的拷贝)\n\n-  如果进行的是扩展操作，那么*rehash* 之后的大小是 大于等于 `ht[0].used * 2` 的第一个 $2^n$  (和 *Java*的实现有点区别，*redis* 这里是针对已经使用的大小乘以二，然后再找到不小于这个数的第一个二的次幂)\n- 如果是伸缩操作，那么 *rehash* 之后的大小是 大于等于  `ht[0].used` 的第一个 $2^n$ \n\n随后，我们进行一个再哈希 (也就是根据新的大小重新分配 `K,V` ) ，放置到 `ht[1]`。随后互换两者指针即可。\n\n##### 渐进式再哈希\n\n再哈希时的数据拷贝工作是最耗时的。Redis 采用 **rehashidx** 来进行渐进式的处理。\n\n- 初始值设置为0，表示再哈希开始\n- 每一次对哈希表的增删改查，都会随即触发再哈希。\n  - 仅仅再哈希 **rehashidx** 索引对应的节点\n  - 此时的增删改查涉及到两个哈希表\n- 完成所有的再哈希之后，设置为 -1，表示完成\n\n> 通过将再哈希的行为，均摊到增删改查当中，避免了集中式的再哈希操作\n\n### 集合\n\n#### 跳表——有序集合key的底层实现\n\n> 使用于有序集合元素数量大，或者元素成员是字符串类型\n>\n> 跳表还使用在了集群节点中的内部数据结构\n\n##### 跳表节点定义\n\n每一个节点内部，除了基本的数据 `robj` ，还包含了后退指针，以及一个 `level` 数组\n\n```c\ntypedef struct zskiplistNode {\n\n    // 成员对象\n    robj *obj;\n\n    // 分值\n    double score;\n\n    // 后退指针\n    struct zskiplistNode *backward;\n\n    // 层\n    struct zskiplistLevel {\n\n        // 前进指针\n        struct zskiplistNode *forward;\n\n        // 跨度\n        unsigned int span;\n\n    } level[];\n\n} zskiplistNode;\n```\n\n##### 跳表定义\n\n```c\ntypedef struct zskiplist {\n\n    // 表头节点和表尾节点\n    struct zskiplistNode *header, *tail;\n\n    // 表中节点的数量\n    unsigned long length;\n\n    // 表中层数最大的节点的层数\n    int level;\n\n} zskiplist;\n```\n\n几个要点：\n\n- `level` 表示层，当有新的跳跃表节点 *insert* ，**level** 将会是 `[1,32]`之间的一个随机值\n  - 层的 **跨度** `level[i].span`，主要用于计算 **rank**。\n  - 对于某一个需要查询的节点，头结点到它的**跨度累积值**就是它的 **rank**\n- 前进指针和后退指针都是用于 **遍历**\n- 成员和分值\n  - 跳表内部按照分值由小到大来进行组织——从这一点上看，分值大的一般 **rank** 也大\n  - 分值可以重复，成员不可以\n\n*redis* 中的 **有序集合 zset** 使用了一个跳表 + 一个字典来进行实现。通过跳表来进行 *rank* 的从小到大排序，然后通过字典来实现对象到分值的一个映射。不会产生额外的数据空间浪费，并且能够让 **遍历** 和 **获取对象分值** 都能够有一个比较小的时间复杂度\n\n#### Intset 整数集合\n\n> 用于集合键的底层实现之一，如果集合只包含整数，并且数量不多，就采用整数集合来进行实现\n\n##### 数据结构\n\n```C\ntypedef struct intset {\n    \n    // 编码方式\n    uint32_t encoding;\n\n    // 集合包含的元素数量\n    uint32_t length;\n\n    // 保存元素的数组, 按照升序进行排列\n    int8_t contents[];\n\n} intset;\n```\n\n关注：\n\n- 编码方式决定了 **contents[]** 数组的元素的大小\n- 插入操作：\n  - 为了维护 **升序**关系，插入的时间复杂度是 $O(N)$ ——这里其实可以优化\n  - 若出现了大小超过编码的，需要进行 **升级**\n  - 不支持 **降级**\n\n\n\n### Ziplist 压缩列表\n\n> 可以用于基本的列表数据结构；也可以用于哈希字典 (键和值相邻排放) ，同时也是有序集合的底层实现之一。一般用于存储少量的列表项，并且列表项是一些小整数或小字符串\n\n","source":"_posts/Redis-基本数据结构.md","raw":"---\ntitle: Redis-基本数据结构\ndate: 2020-03-24 10:03:53\ntags: 笔记\ncover_img: https://images.unsplash.com/photo-1522968941782-e27ac665baa3?ixlib=rb-1.2.1&auto=format&fit=crop&w=634&q=80\ncover: https://images.unsplash.com/photo-1522968941782-e27ac665baa3?ixlib=rb-1.2.1&auto=format&fit=crop&w=634&q=80\nfeature_img: https://images.unsplash.com/photo-1518976024611-28bf4b48222e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=632&q=80\ndescription:\nkeywords: Redis\n---\n\n## Redis 基本数据结构\n\n> *Redis* 的数据类型有五大类，分别是 **列表、字符串、哈希表、有序集合、无序集合**\n>\n> 字符串底层：SDS\n>\n> 列表底层：链表或者是 *ziplist* 压缩列表\n>\n> 哈希对象：ziplist 或者是 hashtable\n>\n> 集合：*intset* 或 *hashtable*\n>\n> 有序集合：*ziplist* 或 *skiplist & dictionary*\n\n底层的数据结构实现讲解\n\n### 简单动态字符串 SDS\n\n#### 涉及数据结构\n\n```c\nstruct sdshdr\n{\n\n    // buf 中已占用空间的长度\n    int len;\n\n    // buf 中剩余可用空间的长度\n    int free;\n\n    // 数据空间\n    char buf[];\n};\n```\n\n#### 空间预加载策略\n\n当我们进行 `sdscat(sds s1 , const char* t)` 的时候，**可能** 会引发空间重新分配\n\n- 如果 **free space** 足够，那么不进行分配\n- 如果不够，看 **t** 的大小是不是超过 1M (`SDS_MAX_PREALLOC`- $1024\\times 1024$) \n  - 超过 **1M** ，直接 `newLen + SDS_MAX_PREALLOC`\n  - 否则 `newLen = newLen * 2`\n\n```c\nsds sdsMakeRoomFor(sds s, size_t addlen) {\n\n    struct sdshdr *sh, *newsh;\n\n    // 获取 s 目前的空余空间长度\n    size_t free = sdsavail(s);\n\n    size_t len, newlen;\n\n    // s 目前的空余空间已经足够，无须再进行扩展，直接返回\n    if (free >= addlen) return s;\n\n    // 获取 s 目前已占用空间的长度\n    len = sdslen(s);\n    sh = (void*) (s-(sizeof(struct sdshdr)));\n\n    // s 最少需要的长度\n    newlen = (len+addlen);\n\n    // 根据新长度，为 s 分配新空间所需的大小\n    if (newlen < SDS_MAX_PREALLOC)\n        // 如果新长度小于 SDS_MAX_PREALLOC \n        // 那么为它分配两倍于所需长度的空间\n        newlen *= 2;\n    else\n        // 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC\n        newlen += SDS_MAX_PREALLOC;\n    // T = O(N)\n    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);\n\n    // 内存不足，分配失败，返回\n    if (newsh == NULL) return NULL;\n\n    // 更新 sds 的空余长度\n    newsh->free = newlen - len;\n\n    // 返回 sds\n    return newsh->buf;\n}\n```\n\n#### 空间懒释放策略\n\n`sdstrim(sds s, const char*)` 会削减掉 **s** 两边的字符\n\n去掉之后，我们不改变 **len** , 而是作为 **free space** 进行了保留\n\n#### 二进制安全\n\n对于普通的 **C** 字符串，由于是按照空串 `\\0` 来作为结束标志\n\n而对于 **SDS** ，它使用的 **len** 字段就可以避免这一点\n\n\n\n### 链表\n\n基本的数据结构——双向链表\n\n```c\n/*\n * 双端链表节点\n */\ntypedef struct listNode {\n\n    // 前置节点\n    struct listNode *prev;\n\n    // 后置节点\n    struct listNode *next;\n\n    // 节点的值\n    void *value;\n\n} listNode;\n\n/*\n * 双端链表迭代器\n */\ntypedef struct listIter {\n\n    // **当前**迭代到的节点\n    listNode *next;\n\n    // 迭代的方向\n    int direction;\n\n} listIter;\n\n/*\n * 双端链表结构\n */\ntypedef struct list {\n\n    // 表头节点\n    listNode *head;\n\n    // 表尾节点\n    listNode *tail;\n\n    // 节点值复制函数\n    void *(*dup)(void *ptr);\n\n    // 节点值释放函数\n    void (*free)(void *ptr);\n\n    // 节点值对比函数\n    int (*match)(void *ptr, void *key);\n\n    // 链表所包含的节点数量\n    unsigned long len;\n\n} list;\n\n```\n\n可以看出，**Redis**中的list采取了双端链表来进行实现。结构体内部包含了：\n\n- 头结点、尾结点\n- 链表长度\n- 三个支持多态的函数指针\n\n\n\n### 字典 hash\n\nRedis中称作 **字典**。它的实现上都是采取了 **链地址法** 的哈希表结构。\n\n> *redis* 后续还引入了 *zipmap* 来作为 `字符串到字符串`的小*hash* 底层数据结构\n\n### 主要数据结构\n\n```C\n/*\n * 哈希表节点\n */\ntypedef struct dictEntry {\n    \n    // 键\n    void *key;\n\n    // 值\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n    } v;\n\n    // 指向下个哈希表节点，形成链表\n    struct dictEntry *next;\n\n} dictEntry;\n\n\n/*\n * 哈希表\n *\n * 每个字典都使用**两个**哈希表，从而实现渐进式 rehash 。\n */\ntypedef struct dictht {\n    \n    // 哈希表数组\n    dictEntry **table;\n\n    // 哈希表大小\n    unsigned long size;\n    \n    // 哈希表大小掩码，用于计算索引值\n    // 总是等于 size - 1\n    unsigned long sizemask;\n\n    // 该哈希表已有节点的数量\n    unsigned long used;\n\n} dictht;\n//=======================================\n/*\n * 字典\n */\ntypedef struct dict {\n\n    // 类型特定函数\n    dictType *type;\n\n    // 私有数据\n    void *privdata;\n\n    // 哈希表\n    dictht ht[2];\n\n    // rehash 索引\n    // 当 rehash 不在进行时，值为 -1\n    int rehashidx; /* rehashing not in progress if rehashidx == -1 */\n\n    // 目前正在运行的安全迭代器的数量\n    int iterators; /* number of iterators currently running */\n\n} dict;\n```\n\n可以看出，**Entry** 作为节点，维护了 `K,V` 关系；哈希表维护了基本的**哈希表大小**和**已占用Hash数量**。\n\n#### 哈希算法\n\n根据 `hashFunc(key)` 可以得到哈希值 **hash** 。但是这个值往往很大，需要规整到 `[0,size-1]` 范围内，所以我们使用 `hash & mask` 来进行 **模计算**。这里的 **mask** 为 `size - 1` \n\n##### 再哈希\n\n> 大多数的哈希表实现思路类似——**size**都需要是 **2的幂次**，便于进行和掩码的与运算\n\n`dict` 结构中，采用了 `dictht ht[2];` 两个哈希表来进行。一般 `ht[0]` 存储数据，当要进行再哈希的时候，先给 `ht[1]` 分配一定的空间，随后把 `ht[0] ` 的数据再哈希到 `ht[1]` 当中。完成之后，释放 `ht[0]` 空间，调换两个指针 (类似*JVM* *survivor0，1* 的拷贝)\n\n-  如果进行的是扩展操作，那么*rehash* 之后的大小是 大于等于 `ht[0].used * 2` 的第一个 $2^n$  (和 *Java*的实现有点区别，*redis* 这里是针对已经使用的大小乘以二，然后再找到不小于这个数的第一个二的次幂)\n- 如果是伸缩操作，那么 *rehash* 之后的大小是 大于等于  `ht[0].used` 的第一个 $2^n$ \n\n随后，我们进行一个再哈希 (也就是根据新的大小重新分配 `K,V` ) ，放置到 `ht[1]`。随后互换两者指针即可。\n\n##### 渐进式再哈希\n\n再哈希时的数据拷贝工作是最耗时的。Redis 采用 **rehashidx** 来进行渐进式的处理。\n\n- 初始值设置为0，表示再哈希开始\n- 每一次对哈希表的增删改查，都会随即触发再哈希。\n  - 仅仅再哈希 **rehashidx** 索引对应的节点\n  - 此时的增删改查涉及到两个哈希表\n- 完成所有的再哈希之后，设置为 -1，表示完成\n\n> 通过将再哈希的行为，均摊到增删改查当中，避免了集中式的再哈希操作\n\n### 集合\n\n#### 跳表——有序集合key的底层实现\n\n> 使用于有序集合元素数量大，或者元素成员是字符串类型\n>\n> 跳表还使用在了集群节点中的内部数据结构\n\n##### 跳表节点定义\n\n每一个节点内部，除了基本的数据 `robj` ，还包含了后退指针，以及一个 `level` 数组\n\n```c\ntypedef struct zskiplistNode {\n\n    // 成员对象\n    robj *obj;\n\n    // 分值\n    double score;\n\n    // 后退指针\n    struct zskiplistNode *backward;\n\n    // 层\n    struct zskiplistLevel {\n\n        // 前进指针\n        struct zskiplistNode *forward;\n\n        // 跨度\n        unsigned int span;\n\n    } level[];\n\n} zskiplistNode;\n```\n\n##### 跳表定义\n\n```c\ntypedef struct zskiplist {\n\n    // 表头节点和表尾节点\n    struct zskiplistNode *header, *tail;\n\n    // 表中节点的数量\n    unsigned long length;\n\n    // 表中层数最大的节点的层数\n    int level;\n\n} zskiplist;\n```\n\n几个要点：\n\n- `level` 表示层，当有新的跳跃表节点 *insert* ，**level** 将会是 `[1,32]`之间的一个随机值\n  - 层的 **跨度** `level[i].span`，主要用于计算 **rank**。\n  - 对于某一个需要查询的节点，头结点到它的**跨度累积值**就是它的 **rank**\n- 前进指针和后退指针都是用于 **遍历**\n- 成员和分值\n  - 跳表内部按照分值由小到大来进行组织——从这一点上看，分值大的一般 **rank** 也大\n  - 分值可以重复，成员不可以\n\n*redis* 中的 **有序集合 zset** 使用了一个跳表 + 一个字典来进行实现。通过跳表来进行 *rank* 的从小到大排序，然后通过字典来实现对象到分值的一个映射。不会产生额外的数据空间浪费，并且能够让 **遍历** 和 **获取对象分值** 都能够有一个比较小的时间复杂度\n\n#### Intset 整数集合\n\n> 用于集合键的底层实现之一，如果集合只包含整数，并且数量不多，就采用整数集合来进行实现\n\n##### 数据结构\n\n```C\ntypedef struct intset {\n    \n    // 编码方式\n    uint32_t encoding;\n\n    // 集合包含的元素数量\n    uint32_t length;\n\n    // 保存元素的数组, 按照升序进行排列\n    int8_t contents[];\n\n} intset;\n```\n\n关注：\n\n- 编码方式决定了 **contents[]** 数组的元素的大小\n- 插入操作：\n  - 为了维护 **升序**关系，插入的时间复杂度是 $O(N)$ ——这里其实可以优化\n  - 若出现了大小超过编码的，需要进行 **升级**\n  - 不支持 **降级**\n\n\n\n### Ziplist 压缩列表\n\n> 可以用于基本的列表数据结构；也可以用于哈希字典 (键和值相邻排放) ，同时也是有序集合的底层实现之一。一般用于存储少量的列表项，并且列表项是一些小整数或小字符串\n\n","slug":"Redis-基本数据结构","published":1,"updated":"2020-10-22T02:12:58.116Z","_id":"ckgk7k80f000706me653b5qee","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"redis-基本数据结构\"><a class=\"markdownIt-Anchor\" href=\"#redis-基本数据结构\"></a> Redis 基本数据结构</h2>\n<blockquote>\n<p><em>Redis</em> 的数据类型有五大类，分别是 <strong>列表、字符串、哈希表、有序集合、无序集合</strong></p>\n<p>字符串底层：SDS</p>\n<p>列表底层：链表或者是 <em>ziplist</em> 压缩列表</p>\n<p>哈希对象：ziplist 或者是 hashtable</p>\n<p>集合：<em>intset</em> 或 <em>hashtable</em></p>\n<p>有序集合：<em>ziplist</em> 或 <em>skiplist &amp; dictionary</em></p>\n</blockquote>\n<p>底层的数据结构实现讲解</p>\n<h3 id=\"简单动态字符串-sds\"><a class=\"markdownIt-Anchor\" href=\"#简单动态字符串-sds\"></a> 简单动态字符串 SDS</h3>\n<h4 id=\"涉及数据结构\"><a class=\"markdownIt-Anchor\" href=\"#涉及数据结构\"></a> 涉及数据结构</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// buf 中已占用空间的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// buf 中剩余可用空间的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据空间</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"空间预加载策略\"><a class=\"markdownIt-Anchor\" href=\"#空间预加载策略\"></a> 空间预加载策略</h4>\n<p>当我们进行 <code>sdscat(sds s1 , const char* t)</code> 的时候，<strong>可能</strong> 会引发空间重新分配</p>\n<ul>\n<li>如果 <strong>free space</strong> 足够，那么不进行分配</li>\n<li>如果不够，看 <strong>t</strong> 的大小是不是超过 1M (<code>SDS_MAX_PREALLOC</code>- <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1024</mn><mo>×</mo><mn>1024</mn></mrow><annotation encoding=\"application/x-tex\">1024\\times 1024</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">2</span><span class=\"mord\">4</span></span></span></span>)\n<ul>\n<li>超过 <strong>1M</strong> ，直接 <code>newLen + SDS_MAX_PREALLOC</code></li>\n<li>否则 <code>newLen = newLen * 2</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsMakeRoomFor</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> addlen)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span>, *<span class=\"title\">newsh</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 s 目前的空余空间长度</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> <span class=\"built_in\">free</span> = sdsavail(s);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len, newlen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">free</span> &gt;= addlen) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 s 目前已占用空间的长度</span></span><br><span class=\"line\">    len = sdslen(s);</span><br><span class=\"line\">    sh = (<span class=\"keyword\">void</span>*) (s-(<span class=\"keyword\">sizeof</span>(struct sdshdr)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// s 最少需要的长度</span></span><br><span class=\"line\">    newlen = (len+addlen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class=\"line\">        <span class=\"comment\">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class=\"line\">        <span class=\"comment\">// 那么为它分配两倍于所需长度的空间</span></span><br><span class=\"line\">        newlen *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class=\"line\">        newlen += SDS_MAX_PREALLOC;</span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    newsh = zrealloc(sh, <span class=\"keyword\">sizeof</span>(struct sdshdr)+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内存不足，分配失败，返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新 sds 的空余长度</span></span><br><span class=\"line\">    newsh-&gt;<span class=\"built_in\">free</span> = newlen - len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回 sds</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> newsh-&gt;buf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"空间懒释放策略\"><a class=\"markdownIt-Anchor\" href=\"#空间懒释放策略\"></a> 空间懒释放策略</h4>\n<p><code>sdstrim(sds s, const char*)</code> 会削减掉 <strong>s</strong> 两边的字符</p>\n<p>去掉之后，我们不改变 <strong>len</strong> , 而是作为 <strong>free space</strong> 进行了保留</p>\n<h4 id=\"二进制安全\"><a class=\"markdownIt-Anchor\" href=\"#二进制安全\"></a> 二进制安全</h4>\n<p>对于普通的 <strong>C</strong> 字符串，由于是按照空串 <code>\\0</code> 来作为结束标志</p>\n<p>而对于 <strong>SDS</strong> ，它使用的 <strong>len</strong> 字段就可以避免这一点</p>\n<h3 id=\"链表\"><a class=\"markdownIt-Anchor\" href=\"#链表\"></a> 链表</h3>\n<p>基本的数据结构——双向链表</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点的值</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; listNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listIter</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// **当前**迭代到的节点</span></span><br><span class=\"line\">    listNode *next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 迭代的方向</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> direction;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; listIter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表尾节点</span></span><br><span class=\"line\">    listNode *tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值复制函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值对比函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可以看出，<strong>Redis</strong>中的list采取了双端链表来进行实现。结构体内部包含了：</p>\n<ul>\n<li>头结点、尾结点</li>\n<li>链表长度</li>\n<li>三个支持多态的函数指针</li>\n</ul>\n<h3 id=\"字典-hash\"><a class=\"markdownIt-Anchor\" href=\"#字典-hash\"></a> 字典 hash</h3>\n<p>Redis中称作 <strong>字典</strong>。它的实现上都是采取了 <strong>链地址法</strong> 的哈希表结构。</p>\n<blockquote>\n<p><em>redis</em> 后续还引入了 <em>zipmap</em> 来作为 <code>字符串到字符串</code>的小<em>hash</em> 底层数据结构</p>\n</blockquote>\n<h3 id=\"主要数据结构\"><a class=\"markdownIt-Anchor\" href=\"#主要数据结构\"></a> 主要数据结构</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 哈希表节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指向下个哈希表节点，形成链表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; dictEntry;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 哈希表</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 每个字典都使用**两个**哈希表，从而实现渐进式 rehash 。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 哈希表数组</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小掩码，用于计算索引值</span></span><br><span class=\"line\">    <span class=\"comment\">// 总是等于 size - 1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 该哈希表已有节点的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; dictht;</span><br><span class=\"line\"><span class=\"comment\">//=======================================</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 字典</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 类型特定函数</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 私有数据</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// rehash 索引</span></span><br><span class=\"line\">    <span class=\"comment\">// 当 rehash 不在进行时，值为 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 目前正在运行的安全迭代器的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n<p>可以看出，<strong>Entry</strong> 作为节点，维护了 <code>K,V</code> 关系；哈希表维护了基本的<strong>哈希表大小</strong>和<strong>已占用Hash数量</strong>。</p>\n<h4 id=\"哈希算法\"><a class=\"markdownIt-Anchor\" href=\"#哈希算法\"></a> 哈希算法</h4>\n<p>根据 <code>hashFunc(key)</code> 可以得到哈希值 <strong>hash</strong> 。但是这个值往往很大，需要规整到 <code>[0,size-1]</code> 范围内，所以我们使用 <code>hash &amp; mask</code> 来进行 <strong>模计算</strong>。这里的 <strong>mask</strong> 为 <code>size - 1</code></p>\n<h5 id=\"再哈希\"><a class=\"markdownIt-Anchor\" href=\"#再哈希\"></a> 再哈希</h5>\n<blockquote>\n<p>大多数的哈希表实现思路类似——<strong>size</strong>都需要是 <strong>2的幂次</strong>，便于进行和掩码的与运算</p>\n</blockquote>\n<p><code>dict</code> 结构中，采用了 <code>dictht ht[2];</code> 两个哈希表来进行。一般 <code>ht[0]</code> 存储数据，当要进行再哈希的时候，先给 <code>ht[1]</code> 分配一定的空间，随后把 <code>ht[0]</code> 的数据再哈希到 <code>ht[1]</code> 当中。完成之后，释放 <code>ht[0]</code> 空间，调换两个指针 (类似<em>JVM</em> <em>survivor0，1</em> 的拷贝)</p>\n<ul>\n<li>如果进行的是扩展操作，那么<em>rehash</em> 之后的大小是 大于等于 <code>ht[0].used * 2</code> 的第一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span>  (和 <em>Java</em>的实现有点区别，<em>redis</em> 这里是针对已经使用的大小乘以二，然后再找到不小于这个数的第一个二的次幂)</li>\n<li>如果是伸缩操作，那么 <em>rehash</em> 之后的大小是 大于等于  <code>ht[0].used</code> 的第一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n<p>随后，我们进行一个再哈希 (也就是根据新的大小重新分配 <code>K,V</code> ) ，放置到 <code>ht[1]</code>。随后互换两者指针即可。</p>\n<h5 id=\"渐进式再哈希\"><a class=\"markdownIt-Anchor\" href=\"#渐进式再哈希\"></a> 渐进式再哈希</h5>\n<p>再哈希时的数据拷贝工作是最耗时的。Redis 采用 <strong>rehashidx</strong> 来进行渐进式的处理。</p>\n<ul>\n<li>初始值设置为0，表示再哈希开始</li>\n<li>每一次对哈希表的增删改查，都会随即触发再哈希。\n<ul>\n<li>仅仅再哈希 <strong>rehashidx</strong> 索引对应的节点</li>\n<li>此时的增删改查涉及到两个哈希表</li>\n</ul>\n</li>\n<li>完成所有的再哈希之后，设置为 -1，表示完成</li>\n</ul>\n<blockquote>\n<p>通过将再哈希的行为，均摊到增删改查当中，避免了集中式的再哈希操作</p>\n</blockquote>\n<h3 id=\"集合\"><a class=\"markdownIt-Anchor\" href=\"#集合\"></a> 集合</h3>\n<h4 id=\"跳表有序集合key的底层实现\"><a class=\"markdownIt-Anchor\" href=\"#跳表有序集合key的底层实现\"></a> 跳表——有序集合key的底层实现</h4>\n<blockquote>\n<p>使用于有序集合元素数量大，或者元素成员是字符串类型</p>\n<p>跳表还使用在了集群节点中的内部数据结构</p>\n</blockquote>\n<h5 id=\"跳表节点定义\"><a class=\"markdownIt-Anchor\" href=\"#跳表节点定义\"></a> 跳表节点定义</h5>\n<p>每一个节点内部，除了基本的数据 <code>robj</code> ，还包含了后退指针，以及一个 <code>level</code> 数组</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 成员对象</span></span><br><span class=\"line\">    robj *obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分值</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后退指针</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 层</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 前进指针</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 跨度</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> span;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n<h5 id=\"跳表定义\"><a class=\"markdownIt-Anchor\" href=\"#跳表定义\"></a> 跳表定义</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表头节点和表尾节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>, *<span class=\"title\">tail</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表中节点的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表中层数最大的节点的层数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure>\n<p>几个要点：</p>\n<ul>\n<li><code>level</code> 表示层，当有新的跳跃表节点 <em>insert</em> ，<strong>level</strong> 将会是 <code>[1,32]</code>之间的一个随机值\n<ul>\n<li>层的 <strong>跨度</strong> <code>level[i].span</code>，主要用于计算 <strong>rank</strong>。</li>\n<li>对于某一个需要查询的节点，头结点到它的<strong>跨度累积值</strong>就是它的 <strong>rank</strong></li>\n</ul>\n</li>\n<li>前进指针和后退指针都是用于 <strong>遍历</strong></li>\n<li>成员和分值\n<ul>\n<li>跳表内部按照分值由小到大来进行组织——从这一点上看，分值大的一般 <strong>rank</strong> 也大</li>\n<li>分值可以重复，成员不可以</li>\n</ul>\n</li>\n</ul>\n<p><em>redis</em> 中的 <strong>有序集合 zset</strong> 使用了一个跳表 + 一个字典来进行实现。通过跳表来进行 <em>rank</em> 的从小到大排序，然后通过字典来实现对象到分值的一个映射。不会产生额外的数据空间浪费，并且能够让 <strong>遍历</strong> 和 <strong>获取对象分值</strong> 都能够有一个比较小的时间复杂度</p>\n<h4 id=\"intset-整数集合\"><a class=\"markdownIt-Anchor\" href=\"#intset-整数集合\"></a> Intset 整数集合</h4>\n<blockquote>\n<p>用于集合键的底层实现之一，如果集合只包含整数，并且数量不多，就采用整数集合来进行实现</p>\n</blockquote>\n<h5 id=\"数据结构\"><a class=\"markdownIt-Anchor\" href=\"#数据结构\"></a> 数据结构</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span> &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 编码方式</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> encoding;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 集合包含的元素数量</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存元素的数组, 按照升序进行排列</span></span><br><span class=\"line\">    <span class=\"keyword\">int8_t</span> contents[];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; intset;</span><br></pre></td></tr></table></figure>\n<p>关注：</p>\n<ul>\n<li>编码方式决定了 <strong>contents[]</strong> 数组的元素的大小</li>\n<li>插入操作：\n<ul>\n<li>为了维护 <strong>升序</strong>关系，插入的时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> ——这里其实可以优化</li>\n<li>若出现了大小超过编码的，需要进行 <strong>升级</strong></li>\n<li>不支持 <strong>降级</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ziplist-压缩列表\"><a class=\"markdownIt-Anchor\" href=\"#ziplist-压缩列表\"></a> Ziplist 压缩列表</h3>\n<blockquote>\n<p>可以用于基本的列表数据结构；也可以用于哈希字典 (键和值相邻排放) ，同时也是有序集合的底层实现之一。一般用于存储少量的列表项，并且列表项是一些小整数或小字符串</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"redis-基本数据结构\"><a class=\"markdownIt-Anchor\" href=\"#redis-基本数据结构\"></a> Redis 基本数据结构</h2>\n<blockquote>\n<p><em>Redis</em> 的数据类型有五大类，分别是 <strong>列表、字符串、哈希表、有序集合、无序集合</strong></p>\n<p>字符串底层：SDS</p>\n<p>列表底层：链表或者是 <em>ziplist</em> 压缩列表</p>\n<p>哈希对象：ziplist 或者是 hashtable</p>\n<p>集合：<em>intset</em> 或 <em>hashtable</em></p>\n<p>有序集合：<em>ziplist</em> 或 <em>skiplist &amp; dictionary</em></p>\n</blockquote>\n<p>底层的数据结构实现讲解</p>\n<h3 id=\"简单动态字符串-sds\"><a class=\"markdownIt-Anchor\" href=\"#简单动态字符串-sds\"></a> 简单动态字符串 SDS</h3>\n<h4 id=\"涉及数据结构\"><a class=\"markdownIt-Anchor\" href=\"#涉及数据结构\"></a> 涉及数据结构</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// buf 中已占用空间的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// buf 中剩余可用空间的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据空间</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"空间预加载策略\"><a class=\"markdownIt-Anchor\" href=\"#空间预加载策略\"></a> 空间预加载策略</h4>\n<p>当我们进行 <code>sdscat(sds s1 , const char* t)</code> 的时候，<strong>可能</strong> 会引发空间重新分配</p>\n<ul>\n<li>如果 <strong>free space</strong> 足够，那么不进行分配</li>\n<li>如果不够，看 <strong>t</strong> 的大小是不是超过 1M (<code>SDS_MAX_PREALLOC</code>- <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1024</mn><mo>×</mo><mn>1024</mn></mrow><annotation encoding=\"application/x-tex\">1024\\times 1024</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">2</span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">2</span><span class=\"mord\">4</span></span></span></span>)\n<ul>\n<li>超过 <strong>1M</strong> ，直接 <code>newLen + SDS_MAX_PREALLOC</code></li>\n<li>否则 <code>newLen = newLen * 2</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsMakeRoomFor</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> addlen)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span>, *<span class=\"title\">newsh</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 s 目前的空余空间长度</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> <span class=\"built_in\">free</span> = sdsavail(s);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len, newlen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">free</span> &gt;= addlen) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 s 目前已占用空间的长度</span></span><br><span class=\"line\">    len = sdslen(s);</span><br><span class=\"line\">    sh = (<span class=\"keyword\">void</span>*) (s-(<span class=\"keyword\">sizeof</span>(struct sdshdr)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// s 最少需要的长度</span></span><br><span class=\"line\">    newlen = (len+addlen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class=\"line\">        <span class=\"comment\">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class=\"line\">        <span class=\"comment\">// 那么为它分配两倍于所需长度的空间</span></span><br><span class=\"line\">        newlen *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class=\"line\">        newlen += SDS_MAX_PREALLOC;</span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    newsh = zrealloc(sh, <span class=\"keyword\">sizeof</span>(struct sdshdr)+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内存不足，分配失败，返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新 sds 的空余长度</span></span><br><span class=\"line\">    newsh-&gt;<span class=\"built_in\">free</span> = newlen - len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回 sds</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> newsh-&gt;buf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"空间懒释放策略\"><a class=\"markdownIt-Anchor\" href=\"#空间懒释放策略\"></a> 空间懒释放策略</h4>\n<p><code>sdstrim(sds s, const char*)</code> 会削减掉 <strong>s</strong> 两边的字符</p>\n<p>去掉之后，我们不改变 <strong>len</strong> , 而是作为 <strong>free space</strong> 进行了保留</p>\n<h4 id=\"二进制安全\"><a class=\"markdownIt-Anchor\" href=\"#二进制安全\"></a> 二进制安全</h4>\n<p>对于普通的 <strong>C</strong> 字符串，由于是按照空串 <code>\\0</code> 来作为结束标志</p>\n<p>而对于 <strong>SDS</strong> ，它使用的 <strong>len</strong> 字段就可以避免这一点</p>\n<h3 id=\"链表\"><a class=\"markdownIt-Anchor\" href=\"#链表\"></a> 链表</h3>\n<p>基本的数据结构——双向链表</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点的值</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; listNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listIter</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// **当前**迭代到的节点</span></span><br><span class=\"line\">    listNode *next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 迭代的方向</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> direction;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; listIter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表尾节点</span></span><br><span class=\"line\">    listNode *tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值复制函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值对比函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>可以看出，<strong>Redis</strong>中的list采取了双端链表来进行实现。结构体内部包含了：</p>\n<ul>\n<li>头结点、尾结点</li>\n<li>链表长度</li>\n<li>三个支持多态的函数指针</li>\n</ul>\n<h3 id=\"字典-hash\"><a class=\"markdownIt-Anchor\" href=\"#字典-hash\"></a> 字典 hash</h3>\n<p>Redis中称作 <strong>字典</strong>。它的实现上都是采取了 <strong>链地址法</strong> 的哈希表结构。</p>\n<blockquote>\n<p><em>redis</em> 后续还引入了 <em>zipmap</em> 来作为 <code>字符串到字符串</code>的小<em>hash</em> 底层数据结构</p>\n</blockquote>\n<h3 id=\"主要数据结构\"><a class=\"markdownIt-Anchor\" href=\"#主要数据结构\"></a> 主要数据结构</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 哈希表节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"keyword\">int64_t</span> s64;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指向下个哈希表节点，形成链表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; dictEntry;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 哈希表</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 每个字典都使用**两个**哈希表，从而实现渐进式 rehash 。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span> &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 哈希表数组</span></span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小掩码，用于计算索引值</span></span><br><span class=\"line\">    <span class=\"comment\">// 总是等于 size - 1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 该哈希表已有节点的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; dictht;</span><br><span class=\"line\"><span class=\"comment\">//=======================================</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 字典</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 类型特定函数</span></span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 私有数据</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 哈希表</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// rehash 索引</span></span><br><span class=\"line\">    <span class=\"comment\">// 当 rehash 不在进行时，值为 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> rehashidx; <span class=\"comment\">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 目前正在运行的安全迭代器的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> iterators; <span class=\"comment\">/* number of iterators currently running */</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n<p>可以看出，<strong>Entry</strong> 作为节点，维护了 <code>K,V</code> 关系；哈希表维护了基本的<strong>哈希表大小</strong>和<strong>已占用Hash数量</strong>。</p>\n<h4 id=\"哈希算法\"><a class=\"markdownIt-Anchor\" href=\"#哈希算法\"></a> 哈希算法</h4>\n<p>根据 <code>hashFunc(key)</code> 可以得到哈希值 <strong>hash</strong> 。但是这个值往往很大，需要规整到 <code>[0,size-1]</code> 范围内，所以我们使用 <code>hash &amp; mask</code> 来进行 <strong>模计算</strong>。这里的 <strong>mask</strong> 为 <code>size - 1</code></p>\n<h5 id=\"再哈希\"><a class=\"markdownIt-Anchor\" href=\"#再哈希\"></a> 再哈希</h5>\n<blockquote>\n<p>大多数的哈希表实现思路类似——<strong>size</strong>都需要是 <strong>2的幂次</strong>，便于进行和掩码的与运算</p>\n</blockquote>\n<p><code>dict</code> 结构中，采用了 <code>dictht ht[2];</code> 两个哈希表来进行。一般 <code>ht[0]</code> 存储数据，当要进行再哈希的时候，先给 <code>ht[1]</code> 分配一定的空间，随后把 <code>ht[0]</code> 的数据再哈希到 <code>ht[1]</code> 当中。完成之后，释放 <code>ht[0]</code> 空间，调换两个指针 (类似<em>JVM</em> <em>survivor0，1</em> 的拷贝)</p>\n<ul>\n<li>如果进行的是扩展操作，那么<em>rehash</em> 之后的大小是 大于等于 <code>ht[0].used * 2</code> 的第一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span>  (和 <em>Java</em>的实现有点区别，<em>redis</em> 这里是针对已经使用的大小乘以二，然后再找到不小于这个数的第一个二的次幂)</li>\n<li>如果是伸缩操作，那么 <em>rehash</em> 之后的大小是 大于等于  <code>ht[0].used</code> 的第一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n<p>随后，我们进行一个再哈希 (也就是根据新的大小重新分配 <code>K,V</code> ) ，放置到 <code>ht[1]</code>。随后互换两者指针即可。</p>\n<h5 id=\"渐进式再哈希\"><a class=\"markdownIt-Anchor\" href=\"#渐进式再哈希\"></a> 渐进式再哈希</h5>\n<p>再哈希时的数据拷贝工作是最耗时的。Redis 采用 <strong>rehashidx</strong> 来进行渐进式的处理。</p>\n<ul>\n<li>初始值设置为0，表示再哈希开始</li>\n<li>每一次对哈希表的增删改查，都会随即触发再哈希。\n<ul>\n<li>仅仅再哈希 <strong>rehashidx</strong> 索引对应的节点</li>\n<li>此时的增删改查涉及到两个哈希表</li>\n</ul>\n</li>\n<li>完成所有的再哈希之后，设置为 -1，表示完成</li>\n</ul>\n<blockquote>\n<p>通过将再哈希的行为，均摊到增删改查当中，避免了集中式的再哈希操作</p>\n</blockquote>\n<h3 id=\"集合\"><a class=\"markdownIt-Anchor\" href=\"#集合\"></a> 集合</h3>\n<h4 id=\"跳表有序集合key的底层实现\"><a class=\"markdownIt-Anchor\" href=\"#跳表有序集合key的底层实现\"></a> 跳表——有序集合key的底层实现</h4>\n<blockquote>\n<p>使用于有序集合元素数量大，或者元素成员是字符串类型</p>\n<p>跳表还使用在了集群节点中的内部数据结构</p>\n</blockquote>\n<h5 id=\"跳表节点定义\"><a class=\"markdownIt-Anchor\" href=\"#跳表节点定义\"></a> 跳表节点定义</h5>\n<p>每一个节点内部，除了基本的数据 <code>robj</code> ，还包含了后退指针，以及一个 <code>level</code> 数组</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 成员对象</span></span><br><span class=\"line\">    robj *obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分值</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后退指针</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 层</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 前进指针</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 跨度</span></span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> span;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n<h5 id=\"跳表定义\"><a class=\"markdownIt-Anchor\" href=\"#跳表定义\"></a> 跳表定义</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表头节点和表尾节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>, *<span class=\"title\">tail</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表中节点的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表中层数最大的节点的层数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> level;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure>\n<p>几个要点：</p>\n<ul>\n<li><code>level</code> 表示层，当有新的跳跃表节点 <em>insert</em> ，<strong>level</strong> 将会是 <code>[1,32]</code>之间的一个随机值\n<ul>\n<li>层的 <strong>跨度</strong> <code>level[i].span</code>，主要用于计算 <strong>rank</strong>。</li>\n<li>对于某一个需要查询的节点，头结点到它的<strong>跨度累积值</strong>就是它的 <strong>rank</strong></li>\n</ul>\n</li>\n<li>前进指针和后退指针都是用于 <strong>遍历</strong></li>\n<li>成员和分值\n<ul>\n<li>跳表内部按照分值由小到大来进行组织——从这一点上看，分值大的一般 <strong>rank</strong> 也大</li>\n<li>分值可以重复，成员不可以</li>\n</ul>\n</li>\n</ul>\n<p><em>redis</em> 中的 <strong>有序集合 zset</strong> 使用了一个跳表 + 一个字典来进行实现。通过跳表来进行 <em>rank</em> 的从小到大排序，然后通过字典来实现对象到分值的一个映射。不会产生额外的数据空间浪费，并且能够让 <strong>遍历</strong> 和 <strong>获取对象分值</strong> 都能够有一个比较小的时间复杂度</p>\n<h4 id=\"intset-整数集合\"><a class=\"markdownIt-Anchor\" href=\"#intset-整数集合\"></a> Intset 整数集合</h4>\n<blockquote>\n<p>用于集合键的底层实现之一，如果集合只包含整数，并且数量不多，就采用整数集合来进行实现</p>\n</blockquote>\n<h5 id=\"数据结构\"><a class=\"markdownIt-Anchor\" href=\"#数据结构\"></a> 数据结构</h5>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span> &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 编码方式</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> encoding;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 集合包含的元素数量</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存元素的数组, 按照升序进行排列</span></span><br><span class=\"line\">    <span class=\"keyword\">int8_t</span> contents[];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; intset;</span><br></pre></td></tr></table></figure>\n<p>关注：</p>\n<ul>\n<li>编码方式决定了 <strong>contents[]</strong> 数组的元素的大小</li>\n<li>插入操作：\n<ul>\n<li>为了维护 <strong>升序</strong>关系，插入的时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> ——这里其实可以优化</li>\n<li>若出现了大小超过编码的，需要进行 <strong>升级</strong></li>\n<li>不支持 <strong>降级</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ziplist-压缩列表\"><a class=\"markdownIt-Anchor\" href=\"#ziplist-压缩列表\"></a> Ziplist 压缩列表</h3>\n<blockquote>\n<p>可以用于基本的列表数据结构；也可以用于哈希字典 (键和值相邻排放) ，同时也是有序集合的底层实现之一。一般用于存储少量的列表项，并且列表项是一些小整数或小字符串</p>\n</blockquote>\n"},{"title":"TCP/IP 阅读笔记(1)","date":"2019-12-14T14:24:04.000Z","description":"TCP协议基本内容","cover_img":"https://images.unsplash.com/photo-1465447142348-e9952c393450?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=968&q=80","cover":"https://images.unsplash.com/photo-1465447142348-e9952c393450?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=968&q=80","feature_img":"https://images.unsplash.com/photo-1519389950473-47ba0277781c?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80","_content":"\n### TCP连接形式\n\nTCP连接使用了一对套接字 (`socket`) 来进行唯一表示，也就是把 `IP` 头部的源和目的IP地址，携同TCP头部的源端口号和目的端口号，来进行一个标识。\n\n### Seq 与 Ack\n\n序列号与响应号是通信双方进行确认判定的依据。每一次报文中的响应号就是上一次报文的序列号  + 1 ，表示了接收方想要接收的下一个序列号。\n\n我们所熟知的三次握手，其实本质上就是发送方和接收方的序列号交换：\n\n> 第一次报文发送：SYN表明是客户端期望进行序列号同步，并且发送自己的序列号\n>\n> 第二次报文发送：SYN表示是服务端期望进行序列号同步，返回之前客户端的序列号 + 1 , 表示此时客户端序列号已经同步。此时还需要发送服务端自己的序列号，等待客户端是否给予最后一次响应。\n>\n> 第三次报文发送：ACK确实就是服务端序列号 + 1 的话，那么表明服务端的序列号也已经同步。至此通过三次报文交换来实现全双工通信的两端序列号同步。\n\n对于四次挥手，其实也是序列号的交换问题。\n\n书上的问题给出了进一步的思考：如果出现同时建立连接和同时断开连接，报文发送个数是多少？\n\n- 对于同时建立连接的情况，一开始同时就会有两次报文发送，这时候两个报文都是 SYN，期望同步自己的序列号。此时连接两端的两个 `socket` 其实都只需要得到自己想要的 `ACK` 就可以了。这时候就是四次报文交换\n- 对于同时断开连接的情况，和上面完全一样，也是四次\n\n### TIME_WAIT问题\n\n四次挥手结束之后，连接断开的发起者还会继续等待 `2MSL` 的时间长度，这种做法能够避免最后一次 **ACK** 因为网络问题没有发送到，给 **被动断开方** 时间进行超时重传。\n\n在发起者还在等待的时候，其实两端的端口还是在连接的状态。问题就来了——端口占用问题。\n\n也就是说，如果我们这时候在服务端或者客户端，断开 `socket` 却又立即重启，这时候就会出现端口占用的情况，导致我们的连接被拒绝。\n\n","source":"_posts/TCP-IP-阅读笔记-1.md","raw":"---\ntitle: TCP/IP 阅读笔记(1)\ndate: 2019-12-14 22:24:04\ntags: 读书笔记\ndescription: TCP协议基本内容\ncover_img: https://images.unsplash.com/photo-1465447142348-e9952c393450?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=968&q=80\ncover: https://images.unsplash.com/photo-1465447142348-e9952c393450?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=968&q=80\nfeature_img: https://images.unsplash.com/photo-1519389950473-47ba0277781c?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80\n---\n\n### TCP连接形式\n\nTCP连接使用了一对套接字 (`socket`) 来进行唯一表示，也就是把 `IP` 头部的源和目的IP地址，携同TCP头部的源端口号和目的端口号，来进行一个标识。\n\n### Seq 与 Ack\n\n序列号与响应号是通信双方进行确认判定的依据。每一次报文中的响应号就是上一次报文的序列号  + 1 ，表示了接收方想要接收的下一个序列号。\n\n我们所熟知的三次握手，其实本质上就是发送方和接收方的序列号交换：\n\n> 第一次报文发送：SYN表明是客户端期望进行序列号同步，并且发送自己的序列号\n>\n> 第二次报文发送：SYN表示是服务端期望进行序列号同步，返回之前客户端的序列号 + 1 , 表示此时客户端序列号已经同步。此时还需要发送服务端自己的序列号，等待客户端是否给予最后一次响应。\n>\n> 第三次报文发送：ACK确实就是服务端序列号 + 1 的话，那么表明服务端的序列号也已经同步。至此通过三次报文交换来实现全双工通信的两端序列号同步。\n\n对于四次挥手，其实也是序列号的交换问题。\n\n书上的问题给出了进一步的思考：如果出现同时建立连接和同时断开连接，报文发送个数是多少？\n\n- 对于同时建立连接的情况，一开始同时就会有两次报文发送，这时候两个报文都是 SYN，期望同步自己的序列号。此时连接两端的两个 `socket` 其实都只需要得到自己想要的 `ACK` 就可以了。这时候就是四次报文交换\n- 对于同时断开连接的情况，和上面完全一样，也是四次\n\n### TIME_WAIT问题\n\n四次挥手结束之后，连接断开的发起者还会继续等待 `2MSL` 的时间长度，这种做法能够避免最后一次 **ACK** 因为网络问题没有发送到，给 **被动断开方** 时间进行超时重传。\n\n在发起者还在等待的时候，其实两端的端口还是在连接的状态。问题就来了——端口占用问题。\n\n也就是说，如果我们这时候在服务端或者客户端，断开 `socket` 却又立即重启，这时候就会出现端口占用的情况，导致我们的连接被拒绝。\n\n","slug":"TCP-IP-阅读笔记-1","published":1,"updated":"2020-10-22T02:12:58.116Z","_id":"ckgk7k80g000906me3cy3gi8g","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"tcp连接形式\"><a class=\"markdownIt-Anchor\" href=\"#tcp连接形式\"></a> TCP连接形式</h3>\n<p>TCP连接使用了一对套接字 (<code>socket</code>) 来进行唯一表示，也就是把 <code>IP</code> 头部的源和目的IP地址，携同TCP头部的源端口号和目的端口号，来进行一个标识。</p>\n<h3 id=\"seq-与-ack\"><a class=\"markdownIt-Anchor\" href=\"#seq-与-ack\"></a> Seq 与 Ack</h3>\n<p>序列号与响应号是通信双方进行确认判定的依据。每一次报文中的响应号就是上一次报文的序列号  + 1 ，表示了接收方想要接收的下一个序列号。</p>\n<p>我们所熟知的三次握手，其实本质上就是发送方和接收方的序列号交换：</p>\n<blockquote>\n<p>第一次报文发送：SYN表明是客户端期望进行序列号同步，并且发送自己的序列号</p>\n<p>第二次报文发送：SYN表示是服务端期望进行序列号同步，返回之前客户端的序列号 + 1 , 表示此时客户端序列号已经同步。此时还需要发送服务端自己的序列号，等待客户端是否给予最后一次响应。</p>\n<p>第三次报文发送：ACK确实就是服务端序列号 + 1 的话，那么表明服务端的序列号也已经同步。至此通过三次报文交换来实现全双工通信的两端序列号同步。</p>\n</blockquote>\n<p>对于四次挥手，其实也是序列号的交换问题。</p>\n<p>书上的问题给出了进一步的思考：如果出现同时建立连接和同时断开连接，报文发送个数是多少？</p>\n<ul>\n<li>对于同时建立连接的情况，一开始同时就会有两次报文发送，这时候两个报文都是 SYN，期望同步自己的序列号。此时连接两端的两个 <code>socket</code> 其实都只需要得到自己想要的 <code>ACK</code> 就可以了。这时候就是四次报文交换</li>\n<li>对于同时断开连接的情况，和上面完全一样，也是四次</li>\n</ul>\n<h3 id=\"time_wait问题\"><a class=\"markdownIt-Anchor\" href=\"#time_wait问题\"></a> TIME_WAIT问题</h3>\n<p>四次挥手结束之后，连接断开的发起者还会继续等待 <code>2MSL</code> 的时间长度，这种做法能够避免最后一次 <strong>ACK</strong> 因为网络问题没有发送到，给 <strong>被动断开方</strong> 时间进行超时重传。</p>\n<p>在发起者还在等待的时候，其实两端的端口还是在连接的状态。问题就来了——端口占用问题。</p>\n<p>也就是说，如果我们这时候在服务端或者客户端，断开 <code>socket</code> 却又立即重启，这时候就会出现端口占用的情况，导致我们的连接被拒绝。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"tcp连接形式\"><a class=\"markdownIt-Anchor\" href=\"#tcp连接形式\"></a> TCP连接形式</h3>\n<p>TCP连接使用了一对套接字 (<code>socket</code>) 来进行唯一表示，也就是把 <code>IP</code> 头部的源和目的IP地址，携同TCP头部的源端口号和目的端口号，来进行一个标识。</p>\n<h3 id=\"seq-与-ack\"><a class=\"markdownIt-Anchor\" href=\"#seq-与-ack\"></a> Seq 与 Ack</h3>\n<p>序列号与响应号是通信双方进行确认判定的依据。每一次报文中的响应号就是上一次报文的序列号  + 1 ，表示了接收方想要接收的下一个序列号。</p>\n<p>我们所熟知的三次握手，其实本质上就是发送方和接收方的序列号交换：</p>\n<blockquote>\n<p>第一次报文发送：SYN表明是客户端期望进行序列号同步，并且发送自己的序列号</p>\n<p>第二次报文发送：SYN表示是服务端期望进行序列号同步，返回之前客户端的序列号 + 1 , 表示此时客户端序列号已经同步。此时还需要发送服务端自己的序列号，等待客户端是否给予最后一次响应。</p>\n<p>第三次报文发送：ACK确实就是服务端序列号 + 1 的话，那么表明服务端的序列号也已经同步。至此通过三次报文交换来实现全双工通信的两端序列号同步。</p>\n</blockquote>\n<p>对于四次挥手，其实也是序列号的交换问题。</p>\n<p>书上的问题给出了进一步的思考：如果出现同时建立连接和同时断开连接，报文发送个数是多少？</p>\n<ul>\n<li>对于同时建立连接的情况，一开始同时就会有两次报文发送，这时候两个报文都是 SYN，期望同步自己的序列号。此时连接两端的两个 <code>socket</code> 其实都只需要得到自己想要的 <code>ACK</code> 就可以了。这时候就是四次报文交换</li>\n<li>对于同时断开连接的情况，和上面完全一样，也是四次</li>\n</ul>\n<h3 id=\"time_wait问题\"><a class=\"markdownIt-Anchor\" href=\"#time_wait问题\"></a> TIME_WAIT问题</h3>\n<p>四次挥手结束之后，连接断开的发起者还会继续等待 <code>2MSL</code> 的时间长度，这种做法能够避免最后一次 <strong>ACK</strong> 因为网络问题没有发送到，给 <strong>被动断开方</strong> 时间进行超时重传。</p>\n<p>在发起者还在等待的时候，其实两端的端口还是在连接的状态。问题就来了——端口占用问题。</p>\n<p>也就是说，如果我们这时候在服务端或者客户端，断开 <code>socket</code> 却又立即重启，这时候就会出现端口占用的情况，导致我们的连接被拒绝。</p>\n"},{"title":"TCP-IP-阅读笔记-2 加密算法","date":"2020-02-17T11:50:35.000Z","cover_img":"https://images.unsplash.com/photo-1566664345779-062ed10879e0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1267&q=80","cover":"https://images.unsplash.com/photo-1566664345779-062ed10879e0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1267&q=80","feature_img":"https://images.unsplash.com/photo-1581893106728-1e2197903b0a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80","description":null,"keywords":null,"_content":"\n## 从HTTPs说起\n\n现实中和加密有关的网络攻击可以大致分为两种：**被动攻击**和 **主动攻击**。其中被动指的是攻击者窃听数据，信息传输双方很可能不知道攻击者的存在；而主动攻击更多的就是数据的伪造，直接导致信息传输中的数据改变。\n\n我们常见的数据传输有如下\n\n### 对称加密\n\n指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。\n常见的对称加密算法：DES，AES等。\n\n一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下：\n\n```\n明文 <-> 密钥 <-> 密文\n```\n\n这样的一种信息传输方式虽然**高效**，但是非常容易被第三方获取到密钥。一旦密钥泄露，那么被动攻击和主动攻击就都有可能。\n\n### 非对称加密\n\n每个人生成一个“私钥-公钥”对\n\n> 使用私钥加密的信息，只能由该私钥对应的公钥才能解密，使用公钥加密的信息，只能由该公钥对应的私钥才能解密\n\n```\n然后可以把你的public key分发给想给你传密文的用户，然后用户使用该public key加密过得密文，只有使用你的private key才能解密\n```\n\n简而言之，每一方自己生成 *private-public* 对，私钥由自己所有，而公钥可以自由地进行分享。通过这种方式进行的数据传输，相比之前的对称加密明显要安全很多——第三方在不知道私钥的情况下，无法窃听到传输的明文内容\n\n但这种方式无法避免**主动攻击**，也就是说，如果第三方在中间截获了某一方(**A**)的公钥，随后将自己的公钥进行替换 (美其名曰**偷梁换柱**)，让另一方(**B**)用 **假的** 公钥进行数据加密，那么这样第三方就可以轻松获取到**B**发送的信息；同时也可以往他们其中的某一方进行虚假数据的传输\n\n### HTTPs协议出场\n\n> 在我个人的理解当中，https兼并了对称加密和非对称加密，通过 **三对随机数** 来进行协商，随后实现 **每一次交互都可以生成不同的密钥条件下的对称加密传输**\n>\n\n 加粗的句话略有点绕口，我们慢慢说开来。\n\n在HTTPs下，我们的研究对象从原来的两个，增加另一个第三方——**证书(颁发者)**。我们可以简单地想成另外一对公钥私钥。那么现在我们就有了三对公钥和私钥，接下来的工作就是依据某一个协议来利用好这三对。\n\n#### 准备工作\n\n假定证书一方足够可靠 (也会出现证书造假的不安全情况发生，这里不提)，另外两方我们设定为**服务端**和**客户端**。\n\n- 对于服务端和客户端，都可以获取到证书的**公钥**\n- 服务端需要在协商之前 (连接建立之前)，将自己的公钥发给证书一方，如果服务端可以进行认证，那么服务端可以收到 **由证书方的私钥加密过后的公钥**，如下图：\n\n<img src=\"https://showme.codes/assets/images/2017-2-20-292372-f3dd4b7370df950e.png\" alt=\"第一版数字证书的内容\"  />\n\n#### 协商\n\n这样一来，我们的准备工作也就差不多了。那么之前那个密钥协商过程是如何进行的呢？\n\n- 首先进行常规的 TCP 三次握手工作\n- SSL一层建立在 TCP之上，HTTP之下。三次握手结束之后，**客户端** 发送一个 `client hello` 给服务端，其中包含了如下内容：\n  - 可支持的加密算法和版本\n  - 客户端生成的第一个随机数 **random1**\n\n- **服务端** 收到信息之后，需要验证是否兼容 **加密算法和版本** (不兼容就不能继续进行接下来的协商了)；若兼容，那么服务端生成第二个随机数 **random2** ，并且把我们之前服务端向证书机构加密过后的公钥也一起发送给 **客户端**。称这一步为 `serverhello`\n- **客户端** 需要先对服务端进行一下身份验证，在 CA 中验证合法性。验证通过之后，就可以使用证书颁发者的公钥，解密**得到服务端的公钥**。随后，客户端生成第三个随机数 **random3** ，使用服务端的公钥进行加密，再送回给服务端，我们称这个密文为 `PreMaster Key`\n- 服务端可以用自己的私钥，解密 `PreMaster Key` ， 得到第三个随机数。至此，三个随机数、此次HTTPs交互的加密算法，在两边都已经协商完成。只需要根据`加密算法 + 三个随机数`共同生成一个密钥，两方就可以得到一致的对称密钥\n- 此后的传输，直接可以使用该对称密钥进行加密解密\n\n#### 更多的思考\n\n> 为什么需要三个随机数？\n>\n> 保证每一次交互 (http连接) 之初生成的密钥具有随机性(加密算法可变，三个随机数可变)，那么居心叵测之人就无法得到密钥和加密算法内容","source":"_posts/TCP-IP-阅读笔记-2 加密.md","raw":"---\ntitle: TCP-IP-阅读笔记-2 加密算法\ndate: 2020-02-17 19:50:35\ntags: 笔记\ncover_img: https://images.unsplash.com/photo-1566664345779-062ed10879e0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1267&q=80\ncover: https://images.unsplash.com/photo-1566664345779-062ed10879e0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1267&q=80\nfeature_img: https://images.unsplash.com/photo-1581893106728-1e2197903b0a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80\ndescription:\nkeywords:\n---\n\n## 从HTTPs说起\n\n现实中和加密有关的网络攻击可以大致分为两种：**被动攻击**和 **主动攻击**。其中被动指的是攻击者窃听数据，信息传输双方很可能不知道攻击者的存在；而主动攻击更多的就是数据的伪造，直接导致信息传输中的数据改变。\n\n我们常见的数据传输有如下\n\n### 对称加密\n\n指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。\n常见的对称加密算法：DES，AES等。\n\n一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下：\n\n```\n明文 <-> 密钥 <-> 密文\n```\n\n这样的一种信息传输方式虽然**高效**，但是非常容易被第三方获取到密钥。一旦密钥泄露，那么被动攻击和主动攻击就都有可能。\n\n### 非对称加密\n\n每个人生成一个“私钥-公钥”对\n\n> 使用私钥加密的信息，只能由该私钥对应的公钥才能解密，使用公钥加密的信息，只能由该公钥对应的私钥才能解密\n\n```\n然后可以把你的public key分发给想给你传密文的用户，然后用户使用该public key加密过得密文，只有使用你的private key才能解密\n```\n\n简而言之，每一方自己生成 *private-public* 对，私钥由自己所有，而公钥可以自由地进行分享。通过这种方式进行的数据传输，相比之前的对称加密明显要安全很多——第三方在不知道私钥的情况下，无法窃听到传输的明文内容\n\n但这种方式无法避免**主动攻击**，也就是说，如果第三方在中间截获了某一方(**A**)的公钥，随后将自己的公钥进行替换 (美其名曰**偷梁换柱**)，让另一方(**B**)用 **假的** 公钥进行数据加密，那么这样第三方就可以轻松获取到**B**发送的信息；同时也可以往他们其中的某一方进行虚假数据的传输\n\n### HTTPs协议出场\n\n> 在我个人的理解当中，https兼并了对称加密和非对称加密，通过 **三对随机数** 来进行协商，随后实现 **每一次交互都可以生成不同的密钥条件下的对称加密传输**\n>\n\n 加粗的句话略有点绕口，我们慢慢说开来。\n\n在HTTPs下，我们的研究对象从原来的两个，增加另一个第三方——**证书(颁发者)**。我们可以简单地想成另外一对公钥私钥。那么现在我们就有了三对公钥和私钥，接下来的工作就是依据某一个协议来利用好这三对。\n\n#### 准备工作\n\n假定证书一方足够可靠 (也会出现证书造假的不安全情况发生，这里不提)，另外两方我们设定为**服务端**和**客户端**。\n\n- 对于服务端和客户端，都可以获取到证书的**公钥**\n- 服务端需要在协商之前 (连接建立之前)，将自己的公钥发给证书一方，如果服务端可以进行认证，那么服务端可以收到 **由证书方的私钥加密过后的公钥**，如下图：\n\n<img src=\"https://showme.codes/assets/images/2017-2-20-292372-f3dd4b7370df950e.png\" alt=\"第一版数字证书的内容\"  />\n\n#### 协商\n\n这样一来，我们的准备工作也就差不多了。那么之前那个密钥协商过程是如何进行的呢？\n\n- 首先进行常规的 TCP 三次握手工作\n- SSL一层建立在 TCP之上，HTTP之下。三次握手结束之后，**客户端** 发送一个 `client hello` 给服务端，其中包含了如下内容：\n  - 可支持的加密算法和版本\n  - 客户端生成的第一个随机数 **random1**\n\n- **服务端** 收到信息之后，需要验证是否兼容 **加密算法和版本** (不兼容就不能继续进行接下来的协商了)；若兼容，那么服务端生成第二个随机数 **random2** ，并且把我们之前服务端向证书机构加密过后的公钥也一起发送给 **客户端**。称这一步为 `serverhello`\n- **客户端** 需要先对服务端进行一下身份验证，在 CA 中验证合法性。验证通过之后，就可以使用证书颁发者的公钥，解密**得到服务端的公钥**。随后，客户端生成第三个随机数 **random3** ，使用服务端的公钥进行加密，再送回给服务端，我们称这个密文为 `PreMaster Key`\n- 服务端可以用自己的私钥，解密 `PreMaster Key` ， 得到第三个随机数。至此，三个随机数、此次HTTPs交互的加密算法，在两边都已经协商完成。只需要根据`加密算法 + 三个随机数`共同生成一个密钥，两方就可以得到一致的对称密钥\n- 此后的传输，直接可以使用该对称密钥进行加密解密\n\n#### 更多的思考\n\n> 为什么需要三个随机数？\n>\n> 保证每一次交互 (http连接) 之初生成的密钥具有随机性(加密算法可变，三个随机数可变)，那么居心叵测之人就无法得到密钥和加密算法内容","slug":"TCP-IP-阅读笔记-2 加密","published":1,"updated":"2020-10-22T02:12:58.117Z","_id":"ckgk7k80h000a06me347nhw48","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"从https说起\"><a class=\"markdownIt-Anchor\" href=\"#从https说起\"></a> 从HTTPs说起</h2>\n<p>现实中和加密有关的网络攻击可以大致分为两种：<strong>被动攻击</strong>和 <strong>主动攻击</strong>。其中被动指的是攻击者窃听数据，信息传输双方很可能不知道攻击者的存在；而主动攻击更多的就是数据的伪造，直接导致信息传输中的数据改变。</p>\n<p>我们常见的数据传输有如下</p>\n<h3 id=\"对称加密\"><a class=\"markdownIt-Anchor\" href=\"#对称加密\"></a> 对称加密</h3>\n<p>指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。<br />\n常见的对称加密算法：DES，AES等。</p>\n<p>一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">明文 <span class=\"tag\">&lt;<span class=\"name\">-</span>&gt;</span> 密钥 <span class=\"tag\">&lt;<span class=\"name\">-</span>&gt;</span> 密文</span><br></pre></td></tr></table></figure>\n<p>这样的一种信息传输方式虽然<strong>高效</strong>，但是非常容易被第三方获取到密钥。一旦密钥泄露，那么被动攻击和主动攻击就都有可能。</p>\n<h3 id=\"非对称加密\"><a class=\"markdownIt-Anchor\" href=\"#非对称加密\"></a> 非对称加密</h3>\n<p>每个人生成一个“私钥-公钥”对</p>\n<blockquote>\n<p>使用私钥加密的信息，只能由该私钥对应的公钥才能解密，使用公钥加密的信息，只能由该公钥对应的私钥才能解密</p>\n</blockquote>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">然后可以把你的<span class=\"keyword\">public</span> <span class=\"built_in\">key</span>分发给想给你传密文的用户，然后用户使用该<span class=\"keyword\">public</span> <span class=\"built_in\">key</span>加密过得密文，只有使用你的<span class=\"keyword\">private</span> <span class=\"built_in\">key</span>才能解密</span><br></pre></td></tr></table></figure>\n<p>简而言之，每一方自己生成 <em>private-public</em> 对，私钥由自己所有，而公钥可以自由地进行分享。通过这种方式进行的数据传输，相比之前的对称加密明显要安全很多——第三方在不知道私钥的情况下，无法窃听到传输的明文内容</p>\n<p>但这种方式无法避免<strong>主动攻击</strong>，也就是说，如果第三方在中间截获了某一方(<strong>A</strong>)的公钥，随后将自己的公钥进行替换 (美其名曰<strong>偷梁换柱</strong>)，让另一方(<strong>B</strong>)用 <strong>假的</strong> 公钥进行数据加密，那么这样第三方就可以轻松获取到<strong>B</strong>发送的信息；同时也可以往他们其中的某一方进行虚假数据的传输</p>\n<h3 id=\"https协议出场\"><a class=\"markdownIt-Anchor\" href=\"#https协议出场\"></a> HTTPs协议出场</h3>\n<blockquote>\n<p>在我个人的理解当中，https兼并了对称加密和非对称加密，通过 <strong>三对随机数</strong> 来进行协商，随后实现 <strong>每一次交互都可以生成不同的密钥条件下的对称加密传输</strong></p>\n</blockquote>\n<p>加粗的句话略有点绕口，我们慢慢说开来。</p>\n<p>在HTTPs下，我们的研究对象从原来的两个，增加另一个第三方——<strong>证书(颁发者)</strong>。我们可以简单地想成另外一对公钥私钥。那么现在我们就有了三对公钥和私钥，接下来的工作就是依据某一个协议来利用好这三对。</p>\n<h4 id=\"准备工作\"><a class=\"markdownIt-Anchor\" href=\"#准备工作\"></a> 准备工作</h4>\n<p>假定证书一方足够可靠 (也会出现证书造假的不安全情况发生，这里不提)，另外两方我们设定为<strong>服务端</strong>和<strong>客户端</strong>。</p>\n<ul>\n<li>对于服务端和客户端，都可以获取到证书的<strong>公钥</strong></li>\n<li>服务端需要在协商之前 (连接建立之前)，将自己的公钥发给证书一方，如果服务端可以进行认证，那么服务端可以收到 <strong>由证书方的私钥加密过后的公钥</strong>，如下图：</li>\n</ul>\n<img src=\"https://showme.codes/assets/images/2017-2-20-292372-f3dd4b7370df950e.png\" alt=\"第一版数字证书的内容\"  />\n<h4 id=\"协商\"><a class=\"markdownIt-Anchor\" href=\"#协商\"></a> 协商</h4>\n<p>这样一来，我们的准备工作也就差不多了。那么之前那个密钥协商过程是如何进行的呢？</p>\n<ul>\n<li>\n<p>首先进行常规的 TCP 三次握手工作</p>\n</li>\n<li>\n<p>SSL一层建立在 TCP之上，HTTP之下。三次握手结束之后，<strong>客户端</strong> 发送一个 <code>client hello</code> 给服务端，其中包含了如下内容：</p>\n<ul>\n<li>可支持的加密算法和版本</li>\n<li>客户端生成的第一个随机数 <strong>random1</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>服务端</strong> 收到信息之后，需要验证是否兼容 <strong>加密算法和版本</strong> (不兼容就不能继续进行接下来的协商了)；若兼容，那么服务端生成第二个随机数 <strong>random2</strong> ，并且把我们之前服务端向证书机构加密过后的公钥也一起发送给 <strong>客户端</strong>。称这一步为 <code>serverhello</code></p>\n</li>\n<li>\n<p><strong>客户端</strong> 需要先对服务端进行一下身份验证，在 CA 中验证合法性。验证通过之后，就可以使用证书颁发者的公钥，解密<strong>得到服务端的公钥</strong>。随后，客户端生成第三个随机数 <strong>random3</strong> ，使用服务端的公钥进行加密，再送回给服务端，我们称这个密文为 <code>PreMaster Key</code></p>\n</li>\n<li>\n<p>服务端可以用自己的私钥，解密 <code>PreMaster Key</code> ， 得到第三个随机数。至此，三个随机数、此次HTTPs交互的加密算法，在两边都已经协商完成。只需要根据<code>加密算法 + 三个随机数</code>共同生成一个密钥，两方就可以得到一致的对称密钥</p>\n</li>\n<li>\n<p>此后的传输，直接可以使用该对称密钥进行加密解密</p>\n</li>\n</ul>\n<h4 id=\"更多的思考\"><a class=\"markdownIt-Anchor\" href=\"#更多的思考\"></a> 更多的思考</h4>\n<blockquote>\n<p>为什么需要三个随机数？</p>\n<p>保证每一次交互 (http连接) 之初生成的密钥具有随机性(加密算法可变，三个随机数可变)，那么居心叵测之人就无法得到密钥和加密算法内容</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"从https说起\"><a class=\"markdownIt-Anchor\" href=\"#从https说起\"></a> 从HTTPs说起</h2>\n<p>现实中和加密有关的网络攻击可以大致分为两种：<strong>被动攻击</strong>和 <strong>主动攻击</strong>。其中被动指的是攻击者窃听数据，信息传输双方很可能不知道攻击者的存在；而主动攻击更多的就是数据的伪造，直接导致信息传输中的数据改变。</p>\n<p>我们常见的数据传输有如下</p>\n<h3 id=\"对称加密\"><a class=\"markdownIt-Anchor\" href=\"#对称加密\"></a> 对称加密</h3>\n<p>指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。<br />\n常见的对称加密算法：DES，AES等。</p>\n<p>一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">明文 <span class=\"tag\">&lt;<span class=\"name\">-</span>&gt;</span> 密钥 <span class=\"tag\">&lt;<span class=\"name\">-</span>&gt;</span> 密文</span><br></pre></td></tr></table></figure>\n<p>这样的一种信息传输方式虽然<strong>高效</strong>，但是非常容易被第三方获取到密钥。一旦密钥泄露，那么被动攻击和主动攻击就都有可能。</p>\n<h3 id=\"非对称加密\"><a class=\"markdownIt-Anchor\" href=\"#非对称加密\"></a> 非对称加密</h3>\n<p>每个人生成一个“私钥-公钥”对</p>\n<blockquote>\n<p>使用私钥加密的信息，只能由该私钥对应的公钥才能解密，使用公钥加密的信息，只能由该公钥对应的私钥才能解密</p>\n</blockquote>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">然后可以把你的<span class=\"keyword\">public</span> <span class=\"built_in\">key</span>分发给想给你传密文的用户，然后用户使用该<span class=\"keyword\">public</span> <span class=\"built_in\">key</span>加密过得密文，只有使用你的<span class=\"keyword\">private</span> <span class=\"built_in\">key</span>才能解密</span><br></pre></td></tr></table></figure>\n<p>简而言之，每一方自己生成 <em>private-public</em> 对，私钥由自己所有，而公钥可以自由地进行分享。通过这种方式进行的数据传输，相比之前的对称加密明显要安全很多——第三方在不知道私钥的情况下，无法窃听到传输的明文内容</p>\n<p>但这种方式无法避免<strong>主动攻击</strong>，也就是说，如果第三方在中间截获了某一方(<strong>A</strong>)的公钥，随后将自己的公钥进行替换 (美其名曰<strong>偷梁换柱</strong>)，让另一方(<strong>B</strong>)用 <strong>假的</strong> 公钥进行数据加密，那么这样第三方就可以轻松获取到<strong>B</strong>发送的信息；同时也可以往他们其中的某一方进行虚假数据的传输</p>\n<h3 id=\"https协议出场\"><a class=\"markdownIt-Anchor\" href=\"#https协议出场\"></a> HTTPs协议出场</h3>\n<blockquote>\n<p>在我个人的理解当中，https兼并了对称加密和非对称加密，通过 <strong>三对随机数</strong> 来进行协商，随后实现 <strong>每一次交互都可以生成不同的密钥条件下的对称加密传输</strong></p>\n</blockquote>\n<p>加粗的句话略有点绕口，我们慢慢说开来。</p>\n<p>在HTTPs下，我们的研究对象从原来的两个，增加另一个第三方——<strong>证书(颁发者)</strong>。我们可以简单地想成另外一对公钥私钥。那么现在我们就有了三对公钥和私钥，接下来的工作就是依据某一个协议来利用好这三对。</p>\n<h4 id=\"准备工作\"><a class=\"markdownIt-Anchor\" href=\"#准备工作\"></a> 准备工作</h4>\n<p>假定证书一方足够可靠 (也会出现证书造假的不安全情况发生，这里不提)，另外两方我们设定为<strong>服务端</strong>和<strong>客户端</strong>。</p>\n<ul>\n<li>对于服务端和客户端，都可以获取到证书的<strong>公钥</strong></li>\n<li>服务端需要在协商之前 (连接建立之前)，将自己的公钥发给证书一方，如果服务端可以进行认证，那么服务端可以收到 <strong>由证书方的私钥加密过后的公钥</strong>，如下图：</li>\n</ul>\n<img src=\"https://showme.codes/assets/images/2017-2-20-292372-f3dd4b7370df950e.png\" alt=\"第一版数字证书的内容\"  />\n<h4 id=\"协商\"><a class=\"markdownIt-Anchor\" href=\"#协商\"></a> 协商</h4>\n<p>这样一来，我们的准备工作也就差不多了。那么之前那个密钥协商过程是如何进行的呢？</p>\n<ul>\n<li>\n<p>首先进行常规的 TCP 三次握手工作</p>\n</li>\n<li>\n<p>SSL一层建立在 TCP之上，HTTP之下。三次握手结束之后，<strong>客户端</strong> 发送一个 <code>client hello</code> 给服务端，其中包含了如下内容：</p>\n<ul>\n<li>可支持的加密算法和版本</li>\n<li>客户端生成的第一个随机数 <strong>random1</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>服务端</strong> 收到信息之后，需要验证是否兼容 <strong>加密算法和版本</strong> (不兼容就不能继续进行接下来的协商了)；若兼容，那么服务端生成第二个随机数 <strong>random2</strong> ，并且把我们之前服务端向证书机构加密过后的公钥也一起发送给 <strong>客户端</strong>。称这一步为 <code>serverhello</code></p>\n</li>\n<li>\n<p><strong>客户端</strong> 需要先对服务端进行一下身份验证，在 CA 中验证合法性。验证通过之后，就可以使用证书颁发者的公钥，解密<strong>得到服务端的公钥</strong>。随后，客户端生成第三个随机数 <strong>random3</strong> ，使用服务端的公钥进行加密，再送回给服务端，我们称这个密文为 <code>PreMaster Key</code></p>\n</li>\n<li>\n<p>服务端可以用自己的私钥，解密 <code>PreMaster Key</code> ， 得到第三个随机数。至此，三个随机数、此次HTTPs交互的加密算法，在两边都已经协商完成。只需要根据<code>加密算法 + 三个随机数</code>共同生成一个密钥，两方就可以得到一致的对称密钥</p>\n</li>\n<li>\n<p>此后的传输，直接可以使用该对称密钥进行加密解密</p>\n</li>\n</ul>\n<h4 id=\"更多的思考\"><a class=\"markdownIt-Anchor\" href=\"#更多的思考\"></a> 更多的思考</h4>\n<blockquote>\n<p>为什么需要三个随机数？</p>\n<p>保证每一次交互 (http连接) 之初生成的密钥具有随机性(加密算法可变，三个随机数可变)，那么居心叵测之人就无法得到密钥和加密算法内容</p>\n</blockquote>\n"},{"title":"c++新特性","date":"2020-01-15T02:14:27.000Z","description":"虽说是新特性，但是C++ 11 & 14 已经推出了将近10年了.这次就好好整理一下","cover_img":"https://images.unsplash.com/photo-1565433435379-877a403f0f09?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80","cover":"https://images.unsplash.com/photo-1565433435379-877a403f0f09?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80","feature_img":"https://images.unsplash.com/photo-1534972195531-d756b9bfa9f2?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80","coverImg":"https://images.unsplash.com/photo-1565433435379-877a403f0f09?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80","top_img":"https://images.unsplash.com/photo-1565433435379-877a403f0f09?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80","_content":"\n## What’s new in C++ 11?\n\n###  storage duration specifier\n\n多个C++版本都对变量存储时间的定义有严格的说明\n\n- `auto` - *automatic* storage duration.\n\n- `register` - *automatic* storage duration. Also hints to the compiler to place the object in the processor's register. (deprecated) ——*since C++ 17*\n\n- `static` - *static* or *thread* storage duration and *internal* linkage\n\n- `extern` - *static* or *thread* storage duration and *external* linkage.\n\n- `thread_local` - *thread* storage duration\n\n  The `thread_local` keyword is only allowed for objects declared at namespace scope, objects declared at block scope, and static data members. It indicates that the object has **thread storage duration**. It can be combined with `static` or `extern` to specify internal or external linkage (except for static data members which always have external linkage), respectively, but that additional `static` doesn't affect the storage duration.\n\n- `mutable` - does not affect storage duration or linkage\n\n  注意：`mutable` 主要是标识 **const对象** 中某些可变的成员，实现了从二进制的物理 **const** 到逻辑 **const** (外观不变)\n\n### Variadic templates\n\n可变类模板，在 `c++ reference` 里面以 *parameter pack* 来代替\n\n```cpp\ntemplate<class... Types>\t\t\t//class ... Types 是一个 pack 的声明\t\nvoid f(Types... args) {}\t\t\t//Types... args 是\n```\n\n#### Pack Expansion\n\n- `&args...` 代表的是参数扩展\n- `&args`代表的是 *pack pattern* 本身\n\n### Move semantics\n\n> **凡是取地址（`&`）操作可以成功的都是左值，其余都是右值**\n>\n> - 等号左边的不一定是左值——可以通过操作符重载来让左部变成 **右值**\n\n#### 右值引用\n\n我们之前常见的都是 **左值引用**，指的是我们只能够将 **左值** 赋给一个引用。\n\n-  `int& a = 1` 就是非法的。而我们也可以 `int const& i = 42;` 来进行一个 *tricky* 的躲避\n\n  在 `c++11`中允许了右值引用的出现\n```\nint&& a = 3;\n```\n\n#### 移动语义\n\n我们在进行 `Test(const Test& test)` 拷贝构造函数的执行过程中，会造成很多的拷贝浪费。当单独的一次拷贝构造函数 (特别是对指针数组这些资源)过程消耗特别大的时候，对于性能来说是很低的。\n\n那么 `c++11`标准给出了 **移动拷贝构造函数** 和 **移动赋值操作符重载**。此外，还支持 `std::move()`来强制性让 **左值转化为右值**\n\n#### 完美转发\n\n我们想要实现\n\n> 多级函数调用过程中\n>\n> - 如果变量是左值，那么它作为其他函数的参数的时候也应该是 **左值**\n> - 如果变量是右值，那么它作为其他函数的参数的时候也应该是 **右值**\n\n```cpp\ntemplate <typename T>\nvoid func(T t) {\n    cout << \"in func\" << endl;\n}\n\ntemplate <typename T>\nvoid relay(T&& t) {\n    cout << \"in relay\" << endl;\n    func(t);\n}\n\nint main() {\n    relay(Test());\n}\n```\n\n上面这个例子就是一个 **反例**。我们在传入 `func(t)` 的时候，其实调用了 **拷贝构造函数** (因为编译器把 **t** 当做了一个 **左值**)\n\n> `std::forward<T>()` ，能够保留参数的左右值类型\n\n### Value Category\n\n不止左值右值那么简单\n\n> Cpp reference:\n>\n> Each C++ [expression](https://en.cppreference.com/w/cpp/language/expressions) (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a *type* and a *value category*. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: *prvalue*, *xvalue*, and *lvalue*.\n\n\n\n","source":"_posts/c-新特性.md","raw":"---\ntitle: c++新特性\ndate: 2020-01-15 10:14:27\ntags: 整理\ndescription: 虽说是新特性，但是C++ 11 & 14 已经推出了将近10年了.这次就好好整理一下\ncover_img: https://images.unsplash.com/photo-1565433435379-877a403f0f09?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80\ncover: https://images.unsplash.com/photo-1565433435379-877a403f0f09?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80\nfeature_img: https://images.unsplash.com/photo-1534972195531-d756b9bfa9f2?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80\ncoverImg: https://images.unsplash.com/photo-1565433435379-877a403f0f09?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80\ntop_img: https://images.unsplash.com/photo-1565433435379-877a403f0f09?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80\n---\n\n## What’s new in C++ 11?\n\n###  storage duration specifier\n\n多个C++版本都对变量存储时间的定义有严格的说明\n\n- `auto` - *automatic* storage duration.\n\n- `register` - *automatic* storage duration. Also hints to the compiler to place the object in the processor's register. (deprecated) ——*since C++ 17*\n\n- `static` - *static* or *thread* storage duration and *internal* linkage\n\n- `extern` - *static* or *thread* storage duration and *external* linkage.\n\n- `thread_local` - *thread* storage duration\n\n  The `thread_local` keyword is only allowed for objects declared at namespace scope, objects declared at block scope, and static data members. It indicates that the object has **thread storage duration**. It can be combined with `static` or `extern` to specify internal or external linkage (except for static data members which always have external linkage), respectively, but that additional `static` doesn't affect the storage duration.\n\n- `mutable` - does not affect storage duration or linkage\n\n  注意：`mutable` 主要是标识 **const对象** 中某些可变的成员，实现了从二进制的物理 **const** 到逻辑 **const** (外观不变)\n\n### Variadic templates\n\n可变类模板，在 `c++ reference` 里面以 *parameter pack* 来代替\n\n```cpp\ntemplate<class... Types>\t\t\t//class ... Types 是一个 pack 的声明\t\nvoid f(Types... args) {}\t\t\t//Types... args 是\n```\n\n#### Pack Expansion\n\n- `&args...` 代表的是参数扩展\n- `&args`代表的是 *pack pattern* 本身\n\n### Move semantics\n\n> **凡是取地址（`&`）操作可以成功的都是左值，其余都是右值**\n>\n> - 等号左边的不一定是左值——可以通过操作符重载来让左部变成 **右值**\n\n#### 右值引用\n\n我们之前常见的都是 **左值引用**，指的是我们只能够将 **左值** 赋给一个引用。\n\n-  `int& a = 1` 就是非法的。而我们也可以 `int const& i = 42;` 来进行一个 *tricky* 的躲避\n\n  在 `c++11`中允许了右值引用的出现\n```\nint&& a = 3;\n```\n\n#### 移动语义\n\n我们在进行 `Test(const Test& test)` 拷贝构造函数的执行过程中，会造成很多的拷贝浪费。当单独的一次拷贝构造函数 (特别是对指针数组这些资源)过程消耗特别大的时候，对于性能来说是很低的。\n\n那么 `c++11`标准给出了 **移动拷贝构造函数** 和 **移动赋值操作符重载**。此外，还支持 `std::move()`来强制性让 **左值转化为右值**\n\n#### 完美转发\n\n我们想要实现\n\n> 多级函数调用过程中\n>\n> - 如果变量是左值，那么它作为其他函数的参数的时候也应该是 **左值**\n> - 如果变量是右值，那么它作为其他函数的参数的时候也应该是 **右值**\n\n```cpp\ntemplate <typename T>\nvoid func(T t) {\n    cout << \"in func\" << endl;\n}\n\ntemplate <typename T>\nvoid relay(T&& t) {\n    cout << \"in relay\" << endl;\n    func(t);\n}\n\nint main() {\n    relay(Test());\n}\n```\n\n上面这个例子就是一个 **反例**。我们在传入 `func(t)` 的时候，其实调用了 **拷贝构造函数** (因为编译器把 **t** 当做了一个 **左值**)\n\n> `std::forward<T>()` ，能够保留参数的左右值类型\n\n### Value Category\n\n不止左值右值那么简单\n\n> Cpp reference:\n>\n> Each C++ [expression](https://en.cppreference.com/w/cpp/language/expressions) (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a *type* and a *value category*. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: *prvalue*, *xvalue*, and *lvalue*.\n\n\n\n","slug":"c-新特性","published":1,"updated":"2020-10-22T02:12:58.117Z","_id":"ckgk7k80i000e06me1rjjfcpv","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"whats-new-in-c-11\"><a class=\"markdownIt-Anchor\" href=\"#whats-new-in-c-11\"></a> What’s new in C++ 11?</h2>\n<h3 id=\"storage-duration-specifier\"><a class=\"markdownIt-Anchor\" href=\"#storage-duration-specifier\"></a> storage duration specifier</h3>\n<p>多个C++版本都对变量存储时间的定义有严格的说明</p>\n<ul>\n<li>\n<p><code>auto</code> - <em>automatic</em> storage duration.</p>\n</li>\n<li>\n<p><code>register</code> - <em>automatic</em> storage duration. Also hints to the compiler to place the object in the processor’s register. (deprecated) ——<em>since C++ 17</em></p>\n</li>\n<li>\n<p><code>static</code> - <em>static</em> or <em>thread</em> storage duration and <em>internal</em> linkage</p>\n</li>\n<li>\n<p><code>extern</code> - <em>static</em> or <em>thread</em> storage duration and <em>external</em> linkage.</p>\n</li>\n<li>\n<p><code>thread_local</code> - <em>thread</em> storage duration</p>\n<p>The <code>thread_local</code> keyword is only allowed for objects declared at namespace scope, objects declared at block scope, and static data members. It indicates that the object has <strong>thread storage duration</strong>. It can be combined with <code>static</code> or <code>extern</code> to specify internal or external linkage (except for static data members which always have external linkage), respectively, but that additional <code>static</code> doesn’t affect the storage duration.</p>\n</li>\n<li>\n<p><code>mutable</code> - does not affect storage duration or linkage</p>\n<p>注意：<code>mutable</code> 主要是标识 <strong>const对象</strong> 中某些可变的成员，实现了从二进制的物理 <strong>const</strong> 到逻辑 <strong>const</strong> (外观不变)</p>\n</li>\n</ul>\n<h3 id=\"variadic-templates\"><a class=\"markdownIt-Anchor\" href=\"#variadic-templates\"></a> Variadic templates</h3>\n<p>可变类模板，在 <code>c++ reference</code> 里面以 <em>parameter pack</em> 来代替</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;class... Types&gt;\t\t\t<span class=\"comment\">//class ... Types 是一个 pack 的声明\t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(Types... args)</span> </span>&#123;&#125;\t\t\t<span class=\"comment\">//Types... args 是</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"pack-expansion\"><a class=\"markdownIt-Anchor\" href=\"#pack-expansion\"></a> Pack Expansion</h4>\n<ul>\n<li><code>&amp;args...</code> 代表的是参数扩展</li>\n<li><code>&amp;args</code>代表的是 <em>pack pattern</em> 本身</li>\n</ul>\n<h3 id=\"move-semantics\"><a class=\"markdownIt-Anchor\" href=\"#move-semantics\"></a> Move semantics</h3>\n<blockquote>\n<p><strong>凡是取地址（<code>&amp;</code>）操作可以成功的都是左值，其余都是右值</strong></p>\n<ul>\n<li>等号左边的不一定是左值——可以通过操作符重载来让左部变成 <strong>右值</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"右值引用\"><a class=\"markdownIt-Anchor\" href=\"#右值引用\"></a> 右值引用</h4>\n<p>我们之前常见的都是 <strong>左值引用</strong>，指的是我们只能够将 <strong>左值</strong> 赋给一个引用。</p>\n<ul>\n<li><code>int&amp; a = 1</code> 就是非法的。而我们也可以 <code>int const&amp; i = 42;</code> 来进行一个 <em>tricky</em> 的躲避</li>\n</ul>\n<p>在 <code>c++11</code>中允许了右值引用的出现</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span>&amp;&amp; a = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"移动语义\"><a class=\"markdownIt-Anchor\" href=\"#移动语义\"></a> 移动语义</h4>\n<p>我们在进行 <code>Test(const Test&amp; test)</code> 拷贝构造函数的执行过程中，会造成很多的拷贝浪费。当单独的一次拷贝构造函数 (特别是对指针数组这些资源)过程消耗特别大的时候，对于性能来说是很低的。</p>\n<p>那么 <code>c++11</code>标准给出了 <strong>移动拷贝构造函数</strong> 和 <strong>移动赋值操作符重载</strong>。此外，还支持 <code>std::move()</code>来强制性让 <strong>左值转化为右值</strong></p>\n<h4 id=\"完美转发\"><a class=\"markdownIt-Anchor\" href=\"#完美转发\"></a> 完美转发</h4>\n<p>我们想要实现</p>\n<blockquote>\n<p>多级函数调用过程中</p>\n<ul>\n<li>如果变量是左值，那么它作为其他函数的参数的时候也应该是 <strong>左值</strong></li>\n<li>如果变量是右值，那么它作为其他函数的参数的时候也应该是 <strong>右值</strong></li>\n</ul>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;in func&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">relay</span><span class=\"params\">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;in relay&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    func(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    relay(Test());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这个例子就是一个 <strong>反例</strong>。我们在传入 <code>func(t)</code> 的时候，其实调用了 <strong>拷贝构造函数</strong> (因为编译器把 <strong>t</strong> 当做了一个 <strong>左值</strong>)</p>\n<blockquote>\n<p><code>std::forward&lt;T&gt;()</code> ，能够保留参数的左右值类型</p>\n</blockquote>\n<h3 id=\"value-category\"><a class=\"markdownIt-Anchor\" href=\"#value-category\"></a> Value Category</h3>\n<p>不止左值右值那么简单</p>\n<blockquote>\n<p>Cpp reference:</p>\n<p>Each C++ <a href=\"https://en.cppreference.com/w/cpp/language/expressions\">expression</a> (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a <em>type</em> and a <em>value category</em>. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: <em>prvalue</em>, <em>xvalue</em>, and <em>lvalue</em>.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"whats-new-in-c-11\"><a class=\"markdownIt-Anchor\" href=\"#whats-new-in-c-11\"></a> What’s new in C++ 11?</h2>\n<h3 id=\"storage-duration-specifier\"><a class=\"markdownIt-Anchor\" href=\"#storage-duration-specifier\"></a> storage duration specifier</h3>\n<p>多个C++版本都对变量存储时间的定义有严格的说明</p>\n<ul>\n<li>\n<p><code>auto</code> - <em>automatic</em> storage duration.</p>\n</li>\n<li>\n<p><code>register</code> - <em>automatic</em> storage duration. Also hints to the compiler to place the object in the processor’s register. (deprecated) ——<em>since C++ 17</em></p>\n</li>\n<li>\n<p><code>static</code> - <em>static</em> or <em>thread</em> storage duration and <em>internal</em> linkage</p>\n</li>\n<li>\n<p><code>extern</code> - <em>static</em> or <em>thread</em> storage duration and <em>external</em> linkage.</p>\n</li>\n<li>\n<p><code>thread_local</code> - <em>thread</em> storage duration</p>\n<p>The <code>thread_local</code> keyword is only allowed for objects declared at namespace scope, objects declared at block scope, and static data members. It indicates that the object has <strong>thread storage duration</strong>. It can be combined with <code>static</code> or <code>extern</code> to specify internal or external linkage (except for static data members which always have external linkage), respectively, but that additional <code>static</code> doesn’t affect the storage duration.</p>\n</li>\n<li>\n<p><code>mutable</code> - does not affect storage duration or linkage</p>\n<p>注意：<code>mutable</code> 主要是标识 <strong>const对象</strong> 中某些可变的成员，实现了从二进制的物理 <strong>const</strong> 到逻辑 <strong>const</strong> (外观不变)</p>\n</li>\n</ul>\n<h3 id=\"variadic-templates\"><a class=\"markdownIt-Anchor\" href=\"#variadic-templates\"></a> Variadic templates</h3>\n<p>可变类模板，在 <code>c++ reference</code> 里面以 <em>parameter pack</em> 来代替</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;class... Types&gt;\t\t\t<span class=\"comment\">//class ... Types 是一个 pack 的声明\t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(Types... args)</span> </span>&#123;&#125;\t\t\t<span class=\"comment\">//Types... args 是</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"pack-expansion\"><a class=\"markdownIt-Anchor\" href=\"#pack-expansion\"></a> Pack Expansion</h4>\n<ul>\n<li><code>&amp;args...</code> 代表的是参数扩展</li>\n<li><code>&amp;args</code>代表的是 <em>pack pattern</em> 本身</li>\n</ul>\n<h3 id=\"move-semantics\"><a class=\"markdownIt-Anchor\" href=\"#move-semantics\"></a> Move semantics</h3>\n<blockquote>\n<p><strong>凡是取地址（<code>&amp;</code>）操作可以成功的都是左值，其余都是右值</strong></p>\n<ul>\n<li>等号左边的不一定是左值——可以通过操作符重载来让左部变成 <strong>右值</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"右值引用\"><a class=\"markdownIt-Anchor\" href=\"#右值引用\"></a> 右值引用</h4>\n<p>我们之前常见的都是 <strong>左值引用</strong>，指的是我们只能够将 <strong>左值</strong> 赋给一个引用。</p>\n<ul>\n<li><code>int&amp; a = 1</code> 就是非法的。而我们也可以 <code>int const&amp; i = 42;</code> 来进行一个 <em>tricky</em> 的躲避</li>\n</ul>\n<p>在 <code>c++11</code>中允许了右值引用的出现</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span>&amp;&amp; a = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"移动语义\"><a class=\"markdownIt-Anchor\" href=\"#移动语义\"></a> 移动语义</h4>\n<p>我们在进行 <code>Test(const Test&amp; test)</code> 拷贝构造函数的执行过程中，会造成很多的拷贝浪费。当单独的一次拷贝构造函数 (特别是对指针数组这些资源)过程消耗特别大的时候，对于性能来说是很低的。</p>\n<p>那么 <code>c++11</code>标准给出了 <strong>移动拷贝构造函数</strong> 和 <strong>移动赋值操作符重载</strong>。此外，还支持 <code>std::move()</code>来强制性让 <strong>左值转化为右值</strong></p>\n<h4 id=\"完美转发\"><a class=\"markdownIt-Anchor\" href=\"#完美转发\"></a> 完美转发</h4>\n<p>我们想要实现</p>\n<blockquote>\n<p>多级函数调用过程中</p>\n<ul>\n<li>如果变量是左值，那么它作为其他函数的参数的时候也应该是 <strong>左值</strong></li>\n<li>如果变量是右值，那么它作为其他函数的参数的时候也应该是 <strong>右值</strong></li>\n</ul>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;in func&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">relay</span><span class=\"params\">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;in relay&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    func(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    relay(Test());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这个例子就是一个 <strong>反例</strong>。我们在传入 <code>func(t)</code> 的时候，其实调用了 <strong>拷贝构造函数</strong> (因为编译器把 <strong>t</strong> 当做了一个 <strong>左值</strong>)</p>\n<blockquote>\n<p><code>std::forward&lt;T&gt;()</code> ，能够保留参数的左右值类型</p>\n</blockquote>\n<h3 id=\"value-category\"><a class=\"markdownIt-Anchor\" href=\"#value-category\"></a> Value Category</h3>\n<p>不止左值右值那么简单</p>\n<blockquote>\n<p>Cpp reference:</p>\n<p>Each C++ <a href=\"https://en.cppreference.com/w/cpp/language/expressions\">expression</a> (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a <em>type</em> and a <em>value category</em>. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: <em>prvalue</em>, <em>xvalue</em>, and <em>lvalue</em>.</p>\n</blockquote>\n"},{"title":"cmake学习笔记","date":"2020-02-18T01:12:40.000Z","feature_img":null,"description":null,"keywords":null,"cover":"https://images.unsplash.com/photo-1603199477811-71c45c02f10d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80","_content":"\n## Cmake学习笔记\n\n用于记录一下cmake开发中的一些整理性工作\n\n#### cmake变量\n\n使用 `set(A B)` 来定义`A`这个新的变量，之后就可以通过`${A}`来进行引用，可以想成一个**自定义宏**\n\n#### 动态/静态链接、头文件配置\n\n##### 头文件目录\n\n`INCLUDE_DIRECTORIES`\n\n指定项目使用到的头文件目录，可以一次包含多个头文件目录\n\n##### 添加库文件\n\n``\n\n\n\n#### 添加外部文件夹\n\n`add_subdirectory(source_dir,[binary_dir])`\n\n第一个参数就是外部文件夹的位置，而`binary_dir`表示输出的位置。如果代码目录在外部，则必须要指定第二个参数\n\n`ADD_SUBDIRECTORY`","source":"_posts/cmake学习笔记.md","raw":"---\ntitle: cmake学习笔记\ndate: 2020-02-18 09:12:40\ntags:\nfeature_img:\ndescription:\nkeywords:\ncover: https://images.unsplash.com/photo-1603199477811-71c45c02f10d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80\n---\n\n## Cmake学习笔记\n\n用于记录一下cmake开发中的一些整理性工作\n\n#### cmake变量\n\n使用 `set(A B)` 来定义`A`这个新的变量，之后就可以通过`${A}`来进行引用，可以想成一个**自定义宏**\n\n#### 动态/静态链接、头文件配置\n\n##### 头文件目录\n\n`INCLUDE_DIRECTORIES`\n\n指定项目使用到的头文件目录，可以一次包含多个头文件目录\n\n##### 添加库文件\n\n``\n\n\n\n#### 添加外部文件夹\n\n`add_subdirectory(source_dir,[binary_dir])`\n\n第一个参数就是外部文件夹的位置，而`binary_dir`表示输出的位置。如果代码目录在外部，则必须要指定第二个参数\n\n`ADD_SUBDIRECTORY`","slug":"cmake学习笔记","published":1,"updated":"2020-10-22T02:12:58.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgk7k80j000f06meeo8xhehd","content":"<h2 id=\"cmake学习笔记\"><a class=\"markdownIt-Anchor\" href=\"#cmake学习笔记\"></a> Cmake学习笔记</h2>\n<p>用于记录一下cmake开发中的一些整理性工作</p>\n<h4 id=\"cmake变量\"><a class=\"markdownIt-Anchor\" href=\"#cmake变量\"></a> cmake变量</h4>\n<p>使用 <code>set(A B)</code> 来定义<code>A</code>这个新的变量，之后就可以通过<code>$&#123;A&#125;</code>来进行引用，可以想成一个<strong>自定义宏</strong></p>\n<h4 id=\"动态静态链接-头文件配置\"><a class=\"markdownIt-Anchor\" href=\"#动态静态链接-头文件配置\"></a> 动态/静态链接、头文件配置</h4>\n<h5 id=\"头文件目录\"><a class=\"markdownIt-Anchor\" href=\"#头文件目录\"></a> 头文件目录</h5>\n<p><code>INCLUDE_DIRECTORIES</code></p>\n<p>指定项目使用到的头文件目录，可以一次包含多个头文件目录</p>\n<h5 id=\"添加库文件\"><a class=\"markdownIt-Anchor\" href=\"#添加库文件\"></a> 添加库文件</h5>\n<p>``</p>\n<h4 id=\"添加外部文件夹\"><a class=\"markdownIt-Anchor\" href=\"#添加外部文件夹\"></a> 添加外部文件夹</h4>\n<p><code>add_subdirectory(source_dir,[binary_dir])</code></p>\n<p>第一个参数就是外部文件夹的位置，而<code>binary_dir</code>表示输出的位置。如果代码目录在外部，则必须要指定第二个参数</p>\n<p><code>ADD_SUBDIRECTORY</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"cmake学习笔记\"><a class=\"markdownIt-Anchor\" href=\"#cmake学习笔记\"></a> Cmake学习笔记</h2>\n<p>用于记录一下cmake开发中的一些整理性工作</p>\n<h4 id=\"cmake变量\"><a class=\"markdownIt-Anchor\" href=\"#cmake变量\"></a> cmake变量</h4>\n<p>使用 <code>set(A B)</code> 来定义<code>A</code>这个新的变量，之后就可以通过<code>$&#123;A&#125;</code>来进行引用，可以想成一个<strong>自定义宏</strong></p>\n<h4 id=\"动态静态链接-头文件配置\"><a class=\"markdownIt-Anchor\" href=\"#动态静态链接-头文件配置\"></a> 动态/静态链接、头文件配置</h4>\n<h5 id=\"头文件目录\"><a class=\"markdownIt-Anchor\" href=\"#头文件目录\"></a> 头文件目录</h5>\n<p><code>INCLUDE_DIRECTORIES</code></p>\n<p>指定项目使用到的头文件目录，可以一次包含多个头文件目录</p>\n<h5 id=\"添加库文件\"><a class=\"markdownIt-Anchor\" href=\"#添加库文件\"></a> 添加库文件</h5>\n<p>``</p>\n<h4 id=\"添加外部文件夹\"><a class=\"markdownIt-Anchor\" href=\"#添加外部文件夹\"></a> 添加外部文件夹</h4>\n<p><code>add_subdirectory(source_dir,[binary_dir])</code></p>\n<p>第一个参数就是外部文件夹的位置，而<code>binary_dir</code>表示输出的位置。如果代码目录在外部，则必须要指定第二个参数</p>\n<p><code>ADD_SUBDIRECTORY</code></p>\n"},{"title":"LC周赛 2019-10-05","date":"2019-10-08T01:57:04.000Z","description":"20191005周赛记录","cover_img":"https://images.unsplash.com/photo-1492366254240-43affaefc3e3?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=602&q=80","cover":"https://images.unsplash.com/photo-1492366254240-43affaefc3e3?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=602&q=80","feature_img":"https://images.unsplash.com/photo-1495539406979-bf61750d38ad?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80","_content":"\n## 1. Play with Chips\n\n### 描述\n\nThere are some chips, and the i-th chip is at position `chips[i]`.\n\nYou can perform any of the two following types of moves **any number of times** (possibly zero) **on any chip**:\n\n- Move the `i`-th chip by 2 units to the left or to the right with a cost of **0**.\n- Move the `i`-th chip by 1 unit to the left or to the right with a cost of **1**.\n\nThere can be two or more chips at the same position initially.\n\nReturn the minimum cost needed to move all the chips to the same position (any position).\n\n### 思路 \n\n如果两个chip的位置相差为偶数, 则 `cost = 0`. 否则 `coust = 1 `\n\n我们预先获取chip的一个哈希来进行缓存, 之后遍历哈希中的每一个数, 作为 **目的地**.\n\n那么我们的问题就变成 ： 找出那一个 **目的地** , 使得 `cost` 最小即可\n\n```java\n    public int minCostToMoveChips(int[] chips) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : chips) {\n            set.add(num);\n        }\n        int min = Integer.MAX_VALUE;\n        for (int num : set) {\n            int sum = 0;\n            for (int chip : chips) {\n                int dis = Math.abs(num - chip);\n                sum += dis % 2;\n                if (sum > min) break;\n            }\n            min = Math.min(sum, min);\n        }\n        return min;\n    }\n```\n\n## 2. Longest Arithmetic Subsequence of Given Difference\n\n### 描述\n\nGiven an integer array `arr` and an integer `difference`, return the length of the longest subsequence in `arr` which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals `difference`.\n\n**Example 1:**\n\n```\nInput: arr = [1,2,3,4], difference = 1\nOutput: 4\nExplanation: The longest arithmetic subsequence is [1,2,3,4].\n```\n\n**Example 2:**\n\n```\nInput: arr = [1,3,5,7], difference = 1\nOutput: 1\nExplanation: The longest arithmetic subsequence is any single element.\n```\n\n**Example 3:**\n\n```\nInput: arr = [1,5,7,8,5,3,4,2,1], difference = -2\nOutput: 4\nExplanation: The longest arithmetic subsequence is [7,5,3,1].\n```\n\n### 思路\n\n一开始很明显想到用 `DP` 来解决. 每一步前进的同时需要缓存下当前位置, 便于后续的查找\n\n我们缓存如下的内容：\n\n- 每一个数字和它所处可能位置 `Set` 的哈希映射\n- DP 数组，用于当前 `dp[i]` 的确定\n\n一开始就这样做了，但是 error 了一次. 原因就是这里的 dp 数组并不是单调上升，因为可能会出现中间断层的情况，例如 `[1,2,3,1,2,3,4]` , 中间的 `1` 位置就是断层的出现点. (之后一想，其实也可以通过自己的维护来进行避免，问题不大)\n\n最终代码如下\n\n```java\n public int longestSubsequence(int[] arr, int difference) {\n        int n = arr.length;\n        int[] dp = new int[n];\n        Map<Integer, Set<Integer>> map = new HashMap<>();\n        dp[0] = 1;\n        Set<Integer> set = new HashSet<>();\n        set.add(0);\n        map.put(arr[0], set);\n        for (int i = 1; i < n; ++i) {\n            if (!map.containsKey(arr[i])) {\n                set = new HashSet<>();\n                set.add(i);\n                map.put(arr[i], set);\n            } else {\n                set = map.get(arr[i]);\n                set.add(i);\n                map.put(arr[i], set);\n            }\n\n            int target = arr[i] - difference;\n            if (!map.containsKey(target)) { //不包含前一个数\n                dp[i] = 1;\n            } else {\n                set = map.get(target);\n                int maxLen = 0;\n                for (int num : set) {\n                    maxLen = Math.max(maxLen, dp[num]);\n                }\n                dp[i] = maxLen + 1;\n            }\n        }\n        int ans = 0;\n        for (int num : dp) {\n            ans = Math.max(num, ans);\n        }\n        return ans;\n    }\n```\n\n## 3. Path with Maximum Gold\n\n### 描述\n\nIn a gold mine `grid` of size `m * n`, each cell in this mine has an integer representing the amount of gold in that cell, `0` if it is empty.\n\nReturn the maximum amount of gold you can collect under the conditions:\n\n- Every time you are located in a cell you will collect all the gold in that cell.\n- From your position you can walk one step to the left, right, up or down.\n- You can't visit the same cell more than once.\n- Never visit a cell with `0` gold.\n- You can start and stop collecting gold from **any** position in the grid that has some gold. \n\n**Example 1:**\n\n```\nInput: grid = [[0,6,0],[5,8,7],[0,9,0]]\nOutput: 24\nExplanation:\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\nPath to get the maximum gold, 9 -> 8 -> 7.\n```\n\n**Example 2:**\n\n```\nInput: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\nOutput: 28\nExplanation:\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\nPath to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n```\n\n### 思路\n\n很简单的 DFS 算法实现, 没什么好说的\n\n```java\npublic int getMaximumGold(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int max = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] != 0) {\n                    max = Math.max(max, dfs(grid, new int[]{i, j}, 0));\n                }\n            }\n        }\n        return max;\n    }\n\n    private int dfs(int[][] grid, int[] startPos, int gold) {\n        int m = grid.length, n = grid[0].length;\n        int r = startPos[0], c = startPos[1];\n        if (r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == 0) return gold;\n        gold += grid[r][c];\n        int[][] nums = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                nums[i][j] = grid[i][j];\n            }\n        }\n        nums[r][c] = 0;             //Get the gold\n        int a1 = dfs(nums, new int[]{r, c + 1}, gold);\n        int b1 = dfs(nums, new int[]{r, c - 1}, gold);\n        int c1 = dfs(nums, new int[]{r + 1, c}, gold);\n        int d1 = dfs(nums, new int[]{r - 1, c}, gold);\n        return Arrays.stream(new int[]{a1, b1, c1, d1}).max().getAsInt();\n    }\n```\n\n## 4. Count Vowels Permutation\n\n### 描述\n\nGiven an integer `n`, your task is to count how many strings of length `n` can be formed under the following rules:\n\n- Each character is a lower case vowel (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`)\n- Each vowel `'a'` may only be followed by an `'e'`.\n- Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.\n- Each vowel `'i'` **may not** be followed by another `'i'`.\n- Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.\n- Each vowel `'u'` may only be followed by an `'a'.`\n\nSince the answer may be too large, return it modulo `10^9 + 7.`\n\n**Example 1:**\n\n```\nInput: n = 1\nOutput: 5\nExplanation: All possible strings are: \"a\", \"e\", \"i\" , \"o\" and \"u\".\n```\n\n**Example 2:**\n\n```\nInput: n = 2\nOutput: 10\nExplanation: All possible strings are: \"ae\", \"ea\", \"ei\", \"ia\", \"ie\", \"io\", \"iu\", \"oi\", \"ou\" and \"ua\".\n```\n\n**Example 3:** \n\n```\nInput: n = 5\nOutput: 68\n```\n\n### 思路\n\n假定某一步的最末位中, ‘a’ , ‘e’ , ‘i’ , ‘o’ , ‘u’ 的个数分别是 a , e , i , o , u ，那么下一步末位的个数就分别是 `u+e+i`, `a + i`, `e + o` , `i` , `o +i` \n\n我这里用了一个hash来保存 (小声：这个hard题是简单题的赶脚233)\n\n```java\nclass Solution {\nprivate final long mod = 1_000_000_007;\n    public int countVowelPermutation(int n) {\n        Map<Character, Long> map = new HashMap<>();\n        map.put('a', 1L);\n        map.put('e', 1L);\n        map.put('i', 1L);\n        map.put('o', 1L);\n        map.put('u', 1L);\n        for (int i = 1; i < n; ++i) {\n            Map<Character, Long> tmp = new HashMap<>();\n            tmp.put('a', (map.get('u') + map.get('e') + map.get('i')) % mod);\n            tmp.put('e', (map.get('a') + map.get('i')) % mod);\n            tmp.put('i', (map.get('e') + map.get('o')) % mod);\n            tmp.put('o', (map.get('i')) % mod);\n            tmp.put('u', (map.get('o') + map.get('i')) % mod);\n\n            map = tmp;\n        }\n        return (int) (map.values().stream().reduce(Long::sum).get() % mod);\n    }\n}\n```\n\n## 结语\n\n这次周赛4个题目全部 AC , RANK  740","source":"_posts/leetcode-周赛20191005.md","raw":"---\ntitle: LC周赛 2019-10-05\ndate: 2019-10-08 09:57:04\ntags: \n  - competition\ncategories: \n  - 算法\ndescription: 20191005周赛记录\ncover_img: https://images.unsplash.com/photo-1492366254240-43affaefc3e3?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=602&q=80\ncover: https://images.unsplash.com/photo-1492366254240-43affaefc3e3?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=602&q=80\nfeature_img: https://images.unsplash.com/photo-1495539406979-bf61750d38ad?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80\n---\n\n## 1. Play with Chips\n\n### 描述\n\nThere are some chips, and the i-th chip is at position `chips[i]`.\n\nYou can perform any of the two following types of moves **any number of times** (possibly zero) **on any chip**:\n\n- Move the `i`-th chip by 2 units to the left or to the right with a cost of **0**.\n- Move the `i`-th chip by 1 unit to the left or to the right with a cost of **1**.\n\nThere can be two or more chips at the same position initially.\n\nReturn the minimum cost needed to move all the chips to the same position (any position).\n\n### 思路 \n\n如果两个chip的位置相差为偶数, 则 `cost = 0`. 否则 `coust = 1 `\n\n我们预先获取chip的一个哈希来进行缓存, 之后遍历哈希中的每一个数, 作为 **目的地**.\n\n那么我们的问题就变成 ： 找出那一个 **目的地** , 使得 `cost` 最小即可\n\n```java\n    public int minCostToMoveChips(int[] chips) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : chips) {\n            set.add(num);\n        }\n        int min = Integer.MAX_VALUE;\n        for (int num : set) {\n            int sum = 0;\n            for (int chip : chips) {\n                int dis = Math.abs(num - chip);\n                sum += dis % 2;\n                if (sum > min) break;\n            }\n            min = Math.min(sum, min);\n        }\n        return min;\n    }\n```\n\n## 2. Longest Arithmetic Subsequence of Given Difference\n\n### 描述\n\nGiven an integer array `arr` and an integer `difference`, return the length of the longest subsequence in `arr` which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals `difference`.\n\n**Example 1:**\n\n```\nInput: arr = [1,2,3,4], difference = 1\nOutput: 4\nExplanation: The longest arithmetic subsequence is [1,2,3,4].\n```\n\n**Example 2:**\n\n```\nInput: arr = [1,3,5,7], difference = 1\nOutput: 1\nExplanation: The longest arithmetic subsequence is any single element.\n```\n\n**Example 3:**\n\n```\nInput: arr = [1,5,7,8,5,3,4,2,1], difference = -2\nOutput: 4\nExplanation: The longest arithmetic subsequence is [7,5,3,1].\n```\n\n### 思路\n\n一开始很明显想到用 `DP` 来解决. 每一步前进的同时需要缓存下当前位置, 便于后续的查找\n\n我们缓存如下的内容：\n\n- 每一个数字和它所处可能位置 `Set` 的哈希映射\n- DP 数组，用于当前 `dp[i]` 的确定\n\n一开始就这样做了，但是 error 了一次. 原因就是这里的 dp 数组并不是单调上升，因为可能会出现中间断层的情况，例如 `[1,2,3,1,2,3,4]` , 中间的 `1` 位置就是断层的出现点. (之后一想，其实也可以通过自己的维护来进行避免，问题不大)\n\n最终代码如下\n\n```java\n public int longestSubsequence(int[] arr, int difference) {\n        int n = arr.length;\n        int[] dp = new int[n];\n        Map<Integer, Set<Integer>> map = new HashMap<>();\n        dp[0] = 1;\n        Set<Integer> set = new HashSet<>();\n        set.add(0);\n        map.put(arr[0], set);\n        for (int i = 1; i < n; ++i) {\n            if (!map.containsKey(arr[i])) {\n                set = new HashSet<>();\n                set.add(i);\n                map.put(arr[i], set);\n            } else {\n                set = map.get(arr[i]);\n                set.add(i);\n                map.put(arr[i], set);\n            }\n\n            int target = arr[i] - difference;\n            if (!map.containsKey(target)) { //不包含前一个数\n                dp[i] = 1;\n            } else {\n                set = map.get(target);\n                int maxLen = 0;\n                for (int num : set) {\n                    maxLen = Math.max(maxLen, dp[num]);\n                }\n                dp[i] = maxLen + 1;\n            }\n        }\n        int ans = 0;\n        for (int num : dp) {\n            ans = Math.max(num, ans);\n        }\n        return ans;\n    }\n```\n\n## 3. Path with Maximum Gold\n\n### 描述\n\nIn a gold mine `grid` of size `m * n`, each cell in this mine has an integer representing the amount of gold in that cell, `0` if it is empty.\n\nReturn the maximum amount of gold you can collect under the conditions:\n\n- Every time you are located in a cell you will collect all the gold in that cell.\n- From your position you can walk one step to the left, right, up or down.\n- You can't visit the same cell more than once.\n- Never visit a cell with `0` gold.\n- You can start and stop collecting gold from **any** position in the grid that has some gold. \n\n**Example 1:**\n\n```\nInput: grid = [[0,6,0],[5,8,7],[0,9,0]]\nOutput: 24\nExplanation:\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\nPath to get the maximum gold, 9 -> 8 -> 7.\n```\n\n**Example 2:**\n\n```\nInput: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\nOutput: 28\nExplanation:\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\nPath to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n```\n\n### 思路\n\n很简单的 DFS 算法实现, 没什么好说的\n\n```java\npublic int getMaximumGold(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int max = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] != 0) {\n                    max = Math.max(max, dfs(grid, new int[]{i, j}, 0));\n                }\n            }\n        }\n        return max;\n    }\n\n    private int dfs(int[][] grid, int[] startPos, int gold) {\n        int m = grid.length, n = grid[0].length;\n        int r = startPos[0], c = startPos[1];\n        if (r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == 0) return gold;\n        gold += grid[r][c];\n        int[][] nums = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                nums[i][j] = grid[i][j];\n            }\n        }\n        nums[r][c] = 0;             //Get the gold\n        int a1 = dfs(nums, new int[]{r, c + 1}, gold);\n        int b1 = dfs(nums, new int[]{r, c - 1}, gold);\n        int c1 = dfs(nums, new int[]{r + 1, c}, gold);\n        int d1 = dfs(nums, new int[]{r - 1, c}, gold);\n        return Arrays.stream(new int[]{a1, b1, c1, d1}).max().getAsInt();\n    }\n```\n\n## 4. Count Vowels Permutation\n\n### 描述\n\nGiven an integer `n`, your task is to count how many strings of length `n` can be formed under the following rules:\n\n- Each character is a lower case vowel (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`)\n- Each vowel `'a'` may only be followed by an `'e'`.\n- Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.\n- Each vowel `'i'` **may not** be followed by another `'i'`.\n- Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.\n- Each vowel `'u'` may only be followed by an `'a'.`\n\nSince the answer may be too large, return it modulo `10^9 + 7.`\n\n**Example 1:**\n\n```\nInput: n = 1\nOutput: 5\nExplanation: All possible strings are: \"a\", \"e\", \"i\" , \"o\" and \"u\".\n```\n\n**Example 2:**\n\n```\nInput: n = 2\nOutput: 10\nExplanation: All possible strings are: \"ae\", \"ea\", \"ei\", \"ia\", \"ie\", \"io\", \"iu\", \"oi\", \"ou\" and \"ua\".\n```\n\n**Example 3:** \n\n```\nInput: n = 5\nOutput: 68\n```\n\n### 思路\n\n假定某一步的最末位中, ‘a’ , ‘e’ , ‘i’ , ‘o’ , ‘u’ 的个数分别是 a , e , i , o , u ，那么下一步末位的个数就分别是 `u+e+i`, `a + i`, `e + o` , `i` , `o +i` \n\n我这里用了一个hash来保存 (小声：这个hard题是简单题的赶脚233)\n\n```java\nclass Solution {\nprivate final long mod = 1_000_000_007;\n    public int countVowelPermutation(int n) {\n        Map<Character, Long> map = new HashMap<>();\n        map.put('a', 1L);\n        map.put('e', 1L);\n        map.put('i', 1L);\n        map.put('o', 1L);\n        map.put('u', 1L);\n        for (int i = 1; i < n; ++i) {\n            Map<Character, Long> tmp = new HashMap<>();\n            tmp.put('a', (map.get('u') + map.get('e') + map.get('i')) % mod);\n            tmp.put('e', (map.get('a') + map.get('i')) % mod);\n            tmp.put('i', (map.get('e') + map.get('o')) % mod);\n            tmp.put('o', (map.get('i')) % mod);\n            tmp.put('u', (map.get('o') + map.get('i')) % mod);\n\n            map = tmp;\n        }\n        return (int) (map.values().stream().reduce(Long::sum).get() % mod);\n    }\n}\n```\n\n## 结语\n\n这次周赛4个题目全部 AC , RANK  740","slug":"leetcode-周赛20191005","published":1,"updated":"2020-10-22T02:12:58.118Z","_id":"ckgk7k80k000i06mefkv2dfia","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-play-with-chips\"><a class=\"markdownIt-Anchor\" href=\"#1-play-with-chips\"></a> 1. Play with Chips</h2>\n<h3 id=\"描述\"><a class=\"markdownIt-Anchor\" href=\"#描述\"></a> 描述</h3>\n<p>There are some chips, and the i-th chip is at position <code>chips[i]</code>.</p>\n<p>You can perform any of the two following types of moves <strong>any number of times</strong> (possibly zero) <strong>on any chip</strong>:</p>\n<ul>\n<li>Move the <code>i</code>-th chip by 2 units to the left or to the right with a cost of <strong>0</strong>.</li>\n<li>Move the <code>i</code>-th chip by 1 unit to the left or to the right with a cost of <strong>1</strong>.</li>\n</ul>\n<p>There can be two or more chips at the same position initially.</p>\n<p>Return the minimum cost needed to move all the chips to the same position (any position).</p>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h3>\n<p>如果两个chip的位置相差为偶数, 则 <code>cost = 0</code>. 否则 <code>coust = 1</code></p>\n<p>我们预先获取chip的一个哈希来进行缓存, 之后遍历哈希中的每一个数, 作为 <strong>目的地</strong>.</p>\n<p>那么我们的问题就变成 ： 找出那一个 <strong>目的地</strong> , 使得 <code>cost</code> 最小即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minCostToMoveChips</span><span class=\"params\">(<span class=\"keyword\">int</span>[] chips)</span> </span>&#123;</span><br><span class=\"line\">    Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : chips) &#123;</span><br><span class=\"line\">        set.add(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min = Integer.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : set) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> chip : chips) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> dis = Math.abs(num - chip);</span><br><span class=\"line\">            sum += dis % <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &gt; min) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        min = Math.min(sum, min);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-longest-arithmetic-subsequence-of-given-difference\"><a class=\"markdownIt-Anchor\" href=\"#2-longest-arithmetic-subsequence-of-given-difference\"></a> 2. Longest Arithmetic Subsequence of Given Difference</h2>\n<h3 id=\"描述-2\"><a class=\"markdownIt-Anchor\" href=\"#描述-2\"></a> 描述</h3>\n<p>Given an integer array <code>arr</code> and an integer <code>difference</code>, return the length of the longest subsequence in <code>arr</code> which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals <code>difference</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> <span class=\"string\">arr</span> <span class=\"string\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]<span class=\"string\">,</span> <span class=\"string\">difference</span> <span class=\"string\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span> <span class=\"string\">The</span> <span class=\"string\">longest</span> <span class=\"string\">arithmetic</span> <span class=\"string\">subsequence</span> <span class=\"string\">is</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]<span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> <span class=\"string\">arr</span> <span class=\"string\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>]<span class=\"string\">,</span> <span class=\"string\">difference</span> <span class=\"string\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span> <span class=\"string\">The</span> <span class=\"string\">longest</span> <span class=\"string\">arithmetic</span> <span class=\"string\">subsequence</span> <span class=\"string\">is</span> <span class=\"string\">any</span> <span class=\"string\">single</span> <span class=\"string\">element.</span></span><br></pre></td></tr></table></figure>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> <span class=\"string\">arr</span> <span class=\"string\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]<span class=\"string\">,</span> <span class=\"string\">difference</span> <span class=\"string\">=</span> <span class=\"number\">-2</span></span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span> <span class=\"string\">The</span> <span class=\"string\">longest</span> <span class=\"string\">arithmetic</span> <span class=\"string\">subsequence</span> <span class=\"string\">is</span> [<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]<span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\"></a> 思路</h3>\n<p>一开始很明显想到用 <code>DP</code> 来解决. 每一步前进的同时需要缓存下当前位置, 便于后续的查找</p>\n<p>我们缓存如下的内容：</p>\n<ul>\n<li>每一个数字和它所处可能位置 <code>Set</code> 的哈希映射</li>\n<li>DP 数组，用于当前 <code>dp[i]</code> 的确定</li>\n</ul>\n<p>一开始就这样做了，但是 error 了一次. 原因就是这里的 dp 数组并不是单调上升，因为可能会出现中间断层的情况，例如 <code>[1,2,3,1,2,3,4]</code> , 中间的 <code>1</code> 位置就是断层的出现点. (之后一想，其实也可以通过自己的维护来进行避免，问题不大)</p>\n<p>最终代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestSubsequence</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> difference)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">       <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">       Map&lt;Integer, Set&lt;Integer&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">       dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">       Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">       set.add(<span class=\"number\">0</span>);</span><br><span class=\"line\">       map.put(arr[<span class=\"number\">0</span>], set);</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!map.containsKey(arr[i])) &#123;</span><br><span class=\"line\">               set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">               set.add(i);</span><br><span class=\"line\">               map.put(arr[i], set);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               set = map.get(arr[i]);</span><br><span class=\"line\">               set.add(i);</span><br><span class=\"line\">               map.put(arr[i], set);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">int</span> target = arr[i] - difference;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!map.containsKey(target)) &#123; <span class=\"comment\">//不包含前一个数</span></span><br><span class=\"line\">               dp[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               set = map.get(target);</span><br><span class=\"line\">               <span class=\"keyword\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : set) &#123;</span><br><span class=\"line\">                   maxLen = Math.max(maxLen, dp[num]);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               dp[i] = maxLen + <span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : dp) &#123;</span><br><span class=\"line\">           ans = Math.max(num, ans);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-path-with-maximum-gold\"><a class=\"markdownIt-Anchor\" href=\"#3-path-with-maximum-gold\"></a> 3. Path with Maximum Gold</h2>\n<h3 id=\"描述-3\"><a class=\"markdownIt-Anchor\" href=\"#描述-3\"></a> 描述</h3>\n<p>In a gold mine <code>grid</code> of size <code>m * n</code>, each cell in this mine has an integer representing the amount of gold in that cell, <code>0</code> if it is empty.</p>\n<p>Return the maximum amount of gold you can collect under the conditions:</p>\n<ul>\n<li>Every time you are located in a cell you will collect all the gold in that cell.</li>\n<li>From your position you can walk one step to the left, right, up or down.</li>\n<li>You can’t visit the same cell more than once.</li>\n<li>Never visit a cell with <code>0</code> gold.</li>\n<li>You can start and stop collecting gold from <strong>any</strong> position in the grid that has some gold.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> <span class=\"string\">grid</span> <span class=\"string\">=</span> [[<span class=\"number\">0</span>,<span class=\"number\">6</span>,<span class=\"number\">0</span>],[<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>],[<span class=\"number\">0</span>,<span class=\"number\">9</span>,<span class=\"number\">0</span>]]</span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">24</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span></span><br><span class=\"line\">[[<span class=\"number\">0</span>,<span class=\"number\">6</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\"> [<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\"> [<span class=\"number\">0</span>,<span class=\"number\">9</span>,<span class=\"number\">0</span>]]</span><br><span class=\"line\"><span class=\"string\">Path</span> <span class=\"string\">to</span> <span class=\"string\">get</span> <span class=\"string\">the</span> <span class=\"string\">maximum</span> <span class=\"string\">gold,</span> <span class=\"number\">9</span> <span class=\"string\">-&gt;</span> <span class=\"number\">8</span> <span class=\"string\">-&gt;</span> <span class=\"number\">7</span><span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> <span class=\"string\">grid</span> <span class=\"string\">=</span> [[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">7</span>],[<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">6</span>],[<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>],[<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>],[<span class=\"number\">9</span>,<span class=\"number\">0</span>,<span class=\"number\">20</span>]]</span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">28</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span></span><br><span class=\"line\">[[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\"> [<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">6</span>],</span><br><span class=\"line\"> [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>],</span><br><span class=\"line\"> [<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\"> [<span class=\"number\">9</span>,<span class=\"number\">0</span>,<span class=\"number\">20</span>]]</span><br><span class=\"line\"><span class=\"string\">Path</span> <span class=\"string\">to</span> <span class=\"string\">get</span> <span class=\"string\">the</span> <span class=\"string\">maximum</span> <span class=\"string\">gold,</span> <span class=\"number\">1</span> <span class=\"string\">-&gt;</span> <span class=\"number\">2</span> <span class=\"string\">-&gt;</span> <span class=\"number\">3</span> <span class=\"string\">-&gt;</span> <span class=\"number\">4</span> <span class=\"string\">-&gt;</span> <span class=\"number\">5</span> <span class=\"string\">-&gt;</span> <span class=\"number\">6</span> <span class=\"string\">-&gt;</span> <span class=\"number\">7</span><span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"思路-3\"><a class=\"markdownIt-Anchor\" href=\"#思路-3\"></a> 思路</h3>\n<p>很简单的 DFS 算法实现, 没什么好说的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMaximumGold</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = grid.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (grid[i][j] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    max = Math.max(max, dfs(grid, <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i, j&#125;, <span class=\"number\">0</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid, <span class=\"keyword\">int</span>[] startPos, <span class=\"keyword\">int</span> gold)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = grid.length, n = grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = startPos[<span class=\"number\">0</span>], c = startPos[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span> || c &lt; <span class=\"number\">0</span> || r &gt;= m || c &gt;= n || grid[r][c] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> gold;</span><br><span class=\"line\">        gold += grid[r][c];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                nums[i][j] = grid[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nums[r][c] = <span class=\"number\">0</span>;             <span class=\"comment\">//Get the gold</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> a1 = dfs(nums, <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;r, c + <span class=\"number\">1</span>&#125;, gold);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b1 = dfs(nums, <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;r, c - <span class=\"number\">1</span>&#125;, gold);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c1 = dfs(nums, <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;r + <span class=\"number\">1</span>, c&#125;, gold);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d1 = dfs(nums, <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;r - <span class=\"number\">1</span>, c&#125;, gold);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.stream(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;a1, b1, c1, d1&#125;).max().getAsInt();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-count-vowels-permutation\"><a class=\"markdownIt-Anchor\" href=\"#4-count-vowels-permutation\"></a> 4. Count Vowels Permutation</h2>\n<h3 id=\"描述-4\"><a class=\"markdownIt-Anchor\" href=\"#描述-4\"></a> 描述</h3>\n<p>Given an integer <code>n</code>, your task is to count how many strings of length <code>n</code> can be formed under the following rules:</p>\n<ul>\n<li>Each character is a lower case vowel (<code>'a'</code>, <code>'e'</code>, <code>'i'</code>, <code>'o'</code>, <code>'u'</code>)</li>\n<li>Each vowel <code>'a'</code> may only be followed by an <code>'e'</code>.</li>\n<li>Each vowel <code>'e'</code> may only be followed by an <code>'a'</code> or an <code>'i'</code>.</li>\n<li>Each vowel <code>'i'</code> <strong>may not</strong> be followed by another <code>'i'</code>.</li>\n<li>Each vowel <code>'o'</code> may only be followed by an <code>'i'</code> or a <code>'u'</code>.</li>\n<li>Each vowel <code>'u'</code> may only be followed by an <code>'a'.</code></li>\n</ul>\n<p>Since the answer may be too large, return it modulo <code>10^9 + 7.</code></p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> n = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span> All possible strings <span class=\"attr\">are:</span> <span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;e&quot;</span>, <span class=\"string\">&quot;i&quot;</span> , <span class=\"string\">&quot;o&quot;</span> and <span class=\"string\">&quot;u&quot;</span>.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> n = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span> All possible strings <span class=\"attr\">are:</span> <span class=\"string\">&quot;ae&quot;</span>, <span class=\"string\">&quot;ea&quot;</span>, <span class=\"string\">&quot;ei&quot;</span>, <span class=\"string\">&quot;ia&quot;</span>, <span class=\"string\">&quot;ie&quot;</span>, <span class=\"string\">&quot;io&quot;</span>, <span class=\"string\">&quot;iu&quot;</span>, <span class=\"string\">&quot;oi&quot;</span>, <span class=\"string\">&quot;ou&quot;</span> and <span class=\"string\">&quot;ua&quot;</span>.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> <span class=\"string\">n</span> <span class=\"string\">=</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">68</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"思路-4\"><a class=\"markdownIt-Anchor\" href=\"#思路-4\"></a> 思路</h3>\n<p>假定某一步的最末位中, ‘a’ , ‘e’ , ‘i’ , ‘o’ , ‘u’ 的个数分别是 a , e , i , o , u ，那么下一步末位的个数就分别是 <code>u+e+i</code>, <code>a + i</code>, <code>e + o</code> , <code>i</code> , <code>o +i</code></p>\n<p>我这里用了一个hash来保存 (小声：这个hard题是简单题的赶脚233)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> mod = <span class=\"number\">1_000_000_007</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countVowelPermutation</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character, Long&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"number\">1L</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&#x27;e&#x27;</span>, <span class=\"number\">1L</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&#x27;i&#x27;</span>, <span class=\"number\">1L</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&#x27;o&#x27;</span>, <span class=\"number\">1L</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&#x27;u&#x27;</span>, <span class=\"number\">1L</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            Map&lt;Character, Long&gt; tmp = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">            tmp.put(<span class=\"string\">&#x27;a&#x27;</span>, (map.get(<span class=\"string\">&#x27;u&#x27;</span>) + map.get(<span class=\"string\">&#x27;e&#x27;</span>) + map.get(<span class=\"string\">&#x27;i&#x27;</span>)) % mod);</span><br><span class=\"line\">            tmp.put(<span class=\"string\">&#x27;e&#x27;</span>, (map.get(<span class=\"string\">&#x27;a&#x27;</span>) + map.get(<span class=\"string\">&#x27;i&#x27;</span>)) % mod);</span><br><span class=\"line\">            tmp.put(<span class=\"string\">&#x27;i&#x27;</span>, (map.get(<span class=\"string\">&#x27;e&#x27;</span>) + map.get(<span class=\"string\">&#x27;o&#x27;</span>)) % mod);</span><br><span class=\"line\">            tmp.put(<span class=\"string\">&#x27;o&#x27;</span>, (map.get(<span class=\"string\">&#x27;i&#x27;</span>)) % mod);</span><br><span class=\"line\">            tmp.put(<span class=\"string\">&#x27;u&#x27;</span>, (map.get(<span class=\"string\">&#x27;o&#x27;</span>) + map.get(<span class=\"string\">&#x27;i&#x27;</span>)) % mod);</span><br><span class=\"line\"></span><br><span class=\"line\">            map = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) (map.values().stream().reduce(Long::sum).get() % mod);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a class=\"markdownIt-Anchor\" href=\"#结语\"></a> 结语</h2>\n<p>这次周赛4个题目全部 AC , RANK  740</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-play-with-chips\"><a class=\"markdownIt-Anchor\" href=\"#1-play-with-chips\"></a> 1. Play with Chips</h2>\n<h3 id=\"描述\"><a class=\"markdownIt-Anchor\" href=\"#描述\"></a> 描述</h3>\n<p>There are some chips, and the i-th chip is at position <code>chips[i]</code>.</p>\n<p>You can perform any of the two following types of moves <strong>any number of times</strong> (possibly zero) <strong>on any chip</strong>:</p>\n<ul>\n<li>Move the <code>i</code>-th chip by 2 units to the left or to the right with a cost of <strong>0</strong>.</li>\n<li>Move the <code>i</code>-th chip by 1 unit to the left or to the right with a cost of <strong>1</strong>.</li>\n</ul>\n<p>There can be two or more chips at the same position initially.</p>\n<p>Return the minimum cost needed to move all the chips to the same position (any position).</p>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h3>\n<p>如果两个chip的位置相差为偶数, 则 <code>cost = 0</code>. 否则 <code>coust = 1</code></p>\n<p>我们预先获取chip的一个哈希来进行缓存, 之后遍历哈希中的每一个数, 作为 <strong>目的地</strong>.</p>\n<p>那么我们的问题就变成 ： 找出那一个 <strong>目的地</strong> , 使得 <code>cost</code> 最小即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minCostToMoveChips</span><span class=\"params\">(<span class=\"keyword\">int</span>[] chips)</span> </span>&#123;</span><br><span class=\"line\">    Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : chips) &#123;</span><br><span class=\"line\">        set.add(num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min = Integer.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : set) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> chip : chips) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> dis = Math.abs(num - chip);</span><br><span class=\"line\">            sum += dis % <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &gt; min) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        min = Math.min(sum, min);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-longest-arithmetic-subsequence-of-given-difference\"><a class=\"markdownIt-Anchor\" href=\"#2-longest-arithmetic-subsequence-of-given-difference\"></a> 2. Longest Arithmetic Subsequence of Given Difference</h2>\n<h3 id=\"描述-2\"><a class=\"markdownIt-Anchor\" href=\"#描述-2\"></a> 描述</h3>\n<p>Given an integer array <code>arr</code> and an integer <code>difference</code>, return the length of the longest subsequence in <code>arr</code> which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals <code>difference</code>.</p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> <span class=\"string\">arr</span> <span class=\"string\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]<span class=\"string\">,</span> <span class=\"string\">difference</span> <span class=\"string\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span> <span class=\"string\">The</span> <span class=\"string\">longest</span> <span class=\"string\">arithmetic</span> <span class=\"string\">subsequence</span> <span class=\"string\">is</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]<span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> <span class=\"string\">arr</span> <span class=\"string\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>]<span class=\"string\">,</span> <span class=\"string\">difference</span> <span class=\"string\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span> <span class=\"string\">The</span> <span class=\"string\">longest</span> <span class=\"string\">arithmetic</span> <span class=\"string\">subsequence</span> <span class=\"string\">is</span> <span class=\"string\">any</span> <span class=\"string\">single</span> <span class=\"string\">element.</span></span><br></pre></td></tr></table></figure>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> <span class=\"string\">arr</span> <span class=\"string\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]<span class=\"string\">,</span> <span class=\"string\">difference</span> <span class=\"string\">=</span> <span class=\"number\">-2</span></span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span> <span class=\"string\">The</span> <span class=\"string\">longest</span> <span class=\"string\">arithmetic</span> <span class=\"string\">subsequence</span> <span class=\"string\">is</span> [<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]<span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\"></a> 思路</h3>\n<p>一开始很明显想到用 <code>DP</code> 来解决. 每一步前进的同时需要缓存下当前位置, 便于后续的查找</p>\n<p>我们缓存如下的内容：</p>\n<ul>\n<li>每一个数字和它所处可能位置 <code>Set</code> 的哈希映射</li>\n<li>DP 数组，用于当前 <code>dp[i]</code> 的确定</li>\n</ul>\n<p>一开始就这样做了，但是 error 了一次. 原因就是这里的 dp 数组并不是单调上升，因为可能会出现中间断层的情况，例如 <code>[1,2,3,1,2,3,4]</code> , 中间的 <code>1</code> 位置就是断层的出现点. (之后一想，其实也可以通过自己的维护来进行避免，问题不大)</p>\n<p>最终代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestSubsequence</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> difference)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">       <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">       Map&lt;Integer, Set&lt;Integer&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">       dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">       Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">       set.add(<span class=\"number\">0</span>);</span><br><span class=\"line\">       map.put(arr[<span class=\"number\">0</span>], set);</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!map.containsKey(arr[i])) &#123;</span><br><span class=\"line\">               set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">               set.add(i);</span><br><span class=\"line\">               map.put(arr[i], set);</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               set = map.get(arr[i]);</span><br><span class=\"line\">               set.add(i);</span><br><span class=\"line\">               map.put(arr[i], set);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">int</span> target = arr[i] - difference;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (!map.containsKey(target)) &#123; <span class=\"comment\">//不包含前一个数</span></span><br><span class=\"line\">               dp[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               set = map.get(target);</span><br><span class=\"line\">               <span class=\"keyword\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : set) &#123;</span><br><span class=\"line\">                   maxLen = Math.max(maxLen, dp[num]);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               dp[i] = maxLen + <span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : dp) &#123;</span><br><span class=\"line\">           ans = Math.max(num, ans);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-path-with-maximum-gold\"><a class=\"markdownIt-Anchor\" href=\"#3-path-with-maximum-gold\"></a> 3. Path with Maximum Gold</h2>\n<h3 id=\"描述-3\"><a class=\"markdownIt-Anchor\" href=\"#描述-3\"></a> 描述</h3>\n<p>In a gold mine <code>grid</code> of size <code>m * n</code>, each cell in this mine has an integer representing the amount of gold in that cell, <code>0</code> if it is empty.</p>\n<p>Return the maximum amount of gold you can collect under the conditions:</p>\n<ul>\n<li>Every time you are located in a cell you will collect all the gold in that cell.</li>\n<li>From your position you can walk one step to the left, right, up or down.</li>\n<li>You can’t visit the same cell more than once.</li>\n<li>Never visit a cell with <code>0</code> gold.</li>\n<li>You can start and stop collecting gold from <strong>any</strong> position in the grid that has some gold.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> <span class=\"string\">grid</span> <span class=\"string\">=</span> [[<span class=\"number\">0</span>,<span class=\"number\">6</span>,<span class=\"number\">0</span>],[<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>],[<span class=\"number\">0</span>,<span class=\"number\">9</span>,<span class=\"number\">0</span>]]</span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">24</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span></span><br><span class=\"line\">[[<span class=\"number\">0</span>,<span class=\"number\">6</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\"> [<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\"> [<span class=\"number\">0</span>,<span class=\"number\">9</span>,<span class=\"number\">0</span>]]</span><br><span class=\"line\"><span class=\"string\">Path</span> <span class=\"string\">to</span> <span class=\"string\">get</span> <span class=\"string\">the</span> <span class=\"string\">maximum</span> <span class=\"string\">gold,</span> <span class=\"number\">9</span> <span class=\"string\">-&gt;</span> <span class=\"number\">8</span> <span class=\"string\">-&gt;</span> <span class=\"number\">7</span><span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> <span class=\"string\">grid</span> <span class=\"string\">=</span> [[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">7</span>],[<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">6</span>],[<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>],[<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>],[<span class=\"number\">9</span>,<span class=\"number\">0</span>,<span class=\"number\">20</span>]]</span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">28</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span></span><br><span class=\"line\">[[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\"> [<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">6</span>],</span><br><span class=\"line\"> [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>],</span><br><span class=\"line\"> [<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\"> [<span class=\"number\">9</span>,<span class=\"number\">0</span>,<span class=\"number\">20</span>]]</span><br><span class=\"line\"><span class=\"string\">Path</span> <span class=\"string\">to</span> <span class=\"string\">get</span> <span class=\"string\">the</span> <span class=\"string\">maximum</span> <span class=\"string\">gold,</span> <span class=\"number\">1</span> <span class=\"string\">-&gt;</span> <span class=\"number\">2</span> <span class=\"string\">-&gt;</span> <span class=\"number\">3</span> <span class=\"string\">-&gt;</span> <span class=\"number\">4</span> <span class=\"string\">-&gt;</span> <span class=\"number\">5</span> <span class=\"string\">-&gt;</span> <span class=\"number\">6</span> <span class=\"string\">-&gt;</span> <span class=\"number\">7</span><span class=\"string\">.</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"思路-3\"><a class=\"markdownIt-Anchor\" href=\"#思路-3\"></a> 思路</h3>\n<p>很简单的 DFS 算法实现, 没什么好说的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMaximumGold</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = grid.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (grid[i][j] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    max = Math.max(max, dfs(grid, <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i, j&#125;, <span class=\"number\">0</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid, <span class=\"keyword\">int</span>[] startPos, <span class=\"keyword\">int</span> gold)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = grid.length, n = grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = startPos[<span class=\"number\">0</span>], c = startPos[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span> || c &lt; <span class=\"number\">0</span> || r &gt;= m || c &gt;= n || grid[r][c] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> gold;</span><br><span class=\"line\">        gold += grid[r][c];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                nums[i][j] = grid[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nums[r][c] = <span class=\"number\">0</span>;             <span class=\"comment\">//Get the gold</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> a1 = dfs(nums, <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;r, c + <span class=\"number\">1</span>&#125;, gold);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b1 = dfs(nums, <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;r, c - <span class=\"number\">1</span>&#125;, gold);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c1 = dfs(nums, <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;r + <span class=\"number\">1</span>, c&#125;, gold);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d1 = dfs(nums, <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;r - <span class=\"number\">1</span>, c&#125;, gold);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.stream(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;a1, b1, c1, d1&#125;).max().getAsInt();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-count-vowels-permutation\"><a class=\"markdownIt-Anchor\" href=\"#4-count-vowels-permutation\"></a> 4. Count Vowels Permutation</h2>\n<h3 id=\"描述-4\"><a class=\"markdownIt-Anchor\" href=\"#描述-4\"></a> 描述</h3>\n<p>Given an integer <code>n</code>, your task is to count how many strings of length <code>n</code> can be formed under the following rules:</p>\n<ul>\n<li>Each character is a lower case vowel (<code>'a'</code>, <code>'e'</code>, <code>'i'</code>, <code>'o'</code>, <code>'u'</code>)</li>\n<li>Each vowel <code>'a'</code> may only be followed by an <code>'e'</code>.</li>\n<li>Each vowel <code>'e'</code> may only be followed by an <code>'a'</code> or an <code>'i'</code>.</li>\n<li>Each vowel <code>'i'</code> <strong>may not</strong> be followed by another <code>'i'</code>.</li>\n<li>Each vowel <code>'o'</code> may only be followed by an <code>'i'</code> or a <code>'u'</code>.</li>\n<li>Each vowel <code>'u'</code> may only be followed by an <code>'a'.</code></li>\n</ul>\n<p>Since the answer may be too large, return it modulo <code>10^9 + 7.</code></p>\n<p><strong>Example 1:</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> n = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span> All possible strings <span class=\"attr\">are:</span> <span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;e&quot;</span>, <span class=\"string\">&quot;i&quot;</span> , <span class=\"string\">&quot;o&quot;</span> and <span class=\"string\">&quot;u&quot;</span>.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 2:</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> n = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"attr\">Explanation:</span> All possible strings <span class=\"attr\">are:</span> <span class=\"string\">&quot;ae&quot;</span>, <span class=\"string\">&quot;ea&quot;</span>, <span class=\"string\">&quot;ei&quot;</span>, <span class=\"string\">&quot;ia&quot;</span>, <span class=\"string\">&quot;ie&quot;</span>, <span class=\"string\">&quot;io&quot;</span>, <span class=\"string\">&quot;iu&quot;</span>, <span class=\"string\">&quot;oi&quot;</span>, <span class=\"string\">&quot;ou&quot;</span> and <span class=\"string\">&quot;ua&quot;</span>.</span><br></pre></td></tr></table></figure>\n<p><strong>Example 3:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Input:</span> <span class=\"string\">n</span> <span class=\"string\">=</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">Output:</span> <span class=\"number\">68</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"思路-4\"><a class=\"markdownIt-Anchor\" href=\"#思路-4\"></a> 思路</h3>\n<p>假定某一步的最末位中, ‘a’ , ‘e’ , ‘i’ , ‘o’ , ‘u’ 的个数分别是 a , e , i , o , u ，那么下一步末位的个数就分别是 <code>u+e+i</code>, <code>a + i</code>, <code>e + o</code> , <code>i</code> , <code>o +i</code></p>\n<p>我这里用了一个hash来保存 (小声：这个hard题是简单题的赶脚233)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> mod = <span class=\"number\">1_000_000_007</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countVowelPermutation</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character, Long&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"number\">1L</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&#x27;e&#x27;</span>, <span class=\"number\">1L</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&#x27;i&#x27;</span>, <span class=\"number\">1L</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&#x27;o&#x27;</span>, <span class=\"number\">1L</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&#x27;u&#x27;</span>, <span class=\"number\">1L</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            Map&lt;Character, Long&gt; tmp = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">            tmp.put(<span class=\"string\">&#x27;a&#x27;</span>, (map.get(<span class=\"string\">&#x27;u&#x27;</span>) + map.get(<span class=\"string\">&#x27;e&#x27;</span>) + map.get(<span class=\"string\">&#x27;i&#x27;</span>)) % mod);</span><br><span class=\"line\">            tmp.put(<span class=\"string\">&#x27;e&#x27;</span>, (map.get(<span class=\"string\">&#x27;a&#x27;</span>) + map.get(<span class=\"string\">&#x27;i&#x27;</span>)) % mod);</span><br><span class=\"line\">            tmp.put(<span class=\"string\">&#x27;i&#x27;</span>, (map.get(<span class=\"string\">&#x27;e&#x27;</span>) + map.get(<span class=\"string\">&#x27;o&#x27;</span>)) % mod);</span><br><span class=\"line\">            tmp.put(<span class=\"string\">&#x27;o&#x27;</span>, (map.get(<span class=\"string\">&#x27;i&#x27;</span>)) % mod);</span><br><span class=\"line\">            tmp.put(<span class=\"string\">&#x27;u&#x27;</span>, (map.get(<span class=\"string\">&#x27;o&#x27;</span>) + map.get(<span class=\"string\">&#x27;i&#x27;</span>)) % mod);</span><br><span class=\"line\"></span><br><span class=\"line\">            map = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) (map.values().stream().reduce(Long::sum).get() % mod);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a class=\"markdownIt-Anchor\" href=\"#结语\"></a> 结语</h2>\n<p>这次周赛4个题目全部 AC , RANK  740</p>\n"},{"title":"初探Anna","date":"2020-02-17T03:05:56.000Z","cover_img":"https://images.unsplash.com/photo-1551342909-187e24a5797d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=675&q=80","cover":"https://images.unsplash.com/photo-1551342909-187e24a5797d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=675&q=80","feature_img":"https://images.unsplash.com/photo-1517999349371-c43520457b23?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80","description":"由伯克利开发的新一代数据库引擎","keywords":null,"_content":"## Anna初探\n\n### 背景\n\n实习中主要做的是数据库引擎的开发。这一次遇到的是伯克利开发的 *Anna* ，将透过两篇paper来大致讲述一下入门的内容。\n\n### 进入正题\n\n解决目标：\n\n- *data scaling* ：牵涉到数据分片 **partition**\n- *workload scaling* ：牵涉到 **multi-master replication**\n- 硬件最大化利用 & 多核计算机性能 ：**wait-free execution** (每一个core尽可能让他们一直工作)\n- 无协调的一致性 **coordination-free consistency model**\n  - 一致性哈希 & 哈希环\n\n> ##### Lattice 晶格\n>\n> 离散里面的一种偏序结构. 整个图里面只有一个起点和一个终点\n>\n> 达到的事务隔离级别 ：**read-committed transaction**\n>\n> 就这一点，论文中提到了 **casual consistency** 和 **read committed** 两种一致性的*level* ，具体就留到后面展开论述\n\n#### 可用的分布式状态模型类别\n\n- 共享内存\n\n  该方式常常需要额外的加锁去锁来进行一致性维护，因而极大地影响了系统运行效率\n\n  Lattice也不能解决异步请求的数据同步问题，它最重要的 **merge function** 也是需要\n\n- 消息传递\n\n采用了消息传递的架构后，工作节点能够拥有类似于 **local-thread** 的私有状态(*state*)。由于对外界不可见，也就没有了并发的问题\n\n但是由于各个副本之间牵涉到数据的同步，这就会有一个新的 **状态一致性** 问题的出现，我们需要采用新的机制来进行改进\n\n**Single-Master**\n\n- Key值只有一个副本，可以有比较好的一致性\n- 问题：速度不能超过一个node ，这是一个瓶颈\n\n**Multi-Master**\n\n- Key值存在于多个副本中\n- 周期性进行广播发送*update* 信息\n- 问题：一致性不能够保证\n\n> **Anna** 使用的是无协调的 *multi-master replication* ，并且基于 **lattice** 来进行一致性的保证\n\n### Anna架构\n\n主要根据两篇(2018 , 2019) 中先后两个版本的 *Anna* 架构不同点入手\n\n> #### Lattice based\n>\n> *Lattice* 是这个框架主打的内容：在给定的一个偏序条件下，只要该偏序关系重的 **least upper bound** 又满足了\n>\n> - Commutativity 交换律\n> - Associativity 结合律\n> - Idempotence 幂等\n>\n> 那么就可以说是满足一个晶格的关系。这样的系统我们也称作 **ACI system**\n\n2018 Anna-ieee 中的架构图如下 （单一server）\n\n<img src=\"https://i.loli.net/2020/02/17/4xZGNqDcfgkKAlj.png\" alt=\"image.png\"  />\n\n每一个 *actor*都会周期性发出广播，告知 *changeset* 所关联的 *master* ，将更新信息 *merge* 进入各自的私有状态空间，并且清空 *changeset*\n\n#### 多Tire架构\n\n这一个架构是在 2019 anna-vldb 中给出的，和之前的区别主要是适用于云端的分布式系统。更多地把架构重点放在了 **水平扩展** 、**数据访问偏好&负载均衡**、**数据垂直转移**\n\n分布式Anna架构如下图：\n\n> 多个 *Tier* -> 一个 *Tier* 内部有多个 *node* -> 一个 *node* 内部有多个 *worker thread*\n\n<img src=\"https://i.loli.net/2020/02/17/RLbxf3vWFSJcnC4.png\" alt=\"image.png\"  />\n\n\n\n### 回到我们的一致性问题\n\n*ACI* 系统中，由于它的组件也必然满足一个lattice关系，我们就可以采用 **自底向上组合** 的方式来进行系统逻辑的构建\n\n<img src=\"https://i.loli.net/2020/02/17/cYaxepWz2ZdgVTj.png\" alt=\"image.png\" style=\"zoom: 77%;\" />\n\n如上图所示 （*casual consistency*）\n\n- 每一个工作节点(worker)的状态都采用 **MapLattice** 来进行表示\n- **MapLattice**的键，是一种不可变的类型(*immutable*) ；对于值，则是 **ValueLattice**\n\n> 对于 **MapLattice** 的 *merge* 算子，会对两个 MapLattice 的键进行 *Union* 操作，若键相同，那么会进行 **ValueLattice** 的 *merge* 算子\n\n---\n\n接下来我们需要看之前提及的 **casual consistency** 和 **read committed** \n\n#### Casual Consistency\n\n> A , B 两个用户同时在进行事务处理，如果 B 能够见到 A 的更新，那么 B 的更新将会 *Overwrite* A用户的更新；如果不能够看到，那么就会触发数据记录的 *merge* 算子\n\n关键点：**vector lock**\n\n支持 *casual consistency* 的方案中，*vector lock* 的键由客户端的 *proxy ids* 组成，值则由相对应的版本号组成。他们相互具有关联关系。这里的 *version number* 可以由 **MaxIntLattice** 来进行实现，它每次都取**更新前后的最大值**，所以它的值必定是递增的，也契合了版本号递增的特点。\n\n当进行一次写操作的时候，会把 **vector lock** 的版本号进行增加，连同数据项一起进行写入\n\n图中的 **pair lattice** 也具有 *merge* 算子，具体算法如下\n\n> 对于两个 **pair lattice** P(a,b) 和 Q(a,b) ，如果 P.a > Q.a (表示偏序大小关系) ，我们称 **P casually follows Q** ，并且将 *merge* 结果设置为 P\n>\n> 如果不能够进行比较，那么*merge* 结果就是\n>\n> ![image.png](https://i.loli.net/2020/02/17/cbe2SQOmtJ9KPrx.png)\n\n#### Read Committed\n\n和数据库事务隔离级别一样，读提交的要求就是避免 **脏读** 和 **脏写**\n\n##### 脏写\n\n多个写事件的执行中，我们只需要添加一个 *larger timestamp wins* 策略\n\n##### 脏读\n\n添加事务写入的缓冲区，保证未提交的事务不会被放入 *KVS*\n\n\n\n\n\n### 遗留的一些问题\n\n- Critical path of every request 是什么？\n\n","source":"_posts/初探Anna.md","raw":"---\ntitle: 初探Anna\ndate: 2020-02-17 11:05:56\ntags: 笔记\ncover_img: https://images.unsplash.com/photo-1551342909-187e24a5797d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=675&q=80\ncover: https://images.unsplash.com/photo-1551342909-187e24a5797d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=675&q=80\nfeature_img: https://images.unsplash.com/photo-1517999349371-c43520457b23?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80\ndescription: 由伯克利开发的新一代数据库引擎\nkeywords:\n---\n## Anna初探\n\n### 背景\n\n实习中主要做的是数据库引擎的开发。这一次遇到的是伯克利开发的 *Anna* ，将透过两篇paper来大致讲述一下入门的内容。\n\n### 进入正题\n\n解决目标：\n\n- *data scaling* ：牵涉到数据分片 **partition**\n- *workload scaling* ：牵涉到 **multi-master replication**\n- 硬件最大化利用 & 多核计算机性能 ：**wait-free execution** (每一个core尽可能让他们一直工作)\n- 无协调的一致性 **coordination-free consistency model**\n  - 一致性哈希 & 哈希环\n\n> ##### Lattice 晶格\n>\n> 离散里面的一种偏序结构. 整个图里面只有一个起点和一个终点\n>\n> 达到的事务隔离级别 ：**read-committed transaction**\n>\n> 就这一点，论文中提到了 **casual consistency** 和 **read committed** 两种一致性的*level* ，具体就留到后面展开论述\n\n#### 可用的分布式状态模型类别\n\n- 共享内存\n\n  该方式常常需要额外的加锁去锁来进行一致性维护，因而极大地影响了系统运行效率\n\n  Lattice也不能解决异步请求的数据同步问题，它最重要的 **merge function** 也是需要\n\n- 消息传递\n\n采用了消息传递的架构后，工作节点能够拥有类似于 **local-thread** 的私有状态(*state*)。由于对外界不可见，也就没有了并发的问题\n\n但是由于各个副本之间牵涉到数据的同步，这就会有一个新的 **状态一致性** 问题的出现，我们需要采用新的机制来进行改进\n\n**Single-Master**\n\n- Key值只有一个副本，可以有比较好的一致性\n- 问题：速度不能超过一个node ，这是一个瓶颈\n\n**Multi-Master**\n\n- Key值存在于多个副本中\n- 周期性进行广播发送*update* 信息\n- 问题：一致性不能够保证\n\n> **Anna** 使用的是无协调的 *multi-master replication* ，并且基于 **lattice** 来进行一致性的保证\n\n### Anna架构\n\n主要根据两篇(2018 , 2019) 中先后两个版本的 *Anna* 架构不同点入手\n\n> #### Lattice based\n>\n> *Lattice* 是这个框架主打的内容：在给定的一个偏序条件下，只要该偏序关系重的 **least upper bound** 又满足了\n>\n> - Commutativity 交换律\n> - Associativity 结合律\n> - Idempotence 幂等\n>\n> 那么就可以说是满足一个晶格的关系。这样的系统我们也称作 **ACI system**\n\n2018 Anna-ieee 中的架构图如下 （单一server）\n\n<img src=\"https://i.loli.net/2020/02/17/4xZGNqDcfgkKAlj.png\" alt=\"image.png\"  />\n\n每一个 *actor*都会周期性发出广播，告知 *changeset* 所关联的 *master* ，将更新信息 *merge* 进入各自的私有状态空间，并且清空 *changeset*\n\n#### 多Tire架构\n\n这一个架构是在 2019 anna-vldb 中给出的，和之前的区别主要是适用于云端的分布式系统。更多地把架构重点放在了 **水平扩展** 、**数据访问偏好&负载均衡**、**数据垂直转移**\n\n分布式Anna架构如下图：\n\n> 多个 *Tier* -> 一个 *Tier* 内部有多个 *node* -> 一个 *node* 内部有多个 *worker thread*\n\n<img src=\"https://i.loli.net/2020/02/17/RLbxf3vWFSJcnC4.png\" alt=\"image.png\"  />\n\n\n\n### 回到我们的一致性问题\n\n*ACI* 系统中，由于它的组件也必然满足一个lattice关系，我们就可以采用 **自底向上组合** 的方式来进行系统逻辑的构建\n\n<img src=\"https://i.loli.net/2020/02/17/cYaxepWz2ZdgVTj.png\" alt=\"image.png\" style=\"zoom: 77%;\" />\n\n如上图所示 （*casual consistency*）\n\n- 每一个工作节点(worker)的状态都采用 **MapLattice** 来进行表示\n- **MapLattice**的键，是一种不可变的类型(*immutable*) ；对于值，则是 **ValueLattice**\n\n> 对于 **MapLattice** 的 *merge* 算子，会对两个 MapLattice 的键进行 *Union* 操作，若键相同，那么会进行 **ValueLattice** 的 *merge* 算子\n\n---\n\n接下来我们需要看之前提及的 **casual consistency** 和 **read committed** \n\n#### Casual Consistency\n\n> A , B 两个用户同时在进行事务处理，如果 B 能够见到 A 的更新，那么 B 的更新将会 *Overwrite* A用户的更新；如果不能够看到，那么就会触发数据记录的 *merge* 算子\n\n关键点：**vector lock**\n\n支持 *casual consistency* 的方案中，*vector lock* 的键由客户端的 *proxy ids* 组成，值则由相对应的版本号组成。他们相互具有关联关系。这里的 *version number* 可以由 **MaxIntLattice** 来进行实现，它每次都取**更新前后的最大值**，所以它的值必定是递增的，也契合了版本号递增的特点。\n\n当进行一次写操作的时候，会把 **vector lock** 的版本号进行增加，连同数据项一起进行写入\n\n图中的 **pair lattice** 也具有 *merge* 算子，具体算法如下\n\n> 对于两个 **pair lattice** P(a,b) 和 Q(a,b) ，如果 P.a > Q.a (表示偏序大小关系) ，我们称 **P casually follows Q** ，并且将 *merge* 结果设置为 P\n>\n> 如果不能够进行比较，那么*merge* 结果就是\n>\n> ![image.png](https://i.loli.net/2020/02/17/cbe2SQOmtJ9KPrx.png)\n\n#### Read Committed\n\n和数据库事务隔离级别一样，读提交的要求就是避免 **脏读** 和 **脏写**\n\n##### 脏写\n\n多个写事件的执行中，我们只需要添加一个 *larger timestamp wins* 策略\n\n##### 脏读\n\n添加事务写入的缓冲区，保证未提交的事务不会被放入 *KVS*\n\n\n\n\n\n### 遗留的一些问题\n\n- Critical path of every request 是什么？\n\n","slug":"初探Anna","published":1,"updated":"2020-10-22T02:12:58.118Z","_id":"ckgk7k80l000k06mefb0g7u7t","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"anna初探\"><a class=\"markdownIt-Anchor\" href=\"#anna初探\"></a> Anna初探</h2>\n<h3 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\"></a> 背景</h3>\n<p>实习中主要做的是数据库引擎的开发。这一次遇到的是伯克利开发的 <em>Anna</em> ，将透过两篇paper来大致讲述一下入门的内容。</p>\n<h3 id=\"进入正题\"><a class=\"markdownIt-Anchor\" href=\"#进入正题\"></a> 进入正题</h3>\n<p>解决目标：</p>\n<ul>\n<li><em>data scaling</em> ：牵涉到数据分片 <strong>partition</strong></li>\n<li><em>workload scaling</em> ：牵涉到 <strong>multi-master replication</strong></li>\n<li>硬件最大化利用 &amp; 多核计算机性能 ：<strong>wait-free execution</strong> (每一个core尽可能让他们一直工作)</li>\n<li>无协调的一致性 <strong>coordination-free consistency model</strong>\n<ul>\n<li>一致性哈希 &amp; 哈希环</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<h5 id=\"lattice-晶格\"><a class=\"markdownIt-Anchor\" href=\"#lattice-晶格\"></a> Lattice 晶格</h5>\n<p>离散里面的一种偏序结构. 整个图里面只有一个起点和一个终点</p>\n<p>达到的事务隔离级别 ：<strong>read-committed transaction</strong></p>\n<p>就这一点，论文中提到了 <strong>casual consistency</strong> 和 <strong>read committed</strong> 两种一致性的<em>level</em> ，具体就留到后面展开论述</p>\n</blockquote>\n<h4 id=\"可用的分布式状态模型类别\"><a class=\"markdownIt-Anchor\" href=\"#可用的分布式状态模型类别\"></a> 可用的分布式状态模型类别</h4>\n<ul>\n<li>\n<p>共享内存</p>\n<p>该方式常常需要额外的加锁去锁来进行一致性维护，因而极大地影响了系统运行效率</p>\n<p>Lattice也不能解决异步请求的数据同步问题，它最重要的 <strong>merge function</strong> 也是需要</p>\n</li>\n<li>\n<p>消息传递</p>\n</li>\n</ul>\n<p>采用了消息传递的架构后，工作节点能够拥有类似于 <strong>local-thread</strong> 的私有状态(<em>state</em>)。由于对外界不可见，也就没有了并发的问题</p>\n<p>但是由于各个副本之间牵涉到数据的同步，这就会有一个新的 <strong>状态一致性</strong> 问题的出现，我们需要采用新的机制来进行改进</p>\n<p><strong>Single-Master</strong></p>\n<ul>\n<li>Key值只有一个副本，可以有比较好的一致性</li>\n<li>问题：速度不能超过一个node ，这是一个瓶颈</li>\n</ul>\n<p><strong>Multi-Master</strong></p>\n<ul>\n<li>Key值存在于多个副本中</li>\n<li>周期性进行广播发送<em>update</em> 信息</li>\n<li>问题：一致性不能够保证</li>\n</ul>\n<blockquote>\n<p><strong>Anna</strong> 使用的是无协调的 <em>multi-master replication</em> ，并且基于 <strong>lattice</strong> 来进行一致性的保证</p>\n</blockquote>\n<h3 id=\"anna架构\"><a class=\"markdownIt-Anchor\" href=\"#anna架构\"></a> Anna架构</h3>\n<p>主要根据两篇(2018 , 2019) 中先后两个版本的 <em>Anna</em> 架构不同点入手</p>\n<blockquote>\n<h4 id=\"lattice-based\"><a class=\"markdownIt-Anchor\" href=\"#lattice-based\"></a> Lattice based</h4>\n<p><em>Lattice</em> 是这个框架主打的内容：在给定的一个偏序条件下，只要该偏序关系重的 <strong>least upper bound</strong> 又满足了</p>\n<ul>\n<li>Commutativity 交换律</li>\n<li>Associativity 结合律</li>\n<li>Idempotence 幂等</li>\n</ul>\n<p>那么就可以说是满足一个晶格的关系。这样的系统我们也称作 <strong>ACI system</strong></p>\n</blockquote>\n<p>2018 Anna-ieee 中的架构图如下 （单一server）</p>\n<img src=\"https://i.loli.net/2020/02/17/4xZGNqDcfgkKAlj.png\" alt=\"image.png\"  />\n<p>每一个 <em>actor</em>都会周期性发出广播，告知 <em>changeset</em> 所关联的 <em>master</em> ，将更新信息 <em>merge</em> 进入各自的私有状态空间，并且清空 <em>changeset</em></p>\n<h4 id=\"多tire架构\"><a class=\"markdownIt-Anchor\" href=\"#多tire架构\"></a> 多Tire架构</h4>\n<p>这一个架构是在 2019 anna-vldb 中给出的，和之前的区别主要是适用于云端的分布式系统。更多地把架构重点放在了 <strong>水平扩展</strong> 、<strong>数据访问偏好&amp;负载均衡</strong>、<strong>数据垂直转移</strong></p>\n<p>分布式Anna架构如下图：</p>\n<blockquote>\n<p>多个 <em>Tier</em> -&gt; 一个 <em>Tier</em> 内部有多个 <em>node</em> -&gt; 一个 <em>node</em> 内部有多个 <em>worker thread</em></p>\n</blockquote>\n<img src=\"https://i.loli.net/2020/02/17/RLbxf3vWFSJcnC4.png\" alt=\"image.png\"  />\n<h3 id=\"回到我们的一致性问题\"><a class=\"markdownIt-Anchor\" href=\"#回到我们的一致性问题\"></a> 回到我们的一致性问题</h3>\n<p><em>ACI</em> 系统中，由于它的组件也必然满足一个lattice关系，我们就可以采用 <strong>自底向上组合</strong> 的方式来进行系统逻辑的构建</p>\n<img src=\"https://i.loli.net/2020/02/17/cYaxepWz2ZdgVTj.png\" alt=\"image.png\" style=\"zoom: 77%;\" />\n<p>如上图所示 （<em>casual consistency</em>）</p>\n<ul>\n<li>每一个工作节点(worker)的状态都采用 <strong>MapLattice</strong> 来进行表示</li>\n<li><strong>MapLattice</strong>的键，是一种不可变的类型(<em>immutable</em>) ；对于值，则是 <strong>ValueLattice</strong></li>\n</ul>\n<blockquote>\n<p>对于 <strong>MapLattice</strong> 的 <em>merge</em> 算子，会对两个 MapLattice 的键进行 <em>Union</em> 操作，若键相同，那么会进行 <strong>ValueLattice</strong> 的 <em>merge</em> 算子</p>\n</blockquote>\n<hr />\n<p>接下来我们需要看之前提及的 <strong>casual consistency</strong> 和 <strong>read committed</strong></p>\n<h4 id=\"casual-consistency\"><a class=\"markdownIt-Anchor\" href=\"#casual-consistency\"></a> Casual Consistency</h4>\n<blockquote>\n<p>A , B 两个用户同时在进行事务处理，如果 B 能够见到 A 的更新，那么 B 的更新将会 <em>Overwrite</em> A用户的更新；如果不能够看到，那么就会触发数据记录的 <em>merge</em> 算子</p>\n</blockquote>\n<p>关键点：<strong>vector lock</strong></p>\n<p>支持 <em>casual consistency</em> 的方案中，<em>vector lock</em> 的键由客户端的 <em>proxy ids</em> 组成，值则由相对应的版本号组成。他们相互具有关联关系。这里的 <em>version number</em> 可以由 <strong>MaxIntLattice</strong> 来进行实现，它每次都取<strong>更新前后的最大值</strong>，所以它的值必定是递增的，也契合了版本号递增的特点。</p>\n<p>当进行一次写操作的时候，会把 <strong>vector lock</strong> 的版本号进行增加，连同数据项一起进行写入</p>\n<p>图中的 <strong>pair lattice</strong> 也具有 <em>merge</em> 算子，具体算法如下</p>\n<blockquote>\n<p>对于两个 <strong>pair lattice</strong> P(a,b) 和 Q(a,b) ，如果 P.a &gt; Q.a (表示偏序大小关系) ，我们称 <strong>P casually follows Q</strong> ，并且将 <em>merge</em> 结果设置为 P</p>\n<p>如果不能够进行比较，那么<em>merge</em> 结果就是</p>\n<p><img src=\"https://i.loli.net/2020/02/17/cbe2SQOmtJ9KPrx.png\" alt=\"image.png\" /></p>\n</blockquote>\n<h4 id=\"read-committed\"><a class=\"markdownIt-Anchor\" href=\"#read-committed\"></a> Read Committed</h4>\n<p>和数据库事务隔离级别一样，读提交的要求就是避免 <strong>脏读</strong> 和 <strong>脏写</strong></p>\n<h5 id=\"脏写\"><a class=\"markdownIt-Anchor\" href=\"#脏写\"></a> 脏写</h5>\n<p>多个写事件的执行中，我们只需要添加一个 <em>larger timestamp wins</em> 策略</p>\n<h5 id=\"脏读\"><a class=\"markdownIt-Anchor\" href=\"#脏读\"></a> 脏读</h5>\n<p>添加事务写入的缓冲区，保证未提交的事务不会被放入 <em>KVS</em></p>\n<h3 id=\"遗留的一些问题\"><a class=\"markdownIt-Anchor\" href=\"#遗留的一些问题\"></a> 遗留的一些问题</h3>\n<ul>\n<li>Critical path of every request 是什么？</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"anna初探\"><a class=\"markdownIt-Anchor\" href=\"#anna初探\"></a> Anna初探</h2>\n<h3 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\"></a> 背景</h3>\n<p>实习中主要做的是数据库引擎的开发。这一次遇到的是伯克利开发的 <em>Anna</em> ，将透过两篇paper来大致讲述一下入门的内容。</p>\n<h3 id=\"进入正题\"><a class=\"markdownIt-Anchor\" href=\"#进入正题\"></a> 进入正题</h3>\n<p>解决目标：</p>\n<ul>\n<li><em>data scaling</em> ：牵涉到数据分片 <strong>partition</strong></li>\n<li><em>workload scaling</em> ：牵涉到 <strong>multi-master replication</strong></li>\n<li>硬件最大化利用 &amp; 多核计算机性能 ：<strong>wait-free execution</strong> (每一个core尽可能让他们一直工作)</li>\n<li>无协调的一致性 <strong>coordination-free consistency model</strong>\n<ul>\n<li>一致性哈希 &amp; 哈希环</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<h5 id=\"lattice-晶格\"><a class=\"markdownIt-Anchor\" href=\"#lattice-晶格\"></a> Lattice 晶格</h5>\n<p>离散里面的一种偏序结构. 整个图里面只有一个起点和一个终点</p>\n<p>达到的事务隔离级别 ：<strong>read-committed transaction</strong></p>\n<p>就这一点，论文中提到了 <strong>casual consistency</strong> 和 <strong>read committed</strong> 两种一致性的<em>level</em> ，具体就留到后面展开论述</p>\n</blockquote>\n<h4 id=\"可用的分布式状态模型类别\"><a class=\"markdownIt-Anchor\" href=\"#可用的分布式状态模型类别\"></a> 可用的分布式状态模型类别</h4>\n<ul>\n<li>\n<p>共享内存</p>\n<p>该方式常常需要额外的加锁去锁来进行一致性维护，因而极大地影响了系统运行效率</p>\n<p>Lattice也不能解决异步请求的数据同步问题，它最重要的 <strong>merge function</strong> 也是需要</p>\n</li>\n<li>\n<p>消息传递</p>\n</li>\n</ul>\n<p>采用了消息传递的架构后，工作节点能够拥有类似于 <strong>local-thread</strong> 的私有状态(<em>state</em>)。由于对外界不可见，也就没有了并发的问题</p>\n<p>但是由于各个副本之间牵涉到数据的同步，这就会有一个新的 <strong>状态一致性</strong> 问题的出现，我们需要采用新的机制来进行改进</p>\n<p><strong>Single-Master</strong></p>\n<ul>\n<li>Key值只有一个副本，可以有比较好的一致性</li>\n<li>问题：速度不能超过一个node ，这是一个瓶颈</li>\n</ul>\n<p><strong>Multi-Master</strong></p>\n<ul>\n<li>Key值存在于多个副本中</li>\n<li>周期性进行广播发送<em>update</em> 信息</li>\n<li>问题：一致性不能够保证</li>\n</ul>\n<blockquote>\n<p><strong>Anna</strong> 使用的是无协调的 <em>multi-master replication</em> ，并且基于 <strong>lattice</strong> 来进行一致性的保证</p>\n</blockquote>\n<h3 id=\"anna架构\"><a class=\"markdownIt-Anchor\" href=\"#anna架构\"></a> Anna架构</h3>\n<p>主要根据两篇(2018 , 2019) 中先后两个版本的 <em>Anna</em> 架构不同点入手</p>\n<blockquote>\n<h4 id=\"lattice-based\"><a class=\"markdownIt-Anchor\" href=\"#lattice-based\"></a> Lattice based</h4>\n<p><em>Lattice</em> 是这个框架主打的内容：在给定的一个偏序条件下，只要该偏序关系重的 <strong>least upper bound</strong> 又满足了</p>\n<ul>\n<li>Commutativity 交换律</li>\n<li>Associativity 结合律</li>\n<li>Idempotence 幂等</li>\n</ul>\n<p>那么就可以说是满足一个晶格的关系。这样的系统我们也称作 <strong>ACI system</strong></p>\n</blockquote>\n<p>2018 Anna-ieee 中的架构图如下 （单一server）</p>\n<img src=\"https://i.loli.net/2020/02/17/4xZGNqDcfgkKAlj.png\" alt=\"image.png\"  />\n<p>每一个 <em>actor</em>都会周期性发出广播，告知 <em>changeset</em> 所关联的 <em>master</em> ，将更新信息 <em>merge</em> 进入各自的私有状态空间，并且清空 <em>changeset</em></p>\n<h4 id=\"多tire架构\"><a class=\"markdownIt-Anchor\" href=\"#多tire架构\"></a> 多Tire架构</h4>\n<p>这一个架构是在 2019 anna-vldb 中给出的，和之前的区别主要是适用于云端的分布式系统。更多地把架构重点放在了 <strong>水平扩展</strong> 、<strong>数据访问偏好&amp;负载均衡</strong>、<strong>数据垂直转移</strong></p>\n<p>分布式Anna架构如下图：</p>\n<blockquote>\n<p>多个 <em>Tier</em> -&gt; 一个 <em>Tier</em> 内部有多个 <em>node</em> -&gt; 一个 <em>node</em> 内部有多个 <em>worker thread</em></p>\n</blockquote>\n<img src=\"https://i.loli.net/2020/02/17/RLbxf3vWFSJcnC4.png\" alt=\"image.png\"  />\n<h3 id=\"回到我们的一致性问题\"><a class=\"markdownIt-Anchor\" href=\"#回到我们的一致性问题\"></a> 回到我们的一致性问题</h3>\n<p><em>ACI</em> 系统中，由于它的组件也必然满足一个lattice关系，我们就可以采用 <strong>自底向上组合</strong> 的方式来进行系统逻辑的构建</p>\n<img src=\"https://i.loli.net/2020/02/17/cYaxepWz2ZdgVTj.png\" alt=\"image.png\" style=\"zoom: 77%;\" />\n<p>如上图所示 （<em>casual consistency</em>）</p>\n<ul>\n<li>每一个工作节点(worker)的状态都采用 <strong>MapLattice</strong> 来进行表示</li>\n<li><strong>MapLattice</strong>的键，是一种不可变的类型(<em>immutable</em>) ；对于值，则是 <strong>ValueLattice</strong></li>\n</ul>\n<blockquote>\n<p>对于 <strong>MapLattice</strong> 的 <em>merge</em> 算子，会对两个 MapLattice 的键进行 <em>Union</em> 操作，若键相同，那么会进行 <strong>ValueLattice</strong> 的 <em>merge</em> 算子</p>\n</blockquote>\n<hr />\n<p>接下来我们需要看之前提及的 <strong>casual consistency</strong> 和 <strong>read committed</strong></p>\n<h4 id=\"casual-consistency\"><a class=\"markdownIt-Anchor\" href=\"#casual-consistency\"></a> Casual Consistency</h4>\n<blockquote>\n<p>A , B 两个用户同时在进行事务处理，如果 B 能够见到 A 的更新，那么 B 的更新将会 <em>Overwrite</em> A用户的更新；如果不能够看到，那么就会触发数据记录的 <em>merge</em> 算子</p>\n</blockquote>\n<p>关键点：<strong>vector lock</strong></p>\n<p>支持 <em>casual consistency</em> 的方案中，<em>vector lock</em> 的键由客户端的 <em>proxy ids</em> 组成，值则由相对应的版本号组成。他们相互具有关联关系。这里的 <em>version number</em> 可以由 <strong>MaxIntLattice</strong> 来进行实现，它每次都取<strong>更新前后的最大值</strong>，所以它的值必定是递增的，也契合了版本号递增的特点。</p>\n<p>当进行一次写操作的时候，会把 <strong>vector lock</strong> 的版本号进行增加，连同数据项一起进行写入</p>\n<p>图中的 <strong>pair lattice</strong> 也具有 <em>merge</em> 算子，具体算法如下</p>\n<blockquote>\n<p>对于两个 <strong>pair lattice</strong> P(a,b) 和 Q(a,b) ，如果 P.a &gt; Q.a (表示偏序大小关系) ，我们称 <strong>P casually follows Q</strong> ，并且将 <em>merge</em> 结果设置为 P</p>\n<p>如果不能够进行比较，那么<em>merge</em> 结果就是</p>\n<p><img src=\"https://i.loli.net/2020/02/17/cbe2SQOmtJ9KPrx.png\" alt=\"image.png\" /></p>\n</blockquote>\n<h4 id=\"read-committed\"><a class=\"markdownIt-Anchor\" href=\"#read-committed\"></a> Read Committed</h4>\n<p>和数据库事务隔离级别一样，读提交的要求就是避免 <strong>脏读</strong> 和 <strong>脏写</strong></p>\n<h5 id=\"脏写\"><a class=\"markdownIt-Anchor\" href=\"#脏写\"></a> 脏写</h5>\n<p>多个写事件的执行中，我们只需要添加一个 <em>larger timestamp wins</em> 策略</p>\n<h5 id=\"脏读\"><a class=\"markdownIt-Anchor\" href=\"#脏读\"></a> 脏读</h5>\n<p>添加事务写入的缓冲区，保证未提交的事务不会被放入 <em>KVS</em></p>\n<h3 id=\"遗留的一些问题\"><a class=\"markdownIt-Anchor\" href=\"#遗留的一些问题\"></a> 遗留的一些问题</h3>\n<ul>\n<li>Critical path of every request 是什么？</li>\n</ul>\n"},{"title":"数据库-索引","date":"2019-12-05T13:54:56.000Z","author":"Caribou","description":"数据库索引相关内容","cover_img":"https://images.unsplash.com/photo-1533750204176-3b0d38e9ac1e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80","cover":"https://images.unsplash.com/photo-1533750204176-3b0d38e9ac1e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80","feature_img":"https://images.unsplash.com/photo-1504639725590-34d0984388bd?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80","_content":"\n## 索引\n\n#### 页存储\n\n<img src=\"https://i.loli.net/2019/12/05/dQE6NVkHZJcWfye.png\" style=\"zoom:50%;\" />\n\n如上就是数据库在Disk Storage的一个存储方式。一个页包含若干 *Data Rows* , 通过 *Row directory* 来进行索引\n\n> A row in a table can be uniquely specified with the page number (P) and slot number (S).\n\n##### 位图索引\n\nhttps://www.cnblogs.com/LBSer/p/3322630.html\n\n位图索引中只维护distinct值，也就是说重复的值是不维护在树中\n\n对于每一个列建立一个\n\n- 位图索引适合只有几个固定值的列，如性别、婚姻状况、行政区等等，而身份证号这种类型不适合用位图索引。\n\n- 此外，位图索引适合静态数据，而不适合索引频繁更新的列\n\n##### 散列索引\n\n散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。\n\n散列索引根据对应键的散列码来找到最终的索引项的技术，其实和B树就差不多，也就是一种索引之上的二级辅助索引，我理解散列索引都是二级或更高级的稀疏索引，否则桶就太多了，效率也不会很高\n\n##### 聚簇索引\n\n所谓聚簇索引，就是指**主索引文件**和**数据文件**为==同一份文件==，聚簇索引主要用在**Innodb**存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，如下图所示：\n\n在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。\n\n##### 非聚簇索引\n\n聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接**指向对应数据块**。\n\n##### 辅助索引\n\n在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要**二次查找**。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据叶，再通过数据叶中的Page Directory找到数据行\n\n##### 唯一索引\n\n表明此索引的==每一个索引值只对应唯一的数据记录==，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复\n\n##### 主键索引\n\n在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问\n\n---\n\n数据库引擎 ：myISAM , innodb\n\nmyisam索引：因为myisam的索引和数据是分开存储存储的，myisam通过**key_buffer**把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因  \n\ninnodb索引：innodb的数据和索引放在一起，当找到索引也就找到了数据\n\n<img src=\"https://img-blog.csdn.net/20161102111454921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\" style=\"zoom:75%;\" />\n\n1.对于**非聚簇索引表**来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。\n\n2.对于**聚簇索引表**来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)\n\n> ##### 聚簇索引的优点\n>\n> 1.当你需要取出==一定范围内==的数据时，用聚簇索引也比用非聚簇索引好。\n>\n> 2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。\n>\n> 3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。\n>\n> ##### 聚簇索引的缺点\n>\n> 1.**插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。\n>\n> 2.**更新主键的代价很高，因为将会导致被更新的行移动**。因此，对于InnoDB表，我们一般定义主键为不可更新。\n>\n> 3.**二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。**\n>\n> 二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。\n>\n> 4.**采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多**，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。\n\n\n\n","source":"_posts/数据库整理-索引.md","raw":"---\ntitle: 数据库-索引\ndate: 2019-12-05 21:54:56\nauthor: Caribou\ntags: \n  - 笔记\ncategories: \n  - 笔记\ndescription: 数据库索引相关内容\ncover_img: https://images.unsplash.com/photo-1533750204176-3b0d38e9ac1e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80\ncover: https://images.unsplash.com/photo-1533750204176-3b0d38e9ac1e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80\nfeature_img: https://images.unsplash.com/photo-1504639725590-34d0984388bd?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80\n---\n\n## 索引\n\n#### 页存储\n\n<img src=\"https://i.loli.net/2019/12/05/dQE6NVkHZJcWfye.png\" style=\"zoom:50%;\" />\n\n如上就是数据库在Disk Storage的一个存储方式。一个页包含若干 *Data Rows* , 通过 *Row directory* 来进行索引\n\n> A row in a table can be uniquely specified with the page number (P) and slot number (S).\n\n##### 位图索引\n\nhttps://www.cnblogs.com/LBSer/p/3322630.html\n\n位图索引中只维护distinct值，也就是说重复的值是不维护在树中\n\n对于每一个列建立一个\n\n- 位图索引适合只有几个固定值的列，如性别、婚姻状况、行政区等等，而身份证号这种类型不适合用位图索引。\n\n- 此外，位图索引适合静态数据，而不适合索引频繁更新的列\n\n##### 散列索引\n\n散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。\n\n散列索引根据对应键的散列码来找到最终的索引项的技术，其实和B树就差不多，也就是一种索引之上的二级辅助索引，我理解散列索引都是二级或更高级的稀疏索引，否则桶就太多了，效率也不会很高\n\n##### 聚簇索引\n\n所谓聚簇索引，就是指**主索引文件**和**数据文件**为==同一份文件==，聚簇索引主要用在**Innodb**存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，如下图所示：\n\n在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。\n\n##### 非聚簇索引\n\n聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接**指向对应数据块**。\n\n##### 辅助索引\n\n在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要**二次查找**。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据叶，再通过数据叶中的Page Directory找到数据行\n\n##### 唯一索引\n\n表明此索引的==每一个索引值只对应唯一的数据记录==，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复\n\n##### 主键索引\n\n在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问\n\n---\n\n数据库引擎 ：myISAM , innodb\n\nmyisam索引：因为myisam的索引和数据是分开存储存储的，myisam通过**key_buffer**把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因  \n\ninnodb索引：innodb的数据和索引放在一起，当找到索引也就找到了数据\n\n<img src=\"https://img-blog.csdn.net/20161102111454921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\" style=\"zoom:75%;\" />\n\n1.对于**非聚簇索引表**来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。\n\n2.对于**聚簇索引表**来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)\n\n> ##### 聚簇索引的优点\n>\n> 1.当你需要取出==一定范围内==的数据时，用聚簇索引也比用非聚簇索引好。\n>\n> 2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。\n>\n> 3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。\n>\n> ##### 聚簇索引的缺点\n>\n> 1.**插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。\n>\n> 2.**更新主键的代价很高，因为将会导致被更新的行移动**。因此，对于InnoDB表，我们一般定义主键为不可更新。\n>\n> 3.**二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。**\n>\n> 二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。\n>\n> 4.**采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多**，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。\n\n\n\n","slug":"数据库整理-索引","published":1,"updated":"2020-10-22T02:12:58.118Z","_id":"ckgk7k80m000o06meagz10lse","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"索引\"><a class=\"markdownIt-Anchor\" href=\"#索引\"></a> 索引</h2>\n<h4 id=\"页存储\"><a class=\"markdownIt-Anchor\" href=\"#页存储\"></a> 页存储</h4>\n<img src=\"https://i.loli.net/2019/12/05/dQE6NVkHZJcWfye.png\" style=\"zoom:50%;\" />\n<p>如上就是数据库在Disk Storage的一个存储方式。一个页包含若干 <em>Data Rows</em> , 通过 <em>Row directory</em> 来进行索引</p>\n<blockquote>\n<p>A row in a table can be uniquely specified with the page number § and slot number (S).</p>\n</blockquote>\n<h5 id=\"位图索引\"><a class=\"markdownIt-Anchor\" href=\"#位图索引\"></a> 位图索引</h5>\n<p><a href=\"https://www.cnblogs.com/LBSer/p/3322630.html\">https://www.cnblogs.com/LBSer/p/3322630.html</a></p>\n<p>位图索引中只维护distinct值，也就是说重复的值是不维护在树中</p>\n<p>对于每一个列建立一个</p>\n<ul>\n<li>\n<p>位图索引适合只有几个固定值的列，如性别、婚姻状况、行政区等等，而身份证号这种类型不适合用位图索引。</p>\n</li>\n<li>\n<p>此外，位图索引适合静态数据，而不适合索引频繁更新的列</p>\n</li>\n</ul>\n<h5 id=\"散列索引\"><a class=\"markdownIt-Anchor\" href=\"#散列索引\"></a> 散列索引</h5>\n<p>散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。</p>\n<p>散列索引根据对应键的散列码来找到最终的索引项的技术，其实和B树就差不多，也就是一种索引之上的二级辅助索引，我理解散列索引都是二级或更高级的稀疏索引，否则桶就太多了，效率也不会很高</p>\n<h5 id=\"聚簇索引\"><a class=\"markdownIt-Anchor\" href=\"#聚簇索引\"></a> 聚簇索引</h5>\n<p>所谓聚簇索引，就是指<strong>主索引文件</strong>和<strong>数据文件</strong>为<mark>同一份文件</mark>，聚簇索引主要用在<strong>Innodb</strong>存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，如下图所示：</p>\n<p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>\n<h5 id=\"非聚簇索引\"><a class=\"markdownIt-Anchor\" href=\"#非聚簇索引\"></a> 非聚簇索引</h5>\n<p>聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接<strong>指向对应数据块</strong>。</p>\n<h5 id=\"辅助索引\"><a class=\"markdownIt-Anchor\" href=\"#辅助索引\"></a> 辅助索引</h5>\n<p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要<strong>二次查找</strong>。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据叶，再通过数据叶中的Page Directory找到数据行</p>\n<h5 id=\"唯一索引\"><a class=\"markdownIt-Anchor\" href=\"#唯一索引\"></a> 唯一索引</h5>\n<p>表明此索引的<mark>每一个索引值只对应唯一的数据记录</mark>，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复</p>\n<h5 id=\"主键索引\"><a class=\"markdownIt-Anchor\" href=\"#主键索引\"></a> 主键索引</h5>\n<p>在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问</p>\n<hr />\n<p>数据库引擎 ：myISAM , innodb</p>\n<p>myisam索引：因为myisam的索引和数据是分开存储存储的，myisam通过<strong>key_buffer</strong>把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p>\n<p>innodb索引：innodb的数据和索引放在一起，当找到索引也就找到了数据</p>\n<img src=\"https://img-blog.csdn.net/20161102111454921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\" style=\"zoom:75%;\" />\n<p>1.对于<strong>非聚簇索引表</strong>来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。</p>\n<p>2.对于<strong>聚簇索引表</strong>来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)</p>\n<blockquote>\n<h5 id=\"聚簇索引的优点\"><a class=\"markdownIt-Anchor\" href=\"#聚簇索引的优点\"></a> 聚簇索引的优点</h5>\n<p>1.当你需要取出<mark>一定范围内</mark>的数据时，用聚簇索引也比用非聚簇索引好。</p>\n<p>2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。</p>\n<p>3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p>\n<h5 id=\"聚簇索引的缺点\"><a class=\"markdownIt-Anchor\" href=\"#聚簇索引的缺点\"></a> 聚簇索引的缺点</h5>\n<p>1.<strong>插入速度严重依赖于插入顺序</strong>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</p>\n<p>2.<strong>更新主键的代价很高，因为将会导致被更新的行移动</strong>。因此，对于InnoDB表，我们一般定义主键为不可更新。</p>\n<p>3.<strong>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</strong></p>\n<p>二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</p>\n<p>4.<strong>采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多</strong>，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"索引\"><a class=\"markdownIt-Anchor\" href=\"#索引\"></a> 索引</h2>\n<h4 id=\"页存储\"><a class=\"markdownIt-Anchor\" href=\"#页存储\"></a> 页存储</h4>\n<img src=\"https://i.loli.net/2019/12/05/dQE6NVkHZJcWfye.png\" style=\"zoom:50%;\" />\n<p>如上就是数据库在Disk Storage的一个存储方式。一个页包含若干 <em>Data Rows</em> , 通过 <em>Row directory</em> 来进行索引</p>\n<blockquote>\n<p>A row in a table can be uniquely specified with the page number § and slot number (S).</p>\n</blockquote>\n<h5 id=\"位图索引\"><a class=\"markdownIt-Anchor\" href=\"#位图索引\"></a> 位图索引</h5>\n<p><a href=\"https://www.cnblogs.com/LBSer/p/3322630.html\">https://www.cnblogs.com/LBSer/p/3322630.html</a></p>\n<p>位图索引中只维护distinct值，也就是说重复的值是不维护在树中</p>\n<p>对于每一个列建立一个</p>\n<ul>\n<li>\n<p>位图索引适合只有几个固定值的列，如性别、婚姻状况、行政区等等，而身份证号这种类型不适合用位图索引。</p>\n</li>\n<li>\n<p>此外，位图索引适合静态数据，而不适合索引频繁更新的列</p>\n</li>\n</ul>\n<h5 id=\"散列索引\"><a class=\"markdownIt-Anchor\" href=\"#散列索引\"></a> 散列索引</h5>\n<p>散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。</p>\n<p>散列索引根据对应键的散列码来找到最终的索引项的技术，其实和B树就差不多，也就是一种索引之上的二级辅助索引，我理解散列索引都是二级或更高级的稀疏索引，否则桶就太多了，效率也不会很高</p>\n<h5 id=\"聚簇索引\"><a class=\"markdownIt-Anchor\" href=\"#聚簇索引\"></a> 聚簇索引</h5>\n<p>所谓聚簇索引，就是指<strong>主索引文件</strong>和<strong>数据文件</strong>为<mark>同一份文件</mark>，聚簇索引主要用在<strong>Innodb</strong>存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，如下图所示：</p>\n<p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>\n<h5 id=\"非聚簇索引\"><a class=\"markdownIt-Anchor\" href=\"#非聚簇索引\"></a> 非聚簇索引</h5>\n<p>聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接<strong>指向对应数据块</strong>。</p>\n<h5 id=\"辅助索引\"><a class=\"markdownIt-Anchor\" href=\"#辅助索引\"></a> 辅助索引</h5>\n<p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要<strong>二次查找</strong>。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据叶，再通过数据叶中的Page Directory找到数据行</p>\n<h5 id=\"唯一索引\"><a class=\"markdownIt-Anchor\" href=\"#唯一索引\"></a> 唯一索引</h5>\n<p>表明此索引的<mark>每一个索引值只对应唯一的数据记录</mark>，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复</p>\n<h5 id=\"主键索引\"><a class=\"markdownIt-Anchor\" href=\"#主键索引\"></a> 主键索引</h5>\n<p>在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问</p>\n<hr />\n<p>数据库引擎 ：myISAM , innodb</p>\n<p>myisam索引：因为myisam的索引和数据是分开存储存储的，myisam通过<strong>key_buffer</strong>把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p>\n<p>innodb索引：innodb的数据和索引放在一起，当找到索引也就找到了数据</p>\n<img src=\"https://img-blog.csdn.net/20161102111454921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\" style=\"zoom:75%;\" />\n<p>1.对于<strong>非聚簇索引表</strong>来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。</p>\n<p>2.对于<strong>聚簇索引表</strong>来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)</p>\n<blockquote>\n<h5 id=\"聚簇索引的优点\"><a class=\"markdownIt-Anchor\" href=\"#聚簇索引的优点\"></a> 聚簇索引的优点</h5>\n<p>1.当你需要取出<mark>一定范围内</mark>的数据时，用聚簇索引也比用非聚簇索引好。</p>\n<p>2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。</p>\n<p>3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p>\n<h5 id=\"聚簇索引的缺点\"><a class=\"markdownIt-Anchor\" href=\"#聚簇索引的缺点\"></a> 聚簇索引的缺点</h5>\n<p>1.<strong>插入速度严重依赖于插入顺序</strong>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</p>\n<p>2.<strong>更新主键的代价很高，因为将会导致被更新的行移动</strong>。因此，对于InnoDB表，我们一般定义主键为不可更新。</p>\n<p>3.<strong>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</strong></p>\n<p>二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</p>\n<p>4.<strong>采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多</strong>，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</p>\n</blockquote>\n"},{"title":"杂谈-沉思帖","date":"2019-12-22T15:35:20.000Z","description":"总结2019经历","cover_img":"https://images.unsplash.com/photo-1526285592708-e83cf5365929?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80","cover":"https://images.unsplash.com/photo-1526285592708-e83cf5365929?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80","feature_img":"https://images.unsplash.com/photo-1495539406979-bf61750d38ad?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80","_content":"\n> 多尝试新的方向，不浮躁地随波逐流；\n>\n> 有一个自己喜爱的方向是如此地难能可贵\n\n## 杂谈-沉思帖\n\n2019 秋季这个课表算是无法无天了，虽然在春季就做了一些心理预设，但是当它到来的时候，特别是到了现在考试周将近，还是压得人喘不过气。\n\n前一段时间一直在各处投递简历。在打消了出国打算、ML的打算之后，我从暑期就开始对自己的方向进行了思考，留给我试错的时间已经不多了，在后续的一年半时间中，我是需要针对一桩事业真正投入地进行付出，并且能够有一定的产出的。在我各处找着实习的时候，字节一面后十分钟的拒信给了我巨大的打击——\n\n> 基础不牢，地动山摇\n\n面试官丢给我的几乎每一个计网问题我都招架不来，可以说上个学期学的内容全数奉还给了老师。内心千万个声音在警戒着我：你的基础根本不牢固，做了种种项目又有什么用？\n\n图森的面试官告诉我，如果这些基本的网络知识不过关，如何能够在出错的时候进行精准的错误排查？特别是在客户流量比较大的情况下，网络阻塞、丢包这些错误屡见不鲜，如何可以最大限度地减少经济损失？\n\n> 网络协议中每一层的网络攻击可以有哪些？\n\n这个问题我可能一辈子也不忘了，图森的二面官这么一个问题丢过来，我当时的反应就是：一个也没有。\n\n后续的结果也显而易见，又是一封拒信。虽然 `coding` 过关，但是基础过于不扎实而不会要我。\n\n所以，基础 基础 基础！！！\n\n什么叫做基础呢？\n\n其实这些问题，老师课上也没有系统性的说过。我丢失了大一的时候看书的习惯，大二只是对课堂内的东西进行机械接受。最讽刺的就是，当字节面试官问“你觉得计网是一门怎么样的课”的时候，我第一反应回答就是“一门背书的课”。我现在回顾过来，真想好好打当时的自己一个巴掌。不过事实的确如此，我在大二下就是背书来学计网的，当时的我根本没有心思听老师讲课，只想着多做一些项目美滋滋。\n\n现在就到了要亡羊补牢的时候了，11月上旬的样子吧，我开始恶补我之前的 `JVM`, 计网，多线程，`linux` 内核相关的知识。加上后续几个面试的逼迫，我可以说拼了老命在学 (这么紧的课程还要面试，真的会折磨我自己)\n\n`12.21` ，*TX* 的面试官突然打来电话，约了一面。可以说这次是我把握比较好的一次面试了。说着，人的确就是一个犯贱的种，需要一些外力压迫来威胁自己去学习。还有一个很重要的点就是，我真的过于浮躁了，急于求成想去学 *ML* 但是发现真实资源如此贫乏(一整个院搞什么ML? 我们又不是人工智能学院！) 没有一个前辈带领的路走得真心艰苦，没有方向，没有可以去追随的人，于是放弃。现在是时候好好静下心去听听自己了。\n\n> 冬至已至。\n>\n> 希望新的一年，能够笃定，坚毅。","source":"_posts/杂谈-鸡血帖.md","raw":"---\ntitle: 杂谈-沉思帖\ndate: 2019-12-22 23:35:20\ntags: \n  - UpUp\ncategories: \n  - 杂谈\ndescription: 总结2019经历\ncover_img: https://images.unsplash.com/photo-1526285592708-e83cf5365929?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80\ncover: https://images.unsplash.com/photo-1526285592708-e83cf5365929?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80\nfeature_img: https://images.unsplash.com/photo-1495539406979-bf61750d38ad?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80\n---\n\n> 多尝试新的方向，不浮躁地随波逐流；\n>\n> 有一个自己喜爱的方向是如此地难能可贵\n\n## 杂谈-沉思帖\n\n2019 秋季这个课表算是无法无天了，虽然在春季就做了一些心理预设，但是当它到来的时候，特别是到了现在考试周将近，还是压得人喘不过气。\n\n前一段时间一直在各处投递简历。在打消了出国打算、ML的打算之后，我从暑期就开始对自己的方向进行了思考，留给我试错的时间已经不多了，在后续的一年半时间中，我是需要针对一桩事业真正投入地进行付出，并且能够有一定的产出的。在我各处找着实习的时候，字节一面后十分钟的拒信给了我巨大的打击——\n\n> 基础不牢，地动山摇\n\n面试官丢给我的几乎每一个计网问题我都招架不来，可以说上个学期学的内容全数奉还给了老师。内心千万个声音在警戒着我：你的基础根本不牢固，做了种种项目又有什么用？\n\n图森的面试官告诉我，如果这些基本的网络知识不过关，如何能够在出错的时候进行精准的错误排查？特别是在客户流量比较大的情况下，网络阻塞、丢包这些错误屡见不鲜，如何可以最大限度地减少经济损失？\n\n> 网络协议中每一层的网络攻击可以有哪些？\n\n这个问题我可能一辈子也不忘了，图森的二面官这么一个问题丢过来，我当时的反应就是：一个也没有。\n\n后续的结果也显而易见，又是一封拒信。虽然 `coding` 过关，但是基础过于不扎实而不会要我。\n\n所以，基础 基础 基础！！！\n\n什么叫做基础呢？\n\n其实这些问题，老师课上也没有系统性的说过。我丢失了大一的时候看书的习惯，大二只是对课堂内的东西进行机械接受。最讽刺的就是，当字节面试官问“你觉得计网是一门怎么样的课”的时候，我第一反应回答就是“一门背书的课”。我现在回顾过来，真想好好打当时的自己一个巴掌。不过事实的确如此，我在大二下就是背书来学计网的，当时的我根本没有心思听老师讲课，只想着多做一些项目美滋滋。\n\n现在就到了要亡羊补牢的时候了，11月上旬的样子吧，我开始恶补我之前的 `JVM`, 计网，多线程，`linux` 内核相关的知识。加上后续几个面试的逼迫，我可以说拼了老命在学 (这么紧的课程还要面试，真的会折磨我自己)\n\n`12.21` ，*TX* 的面试官突然打来电话，约了一面。可以说这次是我把握比较好的一次面试了。说着，人的确就是一个犯贱的种，需要一些外力压迫来威胁自己去学习。还有一个很重要的点就是，我真的过于浮躁了，急于求成想去学 *ML* 但是发现真实资源如此贫乏(一整个院搞什么ML? 我们又不是人工智能学院！) 没有一个前辈带领的路走得真心艰苦，没有方向，没有可以去追随的人，于是放弃。现在是时候好好静下心去听听自己了。\n\n> 冬至已至。\n>\n> 希望新的一年，能够笃定，坚毅。","slug":"杂谈-鸡血帖","published":1,"updated":"2020-10-22T02:12:58.119Z","_id":"ckgk7k80n000q06me3860ffam","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>多尝试新的方向，不浮躁地随波逐流；</p>\n<p>有一个自己喜爱的方向是如此地难能可贵</p>\n</blockquote>\n<h2 id=\"杂谈-沉思帖\"><a class=\"markdownIt-Anchor\" href=\"#杂谈-沉思帖\"></a> 杂谈-沉思帖</h2>\n<p>2019 秋季这个课表算是无法无天了，虽然在春季就做了一些心理预设，但是当它到来的时候，特别是到了现在考试周将近，还是压得人喘不过气。</p>\n<p>前一段时间一直在各处投递简历。在打消了出国打算、ML的打算之后，我从暑期就开始对自己的方向进行了思考，留给我试错的时间已经不多了，在后续的一年半时间中，我是需要针对一桩事业真正投入地进行付出，并且能够有一定的产出的。在我各处找着实习的时候，字节一面后十分钟的拒信给了我巨大的打击——</p>\n<blockquote>\n<p>基础不牢，地动山摇</p>\n</blockquote>\n<p>面试官丢给我的几乎每一个计网问题我都招架不来，可以说上个学期学的内容全数奉还给了老师。内心千万个声音在警戒着我：你的基础根本不牢固，做了种种项目又有什么用？</p>\n<p>图森的面试官告诉我，如果这些基本的网络知识不过关，如何能够在出错的时候进行精准的错误排查？特别是在客户流量比较大的情况下，网络阻塞、丢包这些错误屡见不鲜，如何可以最大限度地减少经济损失？</p>\n<blockquote>\n<p>网络协议中每一层的网络攻击可以有哪些？</p>\n</blockquote>\n<p>这个问题我可能一辈子也不忘了，图森的二面官这么一个问题丢过来，我当时的反应就是：一个也没有。</p>\n<p>后续的结果也显而易见，又是一封拒信。虽然 <code>coding</code> 过关，但是基础过于不扎实而不会要我。</p>\n<p>所以，基础 基础 基础！！！</p>\n<p>什么叫做基础呢？</p>\n<p>其实这些问题，老师课上也没有系统性的说过。我丢失了大一的时候看书的习惯，大二只是对课堂内的东西进行机械接受。最讽刺的就是，当字节面试官问“你觉得计网是一门怎么样的课”的时候，我第一反应回答就是“一门背书的课”。我现在回顾过来，真想好好打当时的自己一个巴掌。不过事实的确如此，我在大二下就是背书来学计网的，当时的我根本没有心思听老师讲课，只想着多做一些项目美滋滋。</p>\n<p>现在就到了要亡羊补牢的时候了，11月上旬的样子吧，我开始恶补我之前的 <code>JVM</code>, 计网，多线程，<code>linux</code> 内核相关的知识。加上后续几个面试的逼迫，我可以说拼了老命在学 (这么紧的课程还要面试，真的会折磨我自己)</p>\n<p><code>12.21</code> ，<em>TX</em> 的面试官突然打来电话，约了一面。可以说这次是我把握比较好的一次面试了。说着，人的确就是一个犯贱的种，需要一些外力压迫来威胁自己去学习。还有一个很重要的点就是，我真的过于浮躁了，急于求成想去学 <em>ML</em> 但是发现真实资源如此贫乏(一整个院搞什么ML? 我们又不是人工智能学院！) 没有一个前辈带领的路走得真心艰苦，没有方向，没有可以去追随的人，于是放弃。现在是时候好好静下心去听听自己了。</p>\n<blockquote>\n<p>冬至已至。</p>\n<p>希望新的一年，能够笃定，坚毅。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>多尝试新的方向，不浮躁地随波逐流；</p>\n<p>有一个自己喜爱的方向是如此地难能可贵</p>\n</blockquote>\n<h2 id=\"杂谈-沉思帖\"><a class=\"markdownIt-Anchor\" href=\"#杂谈-沉思帖\"></a> 杂谈-沉思帖</h2>\n<p>2019 秋季这个课表算是无法无天了，虽然在春季就做了一些心理预设，但是当它到来的时候，特别是到了现在考试周将近，还是压得人喘不过气。</p>\n<p>前一段时间一直在各处投递简历。在打消了出国打算、ML的打算之后，我从暑期就开始对自己的方向进行了思考，留给我试错的时间已经不多了，在后续的一年半时间中，我是需要针对一桩事业真正投入地进行付出，并且能够有一定的产出的。在我各处找着实习的时候，字节一面后十分钟的拒信给了我巨大的打击——</p>\n<blockquote>\n<p>基础不牢，地动山摇</p>\n</blockquote>\n<p>面试官丢给我的几乎每一个计网问题我都招架不来，可以说上个学期学的内容全数奉还给了老师。内心千万个声音在警戒着我：你的基础根本不牢固，做了种种项目又有什么用？</p>\n<p>图森的面试官告诉我，如果这些基本的网络知识不过关，如何能够在出错的时候进行精准的错误排查？特别是在客户流量比较大的情况下，网络阻塞、丢包这些错误屡见不鲜，如何可以最大限度地减少经济损失？</p>\n<blockquote>\n<p>网络协议中每一层的网络攻击可以有哪些？</p>\n</blockquote>\n<p>这个问题我可能一辈子也不忘了，图森的二面官这么一个问题丢过来，我当时的反应就是：一个也没有。</p>\n<p>后续的结果也显而易见，又是一封拒信。虽然 <code>coding</code> 过关，但是基础过于不扎实而不会要我。</p>\n<p>所以，基础 基础 基础！！！</p>\n<p>什么叫做基础呢？</p>\n<p>其实这些问题，老师课上也没有系统性的说过。我丢失了大一的时候看书的习惯，大二只是对课堂内的东西进行机械接受。最讽刺的就是，当字节面试官问“你觉得计网是一门怎么样的课”的时候，我第一反应回答就是“一门背书的课”。我现在回顾过来，真想好好打当时的自己一个巴掌。不过事实的确如此，我在大二下就是背书来学计网的，当时的我根本没有心思听老师讲课，只想着多做一些项目美滋滋。</p>\n<p>现在就到了要亡羊补牢的时候了，11月上旬的样子吧，我开始恶补我之前的 <code>JVM</code>, 计网，多线程，<code>linux</code> 内核相关的知识。加上后续几个面试的逼迫，我可以说拼了老命在学 (这么紧的课程还要面试，真的会折磨我自己)</p>\n<p><code>12.21</code> ，<em>TX</em> 的面试官突然打来电话，约了一面。可以说这次是我把握比较好的一次面试了。说着，人的确就是一个犯贱的种，需要一些外力压迫来威胁自己去学习。还有一个很重要的点就是，我真的过于浮躁了，急于求成想去学 <em>ML</em> 但是发现真实资源如此贫乏(一整个院搞什么ML? 我们又不是人工智能学院！) 没有一个前辈带领的路走得真心艰苦，没有方向，没有可以去追随的人，于是放弃。现在是时候好好静下心去听听自己了。</p>\n<blockquote>\n<p>冬至已至。</p>\n<p>希望新的一年，能够笃定，坚毅。</p>\n</blockquote>\n"},{"title":"聊一聊一致性的话题","date":"2020-04-09T13:02:05.000Z","cover_img":"https://images.unsplash.com/photo-1559251434-4e172832c9de?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=700&q=80","cover":"https://images.unsplash.com/photo-1559251434-4e172832c9de?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=700&q=80","feature_img":"https://images.unsplash.com/photo-1571606809798-027ae70d593f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80","description":null,"keywords":null,"_content":"\n## 主从复制\n\n在分布式的 *CAP* 理论中，一致和可用我们往往都只能够偏向于其中的一者。这一点这里只是简单提一下。例如我们的 `zk`满足的就是 *CP*\n\n![image.png](https://i.loli.net/2020/12/20/AlHwGEiLrFCS4VY.png)\n\n今天主要谈一谈数据库当中的一个 **一致性** 话题\n\n### Mysql 主从复制\n\n> 在分布式的数据库系统中，如果主数据库发生了故障，那么需要能够及时切换到从数据库，并且进行数据的恢复工作。如何保证主从数据库之间的数据一致性也就成为了焦点问题。这次把目光聚焦在 `Mysql` 上，探究它的主从复制原理\n>\n> 对于这些数据库而言，严格的一致性是一个目标\n\n![image.png](https://i.loli.net/2020/04/09/e7iz9aotfqmlGHM.png)\n\n- 主节点 `Master` 进行数据更新之后，会将更新日志写入 `binlog` 当中。此时创建的是第一个线程 `binlong dump thread`\n- 随后从节点 `Slave`发起连接，连接到 `Master` ，从节点启东之后，启动线程 `IO thread` ，用于将 `binlog ` 内容写入到从节点的 `relay log` \n- 从节点随后创建 `SQL thread` ，用于从 `relay log` 中读取内容，并且开始进行写入操作\n\n### Redis 主从复制\n\n> 其主要的目的和 `Mysql` 一致，都是为了避免主节点失效之后的数据备份\n\n#### 完整复制过程\n\n- 启动 `Slave` ，建立和主节点 `Master` 的连接，发送 `sync` 命令\n- `Master` 启动一个后台进程，将当前的快照存储到 `RDB`当中\n  - 写入 `RDB` 的同时，可能会有数据的不一致性。这时候 `Master` 主进程会把写命令缓存\n- `Master` 发送 `RDB` 给 `Slave` ，随后 `Slave` 进行磁盘保存\n- `Slave` 加载 `RDB` 文件到内存恢复；\n- `Master` 发送缓存给 `Slave`\n\n> 存在的问题：\n>\n> 如果 `Slave` 停止运行，再次运行的时候可能部分的数据不同步；这时候的全数据恢复会非常耗时\n\n#### 部分复制过程 \n\n- `Slave` 连接 `Master` 之后，会主动发起 `PSYNC` 命令，`Slave` 提供 `runid` , `offset` 。如果 `Master` 认定无效，那么进行完整复制；否则根据  `offset` 进行部分数据的同步","source":"_posts/聊一聊一致性话题.md","raw":"---\ntitle: 聊一聊一致性的话题\ndate: 2020-04-09 21:02:05\ntags:\ncover_img: https://images.unsplash.com/photo-1559251434-4e172832c9de?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=700&q=80\ncover: https://images.unsplash.com/photo-1559251434-4e172832c9de?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=700&q=80\nfeature_img: https://images.unsplash.com/photo-1571606809798-027ae70d593f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80\ndescription:\nkeywords:\n---\n\n## 主从复制\n\n在分布式的 *CAP* 理论中，一致和可用我们往往都只能够偏向于其中的一者。这一点这里只是简单提一下。例如我们的 `zk`满足的就是 *CP*\n\n![image.png](https://i.loli.net/2020/12/20/AlHwGEiLrFCS4VY.png)\n\n今天主要谈一谈数据库当中的一个 **一致性** 话题\n\n### Mysql 主从复制\n\n> 在分布式的数据库系统中，如果主数据库发生了故障，那么需要能够及时切换到从数据库，并且进行数据的恢复工作。如何保证主从数据库之间的数据一致性也就成为了焦点问题。这次把目光聚焦在 `Mysql` 上，探究它的主从复制原理\n>\n> 对于这些数据库而言，严格的一致性是一个目标\n\n![image.png](https://i.loli.net/2020/04/09/e7iz9aotfqmlGHM.png)\n\n- 主节点 `Master` 进行数据更新之后，会将更新日志写入 `binlog` 当中。此时创建的是第一个线程 `binlong dump thread`\n- 随后从节点 `Slave`发起连接，连接到 `Master` ，从节点启东之后，启动线程 `IO thread` ，用于将 `binlog ` 内容写入到从节点的 `relay log` \n- 从节点随后创建 `SQL thread` ，用于从 `relay log` 中读取内容，并且开始进行写入操作\n\n### Redis 主从复制\n\n> 其主要的目的和 `Mysql` 一致，都是为了避免主节点失效之后的数据备份\n\n#### 完整复制过程\n\n- 启动 `Slave` ，建立和主节点 `Master` 的连接，发送 `sync` 命令\n- `Master` 启动一个后台进程，将当前的快照存储到 `RDB`当中\n  - 写入 `RDB` 的同时，可能会有数据的不一致性。这时候 `Master` 主进程会把写命令缓存\n- `Master` 发送 `RDB` 给 `Slave` ，随后 `Slave` 进行磁盘保存\n- `Slave` 加载 `RDB` 文件到内存恢复；\n- `Master` 发送缓存给 `Slave`\n\n> 存在的问题：\n>\n> 如果 `Slave` 停止运行，再次运行的时候可能部分的数据不同步；这时候的全数据恢复会非常耗时\n\n#### 部分复制过程 \n\n- `Slave` 连接 `Master` 之后，会主动发起 `PSYNC` 命令，`Slave` 提供 `runid` , `offset` 。如果 `Master` 认定无效，那么进行完整复制；否则根据  `offset` 进行部分数据的同步","slug":"聊一聊一致性话题","published":1,"updated":"2020-12-20T07:50:15.982Z","_id":"ckgk7k80p000v06me11kj4xbf","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"主从复制\"><a class=\"markdownIt-Anchor\" href=\"#主从复制\"></a> 主从复制</h2>\n<p>在分布式的 <em>CAP</em> 理论中，一致和可用我们往往都只能够偏向于其中的一者。这一点这里只是简单提一下。例如我们的 <code>zk</code>满足的就是 <em>CP</em></p>\n<p><img src=\"https://i.loli.net/2020/12/20/AlHwGEiLrFCS4VY.png\" alt=\"image.png\" /></p>\n<p>今天主要谈一谈数据库当中的一个 <strong>一致性</strong> 话题</p>\n<h3 id=\"mysql-主从复制\"><a class=\"markdownIt-Anchor\" href=\"#mysql-主从复制\"></a> Mysql 主从复制</h3>\n<blockquote>\n<p>在分布式的数据库系统中，如果主数据库发生了故障，那么需要能够及时切换到从数据库，并且进行数据的恢复工作。如何保证主从数据库之间的数据一致性也就成为了焦点问题。这次把目光聚焦在 <code>Mysql</code> 上，探究它的主从复制原理</p>\n<p>对于这些数据库而言，严格的一致性是一个目标</p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2020/04/09/e7iz9aotfqmlGHM.png\" alt=\"image.png\" /></p>\n<ul>\n<li>主节点 <code>Master</code> 进行数据更新之后，会将更新日志写入 <code>binlog</code> 当中。此时创建的是第一个线程 <code>binlong dump thread</code></li>\n<li>随后从节点 <code>Slave</code>发起连接，连接到 <code>Master</code> ，从节点启东之后，启动线程 <code>IO thread</code> ，用于将 <code>binlog</code> 内容写入到从节点的 <code>relay log</code></li>\n<li>从节点随后创建 <code>SQL thread</code> ，用于从 <code>relay log</code> 中读取内容，并且开始进行写入操作</li>\n</ul>\n<h3 id=\"redis-主从复制\"><a class=\"markdownIt-Anchor\" href=\"#redis-主从复制\"></a> Redis 主从复制</h3>\n<blockquote>\n<p>其主要的目的和 <code>Mysql</code> 一致，都是为了避免主节点失效之后的数据备份</p>\n</blockquote>\n<h4 id=\"完整复制过程\"><a class=\"markdownIt-Anchor\" href=\"#完整复制过程\"></a> 完整复制过程</h4>\n<ul>\n<li>启动 <code>Slave</code> ，建立和主节点 <code>Master</code> 的连接，发送 <code>sync</code> 命令</li>\n<li><code>Master</code> 启动一个后台进程，将当前的快照存储到 <code>RDB</code>当中\n<ul>\n<li>写入 <code>RDB</code> 的同时，可能会有数据的不一致性。这时候 <code>Master</code> 主进程会把写命令缓存</li>\n</ul>\n</li>\n<li><code>Master</code> 发送 <code>RDB</code> 给 <code>Slave</code> ，随后 <code>Slave</code> 进行磁盘保存</li>\n<li><code>Slave</code> 加载 <code>RDB</code> 文件到内存恢复；</li>\n<li><code>Master</code> 发送缓存给 <code>Slave</code></li>\n</ul>\n<blockquote>\n<p>存在的问题：</p>\n<p>如果 <code>Slave</code> 停止运行，再次运行的时候可能部分的数据不同步；这时候的全数据恢复会非常耗时</p>\n</blockquote>\n<h4 id=\"部分复制过程\"><a class=\"markdownIt-Anchor\" href=\"#部分复制过程\"></a> 部分复制过程</h4>\n<ul>\n<li><code>Slave</code> 连接 <code>Master</code> 之后，会主动发起 <code>PSYNC</code> 命令，<code>Slave</code> 提供 <code>runid</code> , <code>offset</code> 。如果 <code>Master</code> 认定无效，那么进行完整复制；否则根据  <code>offset</code> 进行部分数据的同步</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"主从复制\"><a class=\"markdownIt-Anchor\" href=\"#主从复制\"></a> 主从复制</h2>\n<p>在分布式的 <em>CAP</em> 理论中，一致和可用我们往往都只能够偏向于其中的一者。这一点这里只是简单提一下。例如我们的 <code>zk</code>满足的就是 <em>CP</em></p>\n<p><img src=\"https://i.loli.net/2020/12/20/AlHwGEiLrFCS4VY.png\" alt=\"image.png\" /></p>\n<p>今天主要谈一谈数据库当中的一个 <strong>一致性</strong> 话题</p>\n<h3 id=\"mysql-主从复制\"><a class=\"markdownIt-Anchor\" href=\"#mysql-主从复制\"></a> Mysql 主从复制</h3>\n<blockquote>\n<p>在分布式的数据库系统中，如果主数据库发生了故障，那么需要能够及时切换到从数据库，并且进行数据的恢复工作。如何保证主从数据库之间的数据一致性也就成为了焦点问题。这次把目光聚焦在 <code>Mysql</code> 上，探究它的主从复制原理</p>\n<p>对于这些数据库而言，严格的一致性是一个目标</p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2020/04/09/e7iz9aotfqmlGHM.png\" alt=\"image.png\" /></p>\n<ul>\n<li>主节点 <code>Master</code> 进行数据更新之后，会将更新日志写入 <code>binlog</code> 当中。此时创建的是第一个线程 <code>binlong dump thread</code></li>\n<li>随后从节点 <code>Slave</code>发起连接，连接到 <code>Master</code> ，从节点启东之后，启动线程 <code>IO thread</code> ，用于将 <code>binlog</code> 内容写入到从节点的 <code>relay log</code></li>\n<li>从节点随后创建 <code>SQL thread</code> ，用于从 <code>relay log</code> 中读取内容，并且开始进行写入操作</li>\n</ul>\n<h3 id=\"redis-主从复制\"><a class=\"markdownIt-Anchor\" href=\"#redis-主从复制\"></a> Redis 主从复制</h3>\n<blockquote>\n<p>其主要的目的和 <code>Mysql</code> 一致，都是为了避免主节点失效之后的数据备份</p>\n</blockquote>\n<h4 id=\"完整复制过程\"><a class=\"markdownIt-Anchor\" href=\"#完整复制过程\"></a> 完整复制过程</h4>\n<ul>\n<li>启动 <code>Slave</code> ，建立和主节点 <code>Master</code> 的连接，发送 <code>sync</code> 命令</li>\n<li><code>Master</code> 启动一个后台进程，将当前的快照存储到 <code>RDB</code>当中\n<ul>\n<li>写入 <code>RDB</code> 的同时，可能会有数据的不一致性。这时候 <code>Master</code> 主进程会把写命令缓存</li>\n</ul>\n</li>\n<li><code>Master</code> 发送 <code>RDB</code> 给 <code>Slave</code> ，随后 <code>Slave</code> 进行磁盘保存</li>\n<li><code>Slave</code> 加载 <code>RDB</code> 文件到内存恢复；</li>\n<li><code>Master</code> 发送缓存给 <code>Slave</code></li>\n</ul>\n<blockquote>\n<p>存在的问题：</p>\n<p>如果 <code>Slave</code> 停止运行，再次运行的时候可能部分的数据不同步；这时候的全数据恢复会非常耗时</p>\n</blockquote>\n<h4 id=\"部分复制过程\"><a class=\"markdownIt-Anchor\" href=\"#部分复制过程\"></a> 部分复制过程</h4>\n<ul>\n<li><code>Slave</code> 连接 <code>Master</code> 之后，会主动发起 <code>PSYNC</code> 命令，<code>Slave</code> 提供 <code>runid</code> , <code>offset</code> 。如果 <code>Master</code> 认定无效，那么进行完整复制；否则根据  <code>offset</code> 进行部分数据的同步</li>\n</ul>\n"},{"title":"背包问题","date":"2020-01-15T09:13:36.000Z","description":"关注背包九讲中的内容, 重点考察DP的思考想法","cover_img":"https://images.unsplash.com/photo-1581463455583-40abcfc90be7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1234&q=80","cover":"https://images.unsplash.com/photo-1581463455583-40abcfc90be7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1234&q=80","feature_img":"https://images.unsplash.com/photo-1581463455583-40abcfc90be7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1234&q=80","_content":"\n### 1. 01背包问题\n\n有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。\n\n分析：\n\n- 每一个背包只有 **拿出 or 不拿出** 两种情况\n- 对于 **dp** 数组，我们某一个状态 `dp[i][j]` 表示 **前i种背包的情况下，他们的总重量是 j 的最优解**\n  - 如果 **i** 背包不拿，那么 `dp[i][j] = dp[i - 1][j]`\n  - 如果 **i** 背包拿取，那么 `dp[i][j] = dp[i - 1][j - weights[i]] + values[i]`\n    - 也就是说，拿取之后，需要看剩下的部分最优解\n\n#### 算法优化\n\n根据之前的状态转移方程，我们可以约减一维的 **dp** 空间\n\n改进之后的 **dp** 状态转移方程如下：\n\n`dp[i] = max(dp[j], dp[j - weights[i]] + values[i])`\n\n> 为什么在内层循环，**j** 需要逆序？\n>\n> 在没有开始计算的时候，**dp[i]表示的是dp\\[i-1]\\[j]** 。而当我们需要计算 `dp[i] = max(dp[j], dp[j - weights[i]] + values[i])`的时候，需要保证 `dp[j - w[i]]` 是 **没有被改变的**。因此需要**从后往前**\n\n### 2. 完全背包问题\n\n每一件物品可以 **无限次** 拿取\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int N , V;\n    cin >> N >> V;\n    vector<int> w(N + 1) , v(N + 1);\n    for(int i = 1 ; i <= N ; ++i) cin >> w[i] >> v[i];\n    \n    vector<vector<int>> dp(N + 1 , vector<int>(V + 1 , 0));\n    \n    for(int i = 1; i <= N ; ++i){\n        for(int j = 0 ;j <= V; ++j){\n            dp[i][j] = dp[i - 1][j];\n            for(int k = 0 ; k*w[i] <= j; ++k){\n                dp[i][j] = max(dp[i][j] , dp[i][j - k * w[i]] + k * v[i]);\n            }\n        }\n    }\n    \n    cout << dp[N][V] << endl;\n    \n}\n```\n\n最重要的状态转移方程对比\n\n- **01背包** ：`dp[i][j] = max(dp[i-1][j],dp[i - 1][j - w[i]] + v[i])`\n- **完全背包** ：`dp[i][j] = max(dp[i][j] , dp[i - 1][j - k * w[i]] + k * v[i]);`\n\n不难看出，两者其实非常的类似。根据下标我们可以给出压缩之后的优化版本完全背包解法\n\n> **01背包** 和 **完全背包** 的不同\n>\n> ```cpp\n> //01背包\n> for i  in 0 ... N\n>     for  j = V ... 0\n>         f[j] = max{f[j], f[j - weight[i]] + value[i]}\n> //完全背包\n> for i int 0 ... N\n>   \tfor\t j = 0 ... V\n>       \tf[j] = max{f[j] , f[j - weight[j]] + value[i]}\n> ```\n>\n> 可以看出，只有内层循环的执行顺序不同\n\n给出 **完全背包问题** 的优化方案\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n    int n , capacity;\n    cin >> n >> capacity;\n    vector<int> c(n + 1) , w(n + 1);\n    vector<int> dp(max(n , capacity));\n    for(int i = 1 ; i <= n ;++i) cin >> c[i] >> w[i];\n    \n    for(int i = 1; i <= n ;++i)\n        for(int j = c[i] ; j <= capacity ; ++j)\n            dp[j] = max(dp[j] , dp[j - c[i]] + w[i]);\n    \n    cout << dp[capacity];\n}\n```\n\n","source":"_posts/背包问题.md","raw":"---\ntitle: 背包问题\ndate: 2020-01-15 17:13:36\ntags: 算法\ndescription: 关注背包九讲中的内容, 重点考察DP的思考想法\ncover_img: https://images.unsplash.com/photo-1581463455583-40abcfc90be7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1234&q=80\ncover: https://images.unsplash.com/photo-1581463455583-40abcfc90be7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1234&q=80\nfeature_img: https://images.unsplash.com/photo-1581463455583-40abcfc90be7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1234&q=80\n---\n\n### 1. 01背包问题\n\n有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。\n\n分析：\n\n- 每一个背包只有 **拿出 or 不拿出** 两种情况\n- 对于 **dp** 数组，我们某一个状态 `dp[i][j]` 表示 **前i种背包的情况下，他们的总重量是 j 的最优解**\n  - 如果 **i** 背包不拿，那么 `dp[i][j] = dp[i - 1][j]`\n  - 如果 **i** 背包拿取，那么 `dp[i][j] = dp[i - 1][j - weights[i]] + values[i]`\n    - 也就是说，拿取之后，需要看剩下的部分最优解\n\n#### 算法优化\n\n根据之前的状态转移方程，我们可以约减一维的 **dp** 空间\n\n改进之后的 **dp** 状态转移方程如下：\n\n`dp[i] = max(dp[j], dp[j - weights[i]] + values[i])`\n\n> 为什么在内层循环，**j** 需要逆序？\n>\n> 在没有开始计算的时候，**dp[i]表示的是dp\\[i-1]\\[j]** 。而当我们需要计算 `dp[i] = max(dp[j], dp[j - weights[i]] + values[i])`的时候，需要保证 `dp[j - w[i]]` 是 **没有被改变的**。因此需要**从后往前**\n\n### 2. 完全背包问题\n\n每一件物品可以 **无限次** 拿取\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int N , V;\n    cin >> N >> V;\n    vector<int> w(N + 1) , v(N + 1);\n    for(int i = 1 ; i <= N ; ++i) cin >> w[i] >> v[i];\n    \n    vector<vector<int>> dp(N + 1 , vector<int>(V + 1 , 0));\n    \n    for(int i = 1; i <= N ; ++i){\n        for(int j = 0 ;j <= V; ++j){\n            dp[i][j] = dp[i - 1][j];\n            for(int k = 0 ; k*w[i] <= j; ++k){\n                dp[i][j] = max(dp[i][j] , dp[i][j - k * w[i]] + k * v[i]);\n            }\n        }\n    }\n    \n    cout << dp[N][V] << endl;\n    \n}\n```\n\n最重要的状态转移方程对比\n\n- **01背包** ：`dp[i][j] = max(dp[i-1][j],dp[i - 1][j - w[i]] + v[i])`\n- **完全背包** ：`dp[i][j] = max(dp[i][j] , dp[i - 1][j - k * w[i]] + k * v[i]);`\n\n不难看出，两者其实非常的类似。根据下标我们可以给出压缩之后的优化版本完全背包解法\n\n> **01背包** 和 **完全背包** 的不同\n>\n> ```cpp\n> //01背包\n> for i  in 0 ... N\n>     for  j = V ... 0\n>         f[j] = max{f[j], f[j - weight[i]] + value[i]}\n> //完全背包\n> for i int 0 ... N\n>   \tfor\t j = 0 ... V\n>       \tf[j] = max{f[j] , f[j - weight[j]] + value[i]}\n> ```\n>\n> 可以看出，只有内层循环的执行顺序不同\n\n给出 **完全背包问题** 的优化方案\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n    int n , capacity;\n    cin >> n >> capacity;\n    vector<int> c(n + 1) , w(n + 1);\n    vector<int> dp(max(n , capacity));\n    for(int i = 1 ; i <= n ;++i) cin >> c[i] >> w[i];\n    \n    for(int i = 1; i <= n ;++i)\n        for(int j = c[i] ; j <= capacity ; ++j)\n            dp[j] = max(dp[j] , dp[j - c[i]] + w[i]);\n    \n    cout << dp[capacity];\n}\n```\n\n","slug":"背包问题","published":1,"updated":"2020-10-22T02:12:58.119Z","_id":"ckgk7k80q000x06me0njl69y3","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-01背包问题\"><a class=\"markdownIt-Anchor\" href=\"#1-01背包问题\"></a> 1. 01背包问题</h3>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 件物品和一个容量是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 的背包。每件物品只能使用一次。</p>\n<p>分析：</p>\n<ul>\n<li>每一个背包只有 <strong>拿出 or 不拿出</strong> 两种情况</li>\n<li>对于 <strong>dp</strong> 数组，我们某一个状态 <code>dp[i][j]</code> 表示 <strong>前i种背包的情况下，他们的总重量是 j 的最优解</strong>\n<ul>\n<li>如果 <strong>i</strong> 背包不拿，那么 <code>dp[i][j] = dp[i - 1][j]</code></li>\n<li>如果 <strong>i</strong> 背包拿取，那么 <code>dp[i][j] = dp[i - 1][j - weights[i]] + values[i]</code>\n<ul>\n<li>也就是说，拿取之后，需要看剩下的部分最优解</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"算法优化\"><a class=\"markdownIt-Anchor\" href=\"#算法优化\"></a> 算法优化</h4>\n<p>根据之前的状态转移方程，我们可以约减一维的 <strong>dp</strong> 空间</p>\n<p>改进之后的 <strong>dp</strong> 状态转移方程如下：</p>\n<p><code>dp[i] = max(dp[j], dp[j - weights[i]] + values[i])</code></p>\n<blockquote>\n<p>为什么在内层循环，<strong>j</strong> 需要逆序？</p>\n<p>在没有开始计算的时候，<strong>dp[i]表示的是dp[i-1][j]</strong> 。而当我们需要计算 <code>dp[i] = max(dp[j], dp[j - weights[i]] + values[i])</code>的时候，需要保证 <code>dp[j - w[i]]</code> 是 <strong>没有被改变的</strong>。因此需要<strong>从后往前</strong></p>\n</blockquote>\n<h3 id=\"2-完全背包问题\"><a class=\"markdownIt-Anchor\" href=\"#2-完全背包问题\"></a> 2. 完全背包问题</h3>\n<p>每一件物品可以 <strong>无限次</strong> 拿取</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> N , V;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; N &gt;&gt; V;</span><br><span class=\"line\">    vector&lt;int&gt; w(N + 1) , v(N + 1);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= N ; ++i) <span class=\"built_in\">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"title\">dp</span><span class=\"params\">(N + <span class=\"number\">1</span> , <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(V + <span class=\"number\">1</span> , <span class=\"number\">0</span>))</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N ; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ;j &lt;= V; ++j)&#123;</span><br><span class=\"line\">            dp[i][j] = dp[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span> ; k*w[i] &lt;= j; ++k)&#123;</span><br><span class=\"line\">                dp[i][j] = max(dp[i][j] , dp[i][j - k * w[i]] + k * v[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; dp[N][V] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最重要的状态转移方程对比</p>\n<ul>\n<li><strong>01背包</strong> ：<code>dp[i][j] = max(dp[i-1][j],dp[i - 1][j - w[i]] + v[i])</code></li>\n<li><strong>完全背包</strong> ：<code>dp[i][j] = max(dp[i][j] , dp[i - 1][j - k * w[i]] + k * v[i]);</code></li>\n</ul>\n<p>不难看出，两者其实非常的类似。根据下标我们可以给出压缩之后的优化版本完全背包解法</p>\n<blockquote>\n<p><strong>01背包</strong> 和 <strong>完全背包</strong> 的不同</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//01背包</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i  in <span class=\"number\">0</span> ... N</span><br><span class=\"line\">    <span class=\"keyword\">for</span>  j = V ... <span class=\"number\">0</span></span><br><span class=\"line\">        f[j] = max&#123;f[j], f[j - weight[i]] + value[i]&#125;</span><br><span class=\"line\"><span class=\"comment\">//完全背包</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">int</span> <span class=\"number\">0</span> ... N</span><br><span class=\"line\">  \t<span class=\"keyword\">for</span>\t j = <span class=\"number\">0</span> ... V</span><br><span class=\"line\">      \tf[j] = max&#123;f[j] , f[j - weight[j]] + value[i]&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，只有内层循环的执行顺序不同</p>\n</blockquote>\n<p>给出 <strong>完全背包问题</strong> 的优化方案</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n , capacity;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; capacity;</span><br><span class=\"line\">    vector&lt;int&gt; c(n + 1) , w(n + 1);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(max(n , capacity))</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ;++i) <span class=\"built_in\">cin</span> &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n ;++i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = c[i] ; j &lt;= capacity ; ++j)</span><br><span class=\"line\">            dp[j] = max(dp[j] , dp[j - c[i]] + w[i]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; dp[capacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-01背包问题\"><a class=\"markdownIt-Anchor\" href=\"#1-01背包问题\"></a> 1. 01背包问题</h3>\n<p>有 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 件物品和一个容量是 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 的背包。每件物品只能使用一次。</p>\n<p>分析：</p>\n<ul>\n<li>每一个背包只有 <strong>拿出 or 不拿出</strong> 两种情况</li>\n<li>对于 <strong>dp</strong> 数组，我们某一个状态 <code>dp[i][j]</code> 表示 <strong>前i种背包的情况下，他们的总重量是 j 的最优解</strong>\n<ul>\n<li>如果 <strong>i</strong> 背包不拿，那么 <code>dp[i][j] = dp[i - 1][j]</code></li>\n<li>如果 <strong>i</strong> 背包拿取，那么 <code>dp[i][j] = dp[i - 1][j - weights[i]] + values[i]</code>\n<ul>\n<li>也就是说，拿取之后，需要看剩下的部分最优解</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"算法优化\"><a class=\"markdownIt-Anchor\" href=\"#算法优化\"></a> 算法优化</h4>\n<p>根据之前的状态转移方程，我们可以约减一维的 <strong>dp</strong> 空间</p>\n<p>改进之后的 <strong>dp</strong> 状态转移方程如下：</p>\n<p><code>dp[i] = max(dp[j], dp[j - weights[i]] + values[i])</code></p>\n<blockquote>\n<p>为什么在内层循环，<strong>j</strong> 需要逆序？</p>\n<p>在没有开始计算的时候，<strong>dp[i]表示的是dp[i-1][j]</strong> 。而当我们需要计算 <code>dp[i] = max(dp[j], dp[j - weights[i]] + values[i])</code>的时候，需要保证 <code>dp[j - w[i]]</code> 是 <strong>没有被改变的</strong>。因此需要<strong>从后往前</strong></p>\n</blockquote>\n<h3 id=\"2-完全背包问题\"><a class=\"markdownIt-Anchor\" href=\"#2-完全背包问题\"></a> 2. 完全背包问题</h3>\n<p>每一件物品可以 <strong>无限次</strong> 拿取</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> N , V;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; N &gt;&gt; V;</span><br><span class=\"line\">    vector&lt;int&gt; w(N + 1) , v(N + 1);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= N ; ++i) <span class=\"built_in\">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"title\">dp</span><span class=\"params\">(N + <span class=\"number\">1</span> , <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;(V + <span class=\"number\">1</span> , <span class=\"number\">0</span>))</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= N ; ++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ;j &lt;= V; ++j)&#123;</span><br><span class=\"line\">            dp[i][j] = dp[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span> ; k*w[i] &lt;= j; ++k)&#123;</span><br><span class=\"line\">                dp[i][j] = max(dp[i][j] , dp[i][j - k * w[i]] + k * v[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; dp[N][V] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最重要的状态转移方程对比</p>\n<ul>\n<li><strong>01背包</strong> ：<code>dp[i][j] = max(dp[i-1][j],dp[i - 1][j - w[i]] + v[i])</code></li>\n<li><strong>完全背包</strong> ：<code>dp[i][j] = max(dp[i][j] , dp[i - 1][j - k * w[i]] + k * v[i]);</code></li>\n</ul>\n<p>不难看出，两者其实非常的类似。根据下标我们可以给出压缩之后的优化版本完全背包解法</p>\n<blockquote>\n<p><strong>01背包</strong> 和 <strong>完全背包</strong> 的不同</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//01背包</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i  in <span class=\"number\">0</span> ... N</span><br><span class=\"line\">    <span class=\"keyword\">for</span>  j = V ... <span class=\"number\">0</span></span><br><span class=\"line\">        f[j] = max&#123;f[j], f[j - weight[i]] + value[i]&#125;</span><br><span class=\"line\"><span class=\"comment\">//完全背包</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">int</span> <span class=\"number\">0</span> ... N</span><br><span class=\"line\">  \t<span class=\"keyword\">for</span>\t j = <span class=\"number\">0</span> ... V</span><br><span class=\"line\">      \tf[j] = max&#123;f[j] , f[j - weight[j]] + value[i]&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，只有内层循环的执行顺序不同</p>\n</blockquote>\n<p>给出 <strong>完全背包问题</strong> 的优化方案</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n , capacity;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; capacity;</span><br><span class=\"line\">    vector&lt;int&gt; c(n + 1) , w(n + 1);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(max(n , capacity))</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ;++i) <span class=\"built_in\">cin</span> &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n ;++i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = c[i] ; j &lt;= capacity ; ++j)</span><br><span class=\"line\">            dp[j] = max(dp[j] , dp[j - c[i]] + w[i]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; dp[capacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"自己动手实现负载均衡算法","date":"2020-04-02T14:32:27.000Z","cover_img":"https://images.unsplash.com/photo-1584843863029-1bf7e8312a64?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1349&q=80","cover":"https://images.unsplash.com/photo-1584843863029-1bf7e8312a64?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1349&q=80","feature_img":"https://images.unsplash.com/12/car.jpg?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1429&q=80","description":null,"keywords":null,"_content":"\n#### 背景\n\n最近在看 `dubbo` ，它的服务治理当中有很大一个方面讲的就是负载均衡。由于我们的服务提供者可以有多个 `replication` ，究竟选择哪一个比较合适，就成为了我们需要去思考的一个问题。完全出于兴趣使然，我打算动手实现一下常见的负载均衡算法，来让自己加深一下理解。根据一个非常常见的请求调用，以参数作为请求内容，来判定多个备用选项中的选择策略制定\n\n设计了类 `Provider` 和 `Consumer` ，分别表示服务提供者和消费者。由消费者进行触发，来选取 `N` 个服务提供者的负载均衡策略。\n\n```java\n/**\n * Entity\n */\npublic class Provider {\n\tprivate String id;                //id信息\n\tprivate double weight;            //价值权重\n\tprivate long milliseconds;        //响应时间\n\n\tpublic Provider(String id,  double weight, long milliseconds) {\n\t\tthis.id = id;\n\t\tthis.weight = weight;\n\t\tthis.milliseconds = milliseconds;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic double getWeight() {\n\t\treturn weight;\n\t}\n\n\tpublic void setWeight(double weight) {\n\t\tthis.weight = weight;\n\t}\n\n\tpublic long getMilliseconds() {\n\t\treturn milliseconds;\n\t}\n\n\tpublic void setMilliseconds(long milliseconds) {\n\t\tthis.milliseconds = milliseconds;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"id:%s\\tweight:%f\\tlatency:%d\",\n\t\t\t\tid, weight, milliseconds);\n\t}\n}\n```\n\n\n\n#### LRU算法\n\n如下是我的实现策略，内部维护一个 `lruQueue` 队列，队头表示最少访问的节点，当访问某一个节点之后，直接把这个节点移动到队尾即可\n\n```java\n/**\n * 最近最少使用优先\n */\npublic class LruHandler implements BalanceHandler {\n\tprivate Queue<Provider> lruQueue = new LinkedList<>();\n\tprivate int providerCnt =0;\n\n\tpublic void run(List<Provider> providerList) {\n\t\tthis.providerCnt = providerList.size();\n\t\tlruQueue.addAll(providerList);\n\t\tassert this.providerCnt >= 1;\n\t\tSystem.out.println(String.format(\"Start choosing from all of the %d providers\", this.providerCnt));\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\t//choose random first\n\t\t\t\tRandom ran = new Random();\n\t\t\t\tint idx = ran.nextInt(this.providerCnt - 1);\n\t\t\t\tSystem.out.println(String.format(\"Choose provider %d\", idx));\n\t\t\t\t//choose idx and move it to\n\t\t\t\tProvider chosenP = providerList.get(idx);\n\t\t\t\tSystem.out.println(String.format(\"The provider infomation is %s\", chosenP.toString()\n\t\t\t\t));\n\t\t\t\tlruQueue.remove(chosenP);\n\t\t\t\tlruQueue.offer(chosenP);\n\t\t\t\tSystem.out.println(String.format(\"The current queue:%s\", queueToStr()));\n\t\t\t\tSystem.out.println(\"============================================================\");\n\n\t\t\t\tThread.sleep(4000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String queueToStr() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('\\t');\n\t\tfor (Provider p : this.lruQueue) {\n\t\t\tsb.append(p.getId()).append(\"\\t\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n```\n\n#### 随机选取算法\n\n这一个随机化的选取算法主要采取了 `weight` 来进行权重排序，其实 `Dubbo` 里面基于最少活跃度的算法，也是一个特定的优先级队列。这些基于优先级队列的负载均衡算法，直接可以根据权值排序就能够得到\n\n```java\n/**\n * 随机加权选取\n */\npublic class RandomWeightHandler implements BalanceHandler {\n\n\t@Override\n\tpublic void run(List<Provider> providerList) {\n\t\tint size = providerList.size();\n\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(String.format(\"The pre queue:%s\", queueToStr(providerList)));\n\t\t\t\t// change all of the provider weight\n\t\t\t\tfor (int i = 0; i < size; ++i) {\n\t\t\t\t\tProvider en = providerList.get(i);\n\t\t\t\t\ten.setWeight(new Random().nextDouble());\n\t\t\t\t\tproviderList.set(i, en);\n\t\t\t\t}\n\t\t\t\tproviderList.sort((o1, o2) -> {\n\t\t\t\t\tif (o1.getWeight() < o2.getWeight()) return 1;\n\t\t\t\t\telse return -1;\n\t\t\t\t});\n\t\t\t\tProvider p = providerList.get(0);\n\t\t\t\tSystem.out.println(String.format(\"The provider information is %s\", p.toString()));\n\t\t\t\tSystem.out.println(String.format(\"The current queue:%s\", queueToStr(providerList)));\n\t\t\t\tSystem.out.println(\"========================================================\");\n\n\t\t\t\tThread.sleep(4000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String queueToStr(List<Provider> queue) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('\\t');\n\t\tfor (Provider p : queue) {\n\t\t\tsb.append(p.getId()).append(\"\\t\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n```\n\n","source":"_posts/让我们实现一些负载均衡算法.md","raw":"---\ntitle: 自己动手实现负载均衡算法\ndate: 2020-04-02 22:32:27\ntags: coding\ncover_img: https://images.unsplash.com/photo-1584843863029-1bf7e8312a64?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1349&q=80\ncover: https://images.unsplash.com/photo-1584843863029-1bf7e8312a64?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1349&q=80\nfeature_img: https://images.unsplash.com/12/car.jpg?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1429&q=80\ndescription:\nkeywords:\n---\n\n#### 背景\n\n最近在看 `dubbo` ，它的服务治理当中有很大一个方面讲的就是负载均衡。由于我们的服务提供者可以有多个 `replication` ，究竟选择哪一个比较合适，就成为了我们需要去思考的一个问题。完全出于兴趣使然，我打算动手实现一下常见的负载均衡算法，来让自己加深一下理解。根据一个非常常见的请求调用，以参数作为请求内容，来判定多个备用选项中的选择策略制定\n\n设计了类 `Provider` 和 `Consumer` ，分别表示服务提供者和消费者。由消费者进行触发，来选取 `N` 个服务提供者的负载均衡策略。\n\n```java\n/**\n * Entity\n */\npublic class Provider {\n\tprivate String id;                //id信息\n\tprivate double weight;            //价值权重\n\tprivate long milliseconds;        //响应时间\n\n\tpublic Provider(String id,  double weight, long milliseconds) {\n\t\tthis.id = id;\n\t\tthis.weight = weight;\n\t\tthis.milliseconds = milliseconds;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic double getWeight() {\n\t\treturn weight;\n\t}\n\n\tpublic void setWeight(double weight) {\n\t\tthis.weight = weight;\n\t}\n\n\tpublic long getMilliseconds() {\n\t\treturn milliseconds;\n\t}\n\n\tpublic void setMilliseconds(long milliseconds) {\n\t\tthis.milliseconds = milliseconds;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"id:%s\\tweight:%f\\tlatency:%d\",\n\t\t\t\tid, weight, milliseconds);\n\t}\n}\n```\n\n\n\n#### LRU算法\n\n如下是我的实现策略，内部维护一个 `lruQueue` 队列，队头表示最少访问的节点，当访问某一个节点之后，直接把这个节点移动到队尾即可\n\n```java\n/**\n * 最近最少使用优先\n */\npublic class LruHandler implements BalanceHandler {\n\tprivate Queue<Provider> lruQueue = new LinkedList<>();\n\tprivate int providerCnt =0;\n\n\tpublic void run(List<Provider> providerList) {\n\t\tthis.providerCnt = providerList.size();\n\t\tlruQueue.addAll(providerList);\n\t\tassert this.providerCnt >= 1;\n\t\tSystem.out.println(String.format(\"Start choosing from all of the %d providers\", this.providerCnt));\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\t//choose random first\n\t\t\t\tRandom ran = new Random();\n\t\t\t\tint idx = ran.nextInt(this.providerCnt - 1);\n\t\t\t\tSystem.out.println(String.format(\"Choose provider %d\", idx));\n\t\t\t\t//choose idx and move it to\n\t\t\t\tProvider chosenP = providerList.get(idx);\n\t\t\t\tSystem.out.println(String.format(\"The provider infomation is %s\", chosenP.toString()\n\t\t\t\t));\n\t\t\t\tlruQueue.remove(chosenP);\n\t\t\t\tlruQueue.offer(chosenP);\n\t\t\t\tSystem.out.println(String.format(\"The current queue:%s\", queueToStr()));\n\t\t\t\tSystem.out.println(\"============================================================\");\n\n\t\t\t\tThread.sleep(4000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String queueToStr() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('\\t');\n\t\tfor (Provider p : this.lruQueue) {\n\t\t\tsb.append(p.getId()).append(\"\\t\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n```\n\n#### 随机选取算法\n\n这一个随机化的选取算法主要采取了 `weight` 来进行权重排序，其实 `Dubbo` 里面基于最少活跃度的算法，也是一个特定的优先级队列。这些基于优先级队列的负载均衡算法，直接可以根据权值排序就能够得到\n\n```java\n/**\n * 随机加权选取\n */\npublic class RandomWeightHandler implements BalanceHandler {\n\n\t@Override\n\tpublic void run(List<Provider> providerList) {\n\t\tint size = providerList.size();\n\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(String.format(\"The pre queue:%s\", queueToStr(providerList)));\n\t\t\t\t// change all of the provider weight\n\t\t\t\tfor (int i = 0; i < size; ++i) {\n\t\t\t\t\tProvider en = providerList.get(i);\n\t\t\t\t\ten.setWeight(new Random().nextDouble());\n\t\t\t\t\tproviderList.set(i, en);\n\t\t\t\t}\n\t\t\t\tproviderList.sort((o1, o2) -> {\n\t\t\t\t\tif (o1.getWeight() < o2.getWeight()) return 1;\n\t\t\t\t\telse return -1;\n\t\t\t\t});\n\t\t\t\tProvider p = providerList.get(0);\n\t\t\t\tSystem.out.println(String.format(\"The provider information is %s\", p.toString()));\n\t\t\t\tSystem.out.println(String.format(\"The current queue:%s\", queueToStr(providerList)));\n\t\t\t\tSystem.out.println(\"========================================================\");\n\n\t\t\t\tThread.sleep(4000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String queueToStr(List<Provider> queue) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('\\t');\n\t\tfor (Provider p : queue) {\n\t\t\tsb.append(p.getId()).append(\"\\t\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n```\n\n","slug":"让我们实现一些负载均衡算法","published":1,"updated":"2020-10-22T02:12:58.120Z","_id":"ckgk7k80r001006me1oh13du2","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\"></a> 背景</h4>\n<p>最近在看 <code>dubbo</code> ，它的服务治理当中有很大一个方面讲的就是负载均衡。由于我们的服务提供者可以有多个 <code>replication</code> ，究竟选择哪一个比较合适，就成为了我们需要去思考的一个问题。完全出于兴趣使然，我打算动手实现一下常见的负载均衡算法，来让自己加深一下理解。根据一个非常常见的请求调用，以参数作为请求内容，来判定多个备用选项中的选择策略制定</p>\n<p>设计了类 <code>Provider</code> 和 <code>Consumer</code> ，分别表示服务提供者和消费者。由消费者进行触发，来选取 <code>N</code> 个服务提供者的负载均衡策略。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Entity</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String id;                <span class=\"comment\">//id信息</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">double</span> weight;            <span class=\"comment\">//价值权重</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">long</span> milliseconds;        <span class=\"comment\">//响应时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Provider</span><span class=\"params\">(String id,  <span class=\"keyword\">double</span> weight, <span class=\"keyword\">long</span> milliseconds)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.milliseconds = milliseconds;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getWeight</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> weight;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWeight</span><span class=\"params\">(<span class=\"keyword\">double</span> weight)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getMilliseconds</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> milliseconds;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMilliseconds</span><span class=\"params\">(<span class=\"keyword\">long</span> milliseconds)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.milliseconds = milliseconds;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> String.format(<span class=\"string\">&quot;id:%s\\tweight:%f\\tlatency:%d&quot;</span>,</span><br><span class=\"line\">\t\t\t\tid, weight, milliseconds);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"lru算法\"><a class=\"markdownIt-Anchor\" href=\"#lru算法\"></a> LRU算法</h4>\n<p>如下是我的实现策略，内部维护一个 <code>lruQueue</code> 队列，队头表示最少访问的节点，当访问某一个节点之后，直接把这个节点移动到队尾即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最近最少使用优先</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LruHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">BalanceHandler</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Queue&lt;Provider&gt; lruQueue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> providerCnt =<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(List&lt;Provider&gt; providerList)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.providerCnt = providerList.size();</span><br><span class=\"line\">\t\tlruQueue.addAll(providerList);</span><br><span class=\"line\">\t\t<span class=\"keyword\">assert</span> <span class=\"keyword\">this</span>.providerCnt &gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tSystem.out.println(String.format(<span class=\"string\">&quot;Start choosing from all of the %d providers&quot;</span>, <span class=\"keyword\">this</span>.providerCnt));</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//choose random first</span></span><br><span class=\"line\">\t\t\t\tRandom ran = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> idx = ran.nextInt(<span class=\"keyword\">this</span>.providerCnt - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(String.format(<span class=\"string\">&quot;Choose provider %d&quot;</span>, idx));</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//choose idx and move it to</span></span><br><span class=\"line\">\t\t\t\tProvider chosenP = providerList.get(idx);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(String.format(<span class=\"string\">&quot;The provider infomation is %s&quot;</span>, chosenP.toString()</span><br><span class=\"line\">\t\t\t\t));</span><br><span class=\"line\">\t\t\t\tlruQueue.remove(chosenP);</span><br><span class=\"line\">\t\t\t\tlruQueue.offer(chosenP);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(String.format(<span class=\"string\">&quot;The current queue:%s&quot;</span>, queueToStr()));</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;============================================================&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">queueToStr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tStringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">\t\tsb.append(<span class=\"string\">&#x27;\\t&#x27;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Provider p : <span class=\"keyword\">this</span>.lruQueue) &#123;</span><br><span class=\"line\">\t\t\tsb.append(p.getId()).append(<span class=\"string\">&quot;\\t&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"随机选取算法\"><a class=\"markdownIt-Anchor\" href=\"#随机选取算法\"></a> 随机选取算法</h4>\n<p>这一个随机化的选取算法主要采取了 <code>weight</code> 来进行权重排序，其实 <code>Dubbo</code> 里面基于最少活跃度的算法，也是一个特定的优先级队列。这些基于优先级队列的负载均衡算法，直接可以根据权值排序就能够得到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 随机加权选取</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWeightHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">BalanceHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(List&lt;Provider&gt; providerList)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> size = providerList.size();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(String.format(<span class=\"string\">&quot;The pre queue:%s&quot;</span>, queueToStr(providerList)));</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// change all of the provider weight</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">\t\t\t\t\tProvider en = providerList.get(i);</span><br><span class=\"line\">\t\t\t\t\ten.setWeight(<span class=\"keyword\">new</span> Random().nextDouble());</span><br><span class=\"line\">\t\t\t\t\tproviderList.set(i, en);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tproviderList.sort((o1, o2) -&gt; &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (o1.getWeight() &lt; o2.getWeight()) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\tProvider p = providerList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(String.format(<span class=\"string\">&quot;The provider information is %s&quot;</span>, p.toString()));</span><br><span class=\"line\">\t\t\t\tSystem.out.println(String.format(<span class=\"string\">&quot;The current queue:%s&quot;</span>, queueToStr(providerList)));</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;========================================================&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">queueToStr</span><span class=\"params\">(List&lt;Provider&gt; queue)</span> </span>&#123;</span><br><span class=\"line\">\t\tStringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">\t\tsb.append(<span class=\"string\">&#x27;\\t&#x27;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Provider p : queue) &#123;</span><br><span class=\"line\">\t\t\tsb.append(p.getId()).append(<span class=\"string\">&quot;\\t&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\"></a> 背景</h4>\n<p>最近在看 <code>dubbo</code> ，它的服务治理当中有很大一个方面讲的就是负载均衡。由于我们的服务提供者可以有多个 <code>replication</code> ，究竟选择哪一个比较合适，就成为了我们需要去思考的一个问题。完全出于兴趣使然，我打算动手实现一下常见的负载均衡算法，来让自己加深一下理解。根据一个非常常见的请求调用，以参数作为请求内容，来判定多个备用选项中的选择策略制定</p>\n<p>设计了类 <code>Provider</code> 和 <code>Consumer</code> ，分别表示服务提供者和消费者。由消费者进行触发，来选取 <code>N</code> 个服务提供者的负载均衡策略。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Entity</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String id;                <span class=\"comment\">//id信息</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">double</span> weight;            <span class=\"comment\">//价值权重</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">long</span> milliseconds;        <span class=\"comment\">//响应时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Provider</span><span class=\"params\">(String id,  <span class=\"keyword\">double</span> weight, <span class=\"keyword\">long</span> milliseconds)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.milliseconds = milliseconds;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getWeight</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> weight;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWeight</span><span class=\"params\">(<span class=\"keyword\">double</span> weight)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getMilliseconds</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> milliseconds;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMilliseconds</span><span class=\"params\">(<span class=\"keyword\">long</span> milliseconds)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.milliseconds = milliseconds;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> String.format(<span class=\"string\">&quot;id:%s\\tweight:%f\\tlatency:%d&quot;</span>,</span><br><span class=\"line\">\t\t\t\tid, weight, milliseconds);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"lru算法\"><a class=\"markdownIt-Anchor\" href=\"#lru算法\"></a> LRU算法</h4>\n<p>如下是我的实现策略，内部维护一个 <code>lruQueue</code> 队列，队头表示最少访问的节点，当访问某一个节点之后，直接把这个节点移动到队尾即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最近最少使用优先</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LruHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">BalanceHandler</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Queue&lt;Provider&gt; lruQueue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> providerCnt =<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(List&lt;Provider&gt; providerList)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.providerCnt = providerList.size();</span><br><span class=\"line\">\t\tlruQueue.addAll(providerList);</span><br><span class=\"line\">\t\t<span class=\"keyword\">assert</span> <span class=\"keyword\">this</span>.providerCnt &gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tSystem.out.println(String.format(<span class=\"string\">&quot;Start choosing from all of the %d providers&quot;</span>, <span class=\"keyword\">this</span>.providerCnt));</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//choose random first</span></span><br><span class=\"line\">\t\t\t\tRandom ran = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> idx = ran.nextInt(<span class=\"keyword\">this</span>.providerCnt - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(String.format(<span class=\"string\">&quot;Choose provider %d&quot;</span>, idx));</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//choose idx and move it to</span></span><br><span class=\"line\">\t\t\t\tProvider chosenP = providerList.get(idx);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(String.format(<span class=\"string\">&quot;The provider infomation is %s&quot;</span>, chosenP.toString()</span><br><span class=\"line\">\t\t\t\t));</span><br><span class=\"line\">\t\t\t\tlruQueue.remove(chosenP);</span><br><span class=\"line\">\t\t\t\tlruQueue.offer(chosenP);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(String.format(<span class=\"string\">&quot;The current queue:%s&quot;</span>, queueToStr()));</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;============================================================&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">queueToStr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tStringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">\t\tsb.append(<span class=\"string\">&#x27;\\t&#x27;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Provider p : <span class=\"keyword\">this</span>.lruQueue) &#123;</span><br><span class=\"line\">\t\t\tsb.append(p.getId()).append(<span class=\"string\">&quot;\\t&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"随机选取算法\"><a class=\"markdownIt-Anchor\" href=\"#随机选取算法\"></a> 随机选取算法</h4>\n<p>这一个随机化的选取算法主要采取了 <code>weight</code> 来进行权重排序，其实 <code>Dubbo</code> 里面基于最少活跃度的算法，也是一个特定的优先级队列。这些基于优先级队列的负载均衡算法，直接可以根据权值排序就能够得到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 随机加权选取</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWeightHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">BalanceHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(List&lt;Provider&gt; providerList)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> size = providerList.size();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(String.format(<span class=\"string\">&quot;The pre queue:%s&quot;</span>, queueToStr(providerList)));</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// change all of the provider weight</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">\t\t\t\t\tProvider en = providerList.get(i);</span><br><span class=\"line\">\t\t\t\t\ten.setWeight(<span class=\"keyword\">new</span> Random().nextDouble());</span><br><span class=\"line\">\t\t\t\t\tproviderList.set(i, en);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tproviderList.sort((o1, o2) -&gt; &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (o1.getWeight() &lt; o2.getWeight()) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\tProvider p = providerList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(String.format(<span class=\"string\">&quot;The provider information is %s&quot;</span>, p.toString()));</span><br><span class=\"line\">\t\t\t\tSystem.out.println(String.format(<span class=\"string\">&quot;The current queue:%s&quot;</span>, queueToStr(providerList)));</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;========================================================&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tThread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">queueToStr</span><span class=\"params\">(List&lt;Provider&gt; queue)</span> </span>&#123;</span><br><span class=\"line\">\t\tStringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">\t\tsb.append(<span class=\"string\">&#x27;\\t&#x27;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Provider p : queue) &#123;</span><br><span class=\"line\">\t\t\tsb.append(p.getId()).append(<span class=\"string\">&quot;\\t&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"设计模式-单例","date":"2019-12-07T08:47:11.000Z","cover_img":"https://images.unsplash.com/photo-1507580433829-a0989f4d4469?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80","cover":"https://images.unsplash.com/photo-1507580433829-a0989f4d4469?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80","feature_img":"https://images.unsplash.com/photo-1472512946974-cc09a294e210?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1115&q=80","_content":"\n## 单例模式\n\n给出最原始的代码\n\n```java\npublic class Singleton {\n\n    //一个静态的实例\n    private static Singleton singleton;\n    //私有化构造函数\n    private Singleton(){}\n    //给出一个公共的静态方法返回一个单一实例\n    public static Singleton getInstance(){\n        if (singleton == null) {\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n```\n\n现在我们就需要考虑==多线程环境==下的单例模式实现了\n\n**懒汉模式**\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton(){}\n    public static Singleton getInstance(){\n        if (instance == null) {\n            //Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n**饿汉模式**\n\n```java\npublic class Singleton {\n    private static Singleton instance = new Singleton();\n    private Singleton(){}\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n> 多线程下的懒汉模式会出现问题——在判定是 *null* 的时候，还没来得及进行创建实例，另一个进程就进入进行判定\n\n#### 解决办法1\n\n方法上添加 **synchronized** 关键字\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton(){}\n    public static synchronized Singleton getInstance(){\n        if (instance == null) {\n            //Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n> 问题：如果两个线程都要获取单例引用，只能等一个线程获取后，另一个线程才能获取。\n\n#### 解决方法2\n\n双检查锁机制（Double Check Locking）,也叫”DCL“\n\n> 双锁的意思，是指 检测两次instance是否为空。\n\n```java\npublic class Singleton {  \n      \n    //使用volatile关键字保其可见性  \n    volatile private static Singleton instance = null;  \n      \n    private MySingleton(){}  \n       \n    public static MySingleton getInstance() {   \n            if(instance == null){//懒汉式   \n                  synchronized (Singleton.class) {  \n                    if(instance == null){//二次检查  \n                        instance = new MySingleton();  \n                    }  \n                } \n            }\n        return instance;  \n    }  \n}  \n```\n\n#### 解决办法3\n\n当然，我们最好还是采取**饿汉式**\n\n```java\npublic class Singleton{\n    //类加载时就初始化\n    private static final Singleton instance = new Singleton();\n    \n    private Singleton(){}\n\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n#### 解决办法4\n\n采取 **静态内部类**\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE; \n    }  \n}\n```\n\n#### 解决办法5\n\n枚举 Enum\n\n```java\npublic enum EasySingleton{\n    INSTANCE;\n}\n```\n\n","source":"_posts/设计模式-单例.md","raw":"---\ntitle: 设计模式-单例\ndate: 2019-12-07 16:47:11\ntags: 设计模式\ncover_img: https://images.unsplash.com/photo-1507580433829-a0989f4d4469?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80\ncover: https://images.unsplash.com/photo-1507580433829-a0989f4d4469?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80\nfeature_img: https://images.unsplash.com/photo-1472512946974-cc09a294e210?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1115&q=80\n---\n\n## 单例模式\n\n给出最原始的代码\n\n```java\npublic class Singleton {\n\n    //一个静态的实例\n    private static Singleton singleton;\n    //私有化构造函数\n    private Singleton(){}\n    //给出一个公共的静态方法返回一个单一实例\n    public static Singleton getInstance(){\n        if (singleton == null) {\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n```\n\n现在我们就需要考虑==多线程环境==下的单例模式实现了\n\n**懒汉模式**\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton(){}\n    public static Singleton getInstance(){\n        if (instance == null) {\n            //Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n**饿汉模式**\n\n```java\npublic class Singleton {\n    private static Singleton instance = new Singleton();\n    private Singleton(){}\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n> 多线程下的懒汉模式会出现问题——在判定是 *null* 的时候，还没来得及进行创建实例，另一个进程就进入进行判定\n\n#### 解决办法1\n\n方法上添加 **synchronized** 关键字\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton(){}\n    public static synchronized Singleton getInstance(){\n        if (instance == null) {\n            //Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n> 问题：如果两个线程都要获取单例引用，只能等一个线程获取后，另一个线程才能获取。\n\n#### 解决方法2\n\n双检查锁机制（Double Check Locking）,也叫”DCL“\n\n> 双锁的意思，是指 检测两次instance是否为空。\n\n```java\npublic class Singleton {  \n      \n    //使用volatile关键字保其可见性  \n    volatile private static Singleton instance = null;  \n      \n    private MySingleton(){}  \n       \n    public static MySingleton getInstance() {   \n            if(instance == null){//懒汉式   \n                  synchronized (Singleton.class) {  \n                    if(instance == null){//二次检查  \n                        instance = new MySingleton();  \n                    }  \n                } \n            }\n        return instance;  \n    }  \n}  \n```\n\n#### 解决办法3\n\n当然，我们最好还是采取**饿汉式**\n\n```java\npublic class Singleton{\n    //类加载时就初始化\n    private static final Singleton instance = new Singleton();\n    \n    private Singleton(){}\n\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n#### 解决办法4\n\n采取 **静态内部类**\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE; \n    }  \n}\n```\n\n#### 解决办法5\n\n枚举 Enum\n\n```java\npublic enum EasySingleton{\n    INSTANCE;\n}\n```\n\n","slug":"设计模式-单例","published":1,"updated":"2020-10-22T02:12:58.120Z","_id":"ckgk7k80t001306me4k7t2pv9","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"单例模式\"><a class=\"markdownIt-Anchor\" href=\"#单例模式\"></a> 单例模式</h2>\n<p>给出最原始的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//一个静态的实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton;</span><br><span class=\"line\">    <span class=\"comment\">//私有化构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//给出一个公共的静态方法返回一个单一实例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们就需要考虑<mark>多线程环境</mark>下的单例模式实现了</p>\n<p><strong>懒汉模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。</span></span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>饿汉模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>多线程下的懒汉模式会出现问题——在判定是 <em>null</em> 的时候，还没来得及进行创建实例，另一个进程就进入进行判定</p>\n</blockquote>\n<h4 id=\"解决办法1\"><a class=\"markdownIt-Anchor\" href=\"#解决办法1\"></a> 解决办法1</h4>\n<p>方法上添加 <strong>synchronized</strong> 关键字</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。</span></span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>问题：如果两个线程都要获取单例引用，只能等一个线程获取后，另一个线程才能获取。</p>\n</blockquote>\n<h4 id=\"解决方法2\"><a class=\"markdownIt-Anchor\" href=\"#解决方法2\"></a> 解决方法2</h4>\n<p>双检查锁机制（Double Check Locking）,也叫”DCL“</p>\n<blockquote>\n<p>双锁的意思，是指 检测两次instance是否为空。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//使用volatile关键字保其可见性  </span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">MySingleton</span><span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;<span class=\"comment\">//懒汉式   </span></span><br><span class=\"line\">                  <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;<span class=\"comment\">//二次检查  </span></span><br><span class=\"line\">                        instance = <span class=\"keyword\">new</span> MySingleton();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h4 id=\"解决办法3\"><a class=\"markdownIt-Anchor\" href=\"#解决办法3\"></a> 解决办法3</h4>\n<p>当然，我们最好还是采取<strong>饿汉式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//类加载时就初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"解决办法4\"><a class=\"markdownIt-Anchor\" href=\"#解决办法4\"></a> 解决办法4</h4>\n<p>采取 <strong>静态内部类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"解决办法5\"><a class=\"markdownIt-Anchor\" href=\"#解决办法5\"></a> 解决办法5</h4>\n<p>枚举 Enum</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">EasySingleton</span></span>&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"单例模式\"><a class=\"markdownIt-Anchor\" href=\"#单例模式\"></a> 单例模式</h2>\n<p>给出最原始的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//一个静态的实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton;</span><br><span class=\"line\">    <span class=\"comment\">//私有化构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//给出一个公共的静态方法返回一个单一实例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们就需要考虑<mark>多线程环境</mark>下的单例模式实现了</p>\n<p><strong>懒汉模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。</span></span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>饿汉模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>多线程下的懒汉模式会出现问题——在判定是 <em>null</em> 的时候，还没来得及进行创建实例，另一个进程就进入进行判定</p>\n</blockquote>\n<h4 id=\"解决办法1\"><a class=\"markdownIt-Anchor\" href=\"#解决办法1\"></a> 解决办法1</h4>\n<p>方法上添加 <strong>synchronized</strong> 关键字</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。</span></span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>问题：如果两个线程都要获取单例引用，只能等一个线程获取后，另一个线程才能获取。</p>\n</blockquote>\n<h4 id=\"解决方法2\"><a class=\"markdownIt-Anchor\" href=\"#解决方法2\"></a> 解决方法2</h4>\n<p>双检查锁机制（Double Check Locking）,也叫”DCL“</p>\n<blockquote>\n<p>双锁的意思，是指 检测两次instance是否为空。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//使用volatile关键字保其可见性  </span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">MySingleton</span><span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;<span class=\"comment\">//懒汉式   </span></span><br><span class=\"line\">                  <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;<span class=\"comment\">//二次检查  </span></span><br><span class=\"line\">                        instance = <span class=\"keyword\">new</span> MySingleton();  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h4 id=\"解决办法3\"><a class=\"markdownIt-Anchor\" href=\"#解决办法3\"></a> 解决办法3</h4>\n<p>当然，我们最好还是采取<strong>饿汉式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//类加载时就初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"解决办法4\"><a class=\"markdownIt-Anchor\" href=\"#解决办法4\"></a> 解决办法4</h4>\n<p>采取 <strong>静态内部类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"解决办法5\"><a class=\"markdownIt-Anchor\" href=\"#解决办法5\"></a> 解决办法5</h4>\n<p>枚举 Enum</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">EasySingleton</span></span>&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Java集合","date":"2020-03-14T09:26:21.000Z","cover_img":"https://images.unsplash.com/photo-1496507161348-aeec0403f141?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80","cover":"https://images.unsplash.com/photo-1496507161348-aeec0403f141?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80","feature_img":"https://images.unsplash.com/photo-1517958911667-09c05f6cd698?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80","description":null,"keywords":"笔记","_content":"\n## Java 集合类整理\n\n> *JDK* 版本 **1.8**\n>\n> 本文章就最近看的一些jdk源码来进行总结，可能会比较简洁\n\n### 1. List 大类\n\n主要包含了 **ArrayList , Vector , LinkedList**\n\n#### 1.1 ArrayList\n\n> 基本思想：\n>\n> - 默认大小为 10 ，初始化的时候不进行对象数组空间分配，直到第一次 `add(E e)`\n> - 缓冲区满才进行扩容。扩容策略采取 *OldCapacity* * 1.5\n> - `remove` 不进行容量调整 (会有浪费)\n\n关键代码部分 `grow(int minCapacity)`\n\n```java\nprivate void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n}\nprivate static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n}\n```\n\n根据之前计算得到的 `minCapacity` , 进行 `ArrayList` 的扩容操作。如果计算得到的容量大于了 `MAX_ARRAY_SIZE = INT_MAX - 8` ，那么会直接扩容到 `Integer.MAX_VALUE` \n\n> 这里的 `MAX_ARRAY_SIZE` 设置为 `INT_MAX - 8` 主要是为了考虑到，有一些*JVM* 的对象数组 (这里是 `Object[] elementData`) 会采取一定长度的 *header* 。如果直接设置为 `INT_MAX` 可能会引发 OOM\n\n此外，可以看出 `ArrayList` 扩容其实是采取了复制的方法，将原来空间的所有数据放到了另一块空间。这种做法其实在复制上消耗特别大\n\n#### 1.2 Vector\n\n> 基本思想：\n>\n> - 和 `ArrayList` 颇为类似，它也是以10作为初始容量，初始化不分配对象数组的空间\n> - 扩容采取  *OldCapacity* * 2\n> - `remove` 不进行容量调整\n> - 线程安全 `synchronized`\n\n核心代码如下：\n\n```java\nprivate void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + ((capacityIncrement > 0) ?\n                                         capacityIncrement : oldCapacity);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n> 这里的 `capacityIncrement` 是在初始化的时候可以额外指定的变量。如果指定了，那么就不进行乘以二扩容，而是每一次增加这个 `capacityIncrement` 变量\n\n#### 1.3 LinkedList\n\n> - 双向链表\n> - 内部额外存储头结点和尾结点\n\n### 2. KV 大类\n\n#### 2.1 HashMap\n\n> 面试里面最喜欢问的了，没有之一\n>\n> 主要几个流程：\n>\n> - `put`\n> - `get`\n> - `remove`\n>\n> 线程安全问题\n>\n> - put的时候导致的多线程数据不一致 \n>   - 两个线程前后写入，产生数据覆盖\n>   - 成环问题\n>\n> <img src=\"https://i.loli.net/2020/03/14/2WzkGAQVg9Rnpou.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n\n基本数据结构：\n\n- `class Node<K,V>` 是桶节点和链表节点的基本数据结构\n- `Node<K,V>[] table` 是哈希表内部的实现，其实就是 **链表数组**\n\n##### 2.1.1 put 添加 K,V 对\n\n1. 计算 `key` 的 `hashcode` 值，将对象的 `hashcode` 进行高16位和低16位的异或操作。可以看到， `HashMap` 支持对 `null` 键的处理\n\n```java\nstatic final int hash(Object key) {\n  int h;\n\treturn (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n2. `putValue` 主体部分\n\n在之前的 `hash` 获取之后，接下来一步就是进行哈希表的一个处理了，由于细节比较多，我直接在源代码里面加注释来解释了\n\n```java\n/**\n     * Implements Map.put and related methods.\n     *\n     * @param hash hash for key\n     * @param key the key\n     * @param value the value to put\n     * @param onlyIfAbsent if true, don't change existing value\n     * @param evict if false, the table is in creation mode.\n     * @return previous value, or null if none\n     */\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n      \t//如果tab没有初始化\n        if ((tab = table) == null || (n = tab.length) == 0)\n            //resize进行空间分配.\n          \tn = (tab = resize()).length;\n      \t//如果当前桶是空的 , 那么新建节点 , 直接插入\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        //当前桶已经有节点 , 需要在后面进行插入\n      \telse {\n            Node<K,V> e; K k;\n          \t//对于桶的第一个节点 p , 如果插入的点和第一个点 p 一样\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n          \t//如果是红黑树 , 就进行红黑树插入\n          \telse if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            //如果第一个节点不同 , 并且后面是链表\n          \telse {\n                  //遍历链表\n              \t\tfor (int binCount = 0; ; ++binCount) {\n \t\t\t\t\t\t\t\t\t\t//遇到空节点 , 表示可以插入 (1.7进行头插 , 1.8 进行尾插)         \n                    if ((e = p.next) == null) {\n                      \t//插入到尾端\n                        p.next = newNode(hash, key, value, null);\n                      \t//如果 binCount >= 8 - 1 (链表长度为8) , 就把链表转红黑树\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                  \t//如果遇到相同的节点\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\t // p = p.next\n                }\n            }\n          \t//如果这个键值对存在 , 就进行覆盖\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n      \t//如果map大小大于了阈值 , 再次进行 resize\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n有几个细节要提及：\n\n- `1.8` 中 , 链表和红黑树是交替使用的。\n  - 当链表长度达到了 **8** 之后，会转换为红黑树\n  - 当 `size` 是 **6** 之后，红黑树退化为链表\n  - 原因分析：\n    - 红黑树**平均**查询效率 O(logN) , 链表 O(N) / 2。在长度是 **8** 的时候，红黑树时间复杂度为 3 , 链表是 *8 / 2 = 4* 。这时候使用红黑树是效率更高的。而另一边退化的阈值设置为 **6** , 主要是中间有一个 **7** 的 *gap* , 从而避免红黑树和链表直接的频繁切换\n    - 当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件\n\n这里还有一个重要的调用函数 `resize()` 需要看一下\n\n```java\n// Cap 指的是哈希表中 , 链表数组的长度\n// Thr 指的是键值对的个数\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n  \t\t\t//阈值更新 (也就是整个哈希表的可容纳大小)\n        if (oldCap > 0) {\n          \t// 如果旧有oldCap很大 , 就把阈值设置为 Integer.MAX_VALUE\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n          \t//DEFAULT_INITIAL_CAPACITY = 16\n          \t//MAXIMUM_CAPACITY = 1 << 30\n          \t//如果 oldCap * 2 比 MAXIMUM_CAPACITY 小 , 那么阈值更新到 2 倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n  \t\t\t// 把新的链表数组长度设置为原来的 KV 对个数\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        // 对于初始化的情况\n  \t\t\t// 数组长度设置 16\n  \t\t\t// 阈值设置 0.75f * 16 = 12\n  \t\t\telse {\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n  \t\t\t//更新阈值 , 替换原有的哈希表. 数组长度为 newCap\n        threshold = newThr;\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n  \t\t\t//如果不是初始化的情形 , 需要进行rehash\n        if (oldTab != null) {\n          \t//遍历数组每一个桶\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n              \t//当前桶非空 , 需要进行rehash\n                if ((e = oldTab[j]) != null) {\n                  \t//原有桶清空\n                    oldTab[j] = null;\n                  \t//如果只有一个节点 , 直接再次计算hash , 填入就可以\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                  \t//如果是红黑树 , 那么红黑树的 split\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    //如果是链表\n                  \telse { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                          \t//获取next节点\n                            next = e.next;\n                          \t// e 作为前驱节点 , 同时记录下头节点和尾节点\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 低若干位 , 和原来的一致\n                            if ((e.hash & oldCap) == 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 插入到 loTail  , 进行尾插\n                              \tif (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                      \t//到这里 , 已经形成了单独的链表 \n                      \t//如果是低位 , 那么直接重新插入到原来的桶\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                      \t//插入到高位桶\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n\n#### 2.2 HashTable\n\n> 基本要点\n>\n> - 采用链表实现\n> - 线程安全 `synchronized`\n> - 默认的 Capacity (链表数组长度)是 **11** , 装载因子 0.75f\n> - *index* 计算：`index = (hash & 0x7FFFFFFF) % tab.length`\n> - 头插\n> - rehash的变化为 `newCapacity = (oldCapacity << 1) + 1`\n> - KV 不可以为空\n\n#### 2.3 LinkedHashMap\n\n这个类继承自 `HashMap`，内部维护了一个双向链表。这个链表可以决定迭代的遍历顺序\n\n在添加新节点的时候，将新节点链接在**内部双向链表的尾部**。\n\n`accessOrder=true`的模式下,在`afterNodeAccess()`函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。\n\n> 重点关注：afterNodeAccess()函数中，会修改modCount,因此当你正在accessOrder=true的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。\n\n#### 2.4 TreeMap\n\n> LinkedHashMap保证数据可以保持插入顺序\n>\n> 而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了\n\n内部采用了红黑树，并不是基于 **hash** 来进行实现的\n\n### 3. SET 大类\n\n#### 3.1 HashSet\n\n内部实现完全使用了 `HashMap`\n\n#### 3.2 TreeSet\n\n内部实现采用了 `TreeMap` ， 持有 `NavigableMap` 类型的引用\n\n### 4. 线程安全大类\n\n#### 4.1 ConcurrentHashMap\n\n> - *Key , Value* 不可以为空\n> - Hash计算如下 `(h ^ (h >>> 16)) & HASH_BITS`\n> - 链表 & 红黑树使用。链表进行尾插\n> - 链表和红黑树的临界值也是 **8**\n\n主要讲述一下和 *HashMap* 的不同\n\n##### Node定义\n\n在 *ConcurrentHashMap* 中，*Value,next* 都设置为了 `volatile` 内存可见\n\n```java\nprivate final Node<K,V>[] initTable() {\n        Node<K,V>[] tab; int sc;\n        while ((tab = table) == null || tab.length == 0) {\n            if ((sc = sizeCtl) < 0)\n                Thread.yield(); // lost initialization race; just spin\n          \t//CAS控制\n            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n                try {\n                    if ((tab = table) == null || tab.length == 0) {\n                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                        @SuppressWarnings(\"unchecked\")\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = tab = nt;\n                        sc = n - (n >>> 2);\n                    }\n                } finally {\n                    sizeCtl = sc;\n                }\n                break;\n            }\n        }\n        return tab;\n    }\n```\n\n**yield 和 sleep 的异同**\n\n1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。\n\n2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。\n\n3）yield 不能被中断，而 sleep 则可以接受中断。\n\n在 *1.8* 之前，采用了 **分段锁** ； 而 *1.8* 中主要使用了 **CAS** 和 **synchronized** 来进行并发控制\n\n**CAS** 没什么能说的，主要看一下分段锁 *Segment* \n\n这是一种 *ReentrantLock*，段的结构和 *HashMap* 类似，也是数组 + 链表。每一个段包含了 *HashEntry* 数组。当要对这个数组进行修改的时候，必须要先获得对应的锁(*Get*不需要获取锁，因为共享变量设置为了 `volatile`，除非读到的值是空的才会加锁重读)\n\n*volatile* 底层使用了**内存屏障**来加以完成，实现对内存操作的顺序控制。\n\n> *ReentrantLock* 可重入锁，表示已经获取到这个资源的线程，可以再次进入。*Synchronized* 也是可以重入的。每一个线程进入一次，那么锁计数器+1.直到计数器为0的时候才释放\n>\n> - *ReentrantLock* 采用 **JDK** 实现；*Synchronized*则是 **JVM** 实现的\n> - *Synchronized* 底层使用监视器（管程）实现，管程的本质就是操作系统的 *Mutex Lock*，需要牵涉到用户态和核心态的切换。 优化之前，性能比可重入锁差；\n> - *1.6* 之后引入了*Synchronized* 轻量级锁和偏向锁，也是默认开启的。此外还有自适应自旋锁的优化\n\n","source":"_posts/Java集合.md","raw":"---\ntitle: Java集合\ndate: 2020-03-14 17:26:21\ntags: 笔记\ncover_img: https://images.unsplash.com/photo-1496507161348-aeec0403f141?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80\ncover: https://images.unsplash.com/photo-1496507161348-aeec0403f141?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80\nfeature_img: https://images.unsplash.com/photo-1517958911667-09c05f6cd698?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80\ndescription:\nkeywords: 笔记\n---\n\n## Java 集合类整理\n\n> *JDK* 版本 **1.8**\n>\n> 本文章就最近看的一些jdk源码来进行总结，可能会比较简洁\n\n### 1. List 大类\n\n主要包含了 **ArrayList , Vector , LinkedList**\n\n#### 1.1 ArrayList\n\n> 基本思想：\n>\n> - 默认大小为 10 ，初始化的时候不进行对象数组空间分配，直到第一次 `add(E e)`\n> - 缓冲区满才进行扩容。扩容策略采取 *OldCapacity* * 1.5\n> - `remove` 不进行容量调整 (会有浪费)\n\n关键代码部分 `grow(int minCapacity)`\n\n```java\nprivate void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n}\nprivate static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n}\n```\n\n根据之前计算得到的 `minCapacity` , 进行 `ArrayList` 的扩容操作。如果计算得到的容量大于了 `MAX_ARRAY_SIZE = INT_MAX - 8` ，那么会直接扩容到 `Integer.MAX_VALUE` \n\n> 这里的 `MAX_ARRAY_SIZE` 设置为 `INT_MAX - 8` 主要是为了考虑到，有一些*JVM* 的对象数组 (这里是 `Object[] elementData`) 会采取一定长度的 *header* 。如果直接设置为 `INT_MAX` 可能会引发 OOM\n\n此外，可以看出 `ArrayList` 扩容其实是采取了复制的方法，将原来空间的所有数据放到了另一块空间。这种做法其实在复制上消耗特别大\n\n#### 1.2 Vector\n\n> 基本思想：\n>\n> - 和 `ArrayList` 颇为类似，它也是以10作为初始容量，初始化不分配对象数组的空间\n> - 扩容采取  *OldCapacity* * 2\n> - `remove` 不进行容量调整\n> - 线程安全 `synchronized`\n\n核心代码如下：\n\n```java\nprivate void grow(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = elementData.length;\n        int newCapacity = oldCapacity + ((capacityIncrement > 0) ?\n                                         capacityIncrement : oldCapacity);\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n> 这里的 `capacityIncrement` 是在初始化的时候可以额外指定的变量。如果指定了，那么就不进行乘以二扩容，而是每一次增加这个 `capacityIncrement` 变量\n\n#### 1.3 LinkedList\n\n> - 双向链表\n> - 内部额外存储头结点和尾结点\n\n### 2. KV 大类\n\n#### 2.1 HashMap\n\n> 面试里面最喜欢问的了，没有之一\n>\n> 主要几个流程：\n>\n> - `put`\n> - `get`\n> - `remove`\n>\n> 线程安全问题\n>\n> - put的时候导致的多线程数据不一致 \n>   - 两个线程前后写入，产生数据覆盖\n>   - 成环问题\n>\n> <img src=\"https://i.loli.net/2020/03/14/2WzkGAQVg9Rnpou.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n\n基本数据结构：\n\n- `class Node<K,V>` 是桶节点和链表节点的基本数据结构\n- `Node<K,V>[] table` 是哈希表内部的实现，其实就是 **链表数组**\n\n##### 2.1.1 put 添加 K,V 对\n\n1. 计算 `key` 的 `hashcode` 值，将对象的 `hashcode` 进行高16位和低16位的异或操作。可以看到， `HashMap` 支持对 `null` 键的处理\n\n```java\nstatic final int hash(Object key) {\n  int h;\n\treturn (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n2. `putValue` 主体部分\n\n在之前的 `hash` 获取之后，接下来一步就是进行哈希表的一个处理了，由于细节比较多，我直接在源代码里面加注释来解释了\n\n```java\n/**\n     * Implements Map.put and related methods.\n     *\n     * @param hash hash for key\n     * @param key the key\n     * @param value the value to put\n     * @param onlyIfAbsent if true, don't change existing value\n     * @param evict if false, the table is in creation mode.\n     * @return previous value, or null if none\n     */\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n      \t//如果tab没有初始化\n        if ((tab = table) == null || (n = tab.length) == 0)\n            //resize进行空间分配.\n          \tn = (tab = resize()).length;\n      \t//如果当前桶是空的 , 那么新建节点 , 直接插入\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        //当前桶已经有节点 , 需要在后面进行插入\n      \telse {\n            Node<K,V> e; K k;\n          \t//对于桶的第一个节点 p , 如果插入的点和第一个点 p 一样\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n          \t//如果是红黑树 , 就进行红黑树插入\n          \telse if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            //如果第一个节点不同 , 并且后面是链表\n          \telse {\n                  //遍历链表\n              \t\tfor (int binCount = 0; ; ++binCount) {\n \t\t\t\t\t\t\t\t\t\t//遇到空节点 , 表示可以插入 (1.7进行头插 , 1.8 进行尾插)         \n                    if ((e = p.next) == null) {\n                      \t//插入到尾端\n                        p.next = newNode(hash, key, value, null);\n                      \t//如果 binCount >= 8 - 1 (链表长度为8) , 就把链表转红黑树\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                  \t//如果遇到相同的节点\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\t // p = p.next\n                }\n            }\n          \t//如果这个键值对存在 , 就进行覆盖\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n      \t//如果map大小大于了阈值 , 再次进行 resize\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n有几个细节要提及：\n\n- `1.8` 中 , 链表和红黑树是交替使用的。\n  - 当链表长度达到了 **8** 之后，会转换为红黑树\n  - 当 `size` 是 **6** 之后，红黑树退化为链表\n  - 原因分析：\n    - 红黑树**平均**查询效率 O(logN) , 链表 O(N) / 2。在长度是 **8** 的时候，红黑树时间复杂度为 3 , 链表是 *8 / 2 = 4* 。这时候使用红黑树是效率更高的。而另一边退化的阈值设置为 **6** , 主要是中间有一个 **7** 的 *gap* , 从而避免红黑树和链表直接的频繁切换\n    - 当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件\n\n这里还有一个重要的调用函数 `resize()` 需要看一下\n\n```java\n// Cap 指的是哈希表中 , 链表数组的长度\n// Thr 指的是键值对的个数\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n  \t\t\t//阈值更新 (也就是整个哈希表的可容纳大小)\n        if (oldCap > 0) {\n          \t// 如果旧有oldCap很大 , 就把阈值设置为 Integer.MAX_VALUE\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n          \t//DEFAULT_INITIAL_CAPACITY = 16\n          \t//MAXIMUM_CAPACITY = 1 << 30\n          \t//如果 oldCap * 2 比 MAXIMUM_CAPACITY 小 , 那么阈值更新到 2 倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n  \t\t\t// 把新的链表数组长度设置为原来的 KV 对个数\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        // 对于初始化的情况\n  \t\t\t// 数组长度设置 16\n  \t\t\t// 阈值设置 0.75f * 16 = 12\n  \t\t\telse {\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n  \t\t\t//更新阈值 , 替换原有的哈希表. 数组长度为 newCap\n        threshold = newThr;\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n  \t\t\t//如果不是初始化的情形 , 需要进行rehash\n        if (oldTab != null) {\n          \t//遍历数组每一个桶\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n              \t//当前桶非空 , 需要进行rehash\n                if ((e = oldTab[j]) != null) {\n                  \t//原有桶清空\n                    oldTab[j] = null;\n                  \t//如果只有一个节点 , 直接再次计算hash , 填入就可以\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                  \t//如果是红黑树 , 那么红黑树的 split\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    //如果是链表\n                  \telse { // preserve order\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                          \t//获取next节点\n                            next = e.next;\n                          \t// e 作为前驱节点 , 同时记录下头节点和尾节点\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 低若干位 , 和原来的一致\n                            if ((e.hash & oldCap) == 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 插入到 loTail  , 进行尾插\n                              \tif (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                      \t//到这里 , 已经形成了单独的链表 \n                      \t//如果是低位 , 那么直接重新插入到原来的桶\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                      \t//插入到高位桶\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n\n#### 2.2 HashTable\n\n> 基本要点\n>\n> - 采用链表实现\n> - 线程安全 `synchronized`\n> - 默认的 Capacity (链表数组长度)是 **11** , 装载因子 0.75f\n> - *index* 计算：`index = (hash & 0x7FFFFFFF) % tab.length`\n> - 头插\n> - rehash的变化为 `newCapacity = (oldCapacity << 1) + 1`\n> - KV 不可以为空\n\n#### 2.3 LinkedHashMap\n\n这个类继承自 `HashMap`，内部维护了一个双向链表。这个链表可以决定迭代的遍历顺序\n\n在添加新节点的时候，将新节点链接在**内部双向链表的尾部**。\n\n`accessOrder=true`的模式下,在`afterNodeAccess()`函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。\n\n> 重点关注：afterNodeAccess()函数中，会修改modCount,因此当你正在accessOrder=true的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。\n\n#### 2.4 TreeMap\n\n> LinkedHashMap保证数据可以保持插入顺序\n>\n> 而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了\n\n内部采用了红黑树，并不是基于 **hash** 来进行实现的\n\n### 3. SET 大类\n\n#### 3.1 HashSet\n\n内部实现完全使用了 `HashMap`\n\n#### 3.2 TreeSet\n\n内部实现采用了 `TreeMap` ， 持有 `NavigableMap` 类型的引用\n\n### 4. 线程安全大类\n\n#### 4.1 ConcurrentHashMap\n\n> - *Key , Value* 不可以为空\n> - Hash计算如下 `(h ^ (h >>> 16)) & HASH_BITS`\n> - 链表 & 红黑树使用。链表进行尾插\n> - 链表和红黑树的临界值也是 **8**\n\n主要讲述一下和 *HashMap* 的不同\n\n##### Node定义\n\n在 *ConcurrentHashMap* 中，*Value,next* 都设置为了 `volatile` 内存可见\n\n```java\nprivate final Node<K,V>[] initTable() {\n        Node<K,V>[] tab; int sc;\n        while ((tab = table) == null || tab.length == 0) {\n            if ((sc = sizeCtl) < 0)\n                Thread.yield(); // lost initialization race; just spin\n          \t//CAS控制\n            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n                try {\n                    if ((tab = table) == null || tab.length == 0) {\n                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                        @SuppressWarnings(\"unchecked\")\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = tab = nt;\n                        sc = n - (n >>> 2);\n                    }\n                } finally {\n                    sizeCtl = sc;\n                }\n                break;\n            }\n        }\n        return tab;\n    }\n```\n\n**yield 和 sleep 的异同**\n\n1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。\n\n2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。\n\n3）yield 不能被中断，而 sleep 则可以接受中断。\n\n在 *1.8* 之前，采用了 **分段锁** ； 而 *1.8* 中主要使用了 **CAS** 和 **synchronized** 来进行并发控制\n\n**CAS** 没什么能说的，主要看一下分段锁 *Segment* \n\n这是一种 *ReentrantLock*，段的结构和 *HashMap* 类似，也是数组 + 链表。每一个段包含了 *HashEntry* 数组。当要对这个数组进行修改的时候，必须要先获得对应的锁(*Get*不需要获取锁，因为共享变量设置为了 `volatile`，除非读到的值是空的才会加锁重读)\n\n*volatile* 底层使用了**内存屏障**来加以完成，实现对内存操作的顺序控制。\n\n> *ReentrantLock* 可重入锁，表示已经获取到这个资源的线程，可以再次进入。*Synchronized* 也是可以重入的。每一个线程进入一次，那么锁计数器+1.直到计数器为0的时候才释放\n>\n> - *ReentrantLock* 采用 **JDK** 实现；*Synchronized*则是 **JVM** 实现的\n> - *Synchronized* 底层使用监视器（管程）实现，管程的本质就是操作系统的 *Mutex Lock*，需要牵涉到用户态和核心态的切换。 优化之前，性能比可重入锁差；\n> - *1.6* 之后引入了*Synchronized* 轻量级锁和偏向锁，也是默认开启的。此外还有自适应自旋锁的优化\n\n","slug":"Java集合","published":1,"updated":"2020-10-22T02:12:58.115Z","_id":"ckgk7k819001f06mefylxh90m","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"java-集合类整理\"><a class=\"markdownIt-Anchor\" href=\"#java-集合类整理\"></a> Java 集合类整理</h2>\n<blockquote>\n<p><em>JDK</em> 版本 <strong>1.8</strong></p>\n<p>本文章就最近看的一些jdk源码来进行总结，可能会比较简洁</p>\n</blockquote>\n<h3 id=\"1-list-大类\"><a class=\"markdownIt-Anchor\" href=\"#1-list-大类\"></a> 1. List 大类</h3>\n<p>主要包含了 <strong>ArrayList , Vector , LinkedList</strong></p>\n<h4 id=\"11-arraylist\"><a class=\"markdownIt-Anchor\" href=\"#11-arraylist\"></a> 1.1 ArrayList</h4>\n<blockquote>\n<p>基本思想：</p>\n<ul>\n<li>默认大小为 10 ，初始化的时候不进行对象数组空间分配，直到第一次 <code>add(E e)</code></li>\n<li>缓冲区满才进行扩容。扩容策略采取 <em>OldCapacity</em> * 1.5</li>\n<li><code>remove</code> 不进行容量调整 (会有浪费)</li>\n</ul>\n</blockquote>\n<p>关键代码部分 <code>grow(int minCapacity)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">            Integer.MAX_VALUE :</span><br><span class=\"line\">            MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据之前计算得到的 <code>minCapacity</code> , 进行 <code>ArrayList</code> 的扩容操作。如果计算得到的容量大于了 <code>MAX_ARRAY_SIZE = INT_MAX - 8</code> ，那么会直接扩容到 <code>Integer.MAX_VALUE</code></p>\n<blockquote>\n<p>这里的 <code>MAX_ARRAY_SIZE</code> 设置为 <code>INT_MAX - 8</code> 主要是为了考虑到，有一些<em>JVM</em> 的对象数组 (这里是 <code>Object[] elementData</code>) 会采取一定长度的 <em>header</em> 。如果直接设置为 <code>INT_MAX</code> 可能会引发 OOM</p>\n</blockquote>\n<p>此外，可以看出 <code>ArrayList</code> 扩容其实是采取了复制的方法，将原来空间的所有数据放到了另一块空间。这种做法其实在复制上消耗特别大</p>\n<h4 id=\"12-vector\"><a class=\"markdownIt-Anchor\" href=\"#12-vector\"></a> 1.2 Vector</h4>\n<blockquote>\n<p>基本思想：</p>\n<ul>\n<li>和 <code>ArrayList</code> 颇为类似，它也是以10作为初始容量，初始化不分配对象数组的空间</li>\n<li>扩容采取  <em>OldCapacity</em> * 2</li>\n<li><code>remove</code> 不进行容量调整</li>\n<li>线程安全 <code>synchronized</code></li>\n</ul>\n</blockquote>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class=\"number\">0</span>) ?</span><br><span class=\"line\">                                         capacityIncrement : oldCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里的 <code>capacityIncrement</code> 是在初始化的时候可以额外指定的变量。如果指定了，那么就不进行乘以二扩容，而是每一次增加这个 <code>capacityIncrement</code> 变量</p>\n</blockquote>\n<h4 id=\"13-linkedlist\"><a class=\"markdownIt-Anchor\" href=\"#13-linkedlist\"></a> 1.3 LinkedList</h4>\n<blockquote>\n<ul>\n<li>双向链表</li>\n<li>内部额外存储头结点和尾结点</li>\n</ul>\n</blockquote>\n<h3 id=\"2-kv-大类\"><a class=\"markdownIt-Anchor\" href=\"#2-kv-大类\"></a> 2. KV 大类</h3>\n<h4 id=\"21-hashmap\"><a class=\"markdownIt-Anchor\" href=\"#21-hashmap\"></a> 2.1 HashMap</h4>\n<blockquote>\n<p>面试里面最喜欢问的了，没有之一</p>\n<p>主要几个流程：</p>\n<ul>\n<li><code>put</code></li>\n<li><code>get</code></li>\n<li><code>remove</code></li>\n</ul>\n<p>线程安全问题</p>\n<ul>\n<li>put的时候导致的多线程数据不一致\n<ul>\n<li>两个线程前后写入，产生数据覆盖</li>\n<li>成环问题</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://i.loli.net/2020/03/14/2WzkGAQVg9Rnpou.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n</blockquote>\n<p>基本数据结构：</p>\n<ul>\n<li><code>class Node&lt;K,V&gt;</code> 是桶节点和链表节点的基本数据结构</li>\n<li><code>Node&lt;K,V&gt;[] table</code> 是哈希表内部的实现，其实就是 <strong>链表数组</strong></li>\n</ul>\n<h5 id=\"211-put-添加-kv-对\"><a class=\"markdownIt-Anchor\" href=\"#211-put-添加-kv-对\"></a> 2.1.1 put 添加 K,V 对</h5>\n<ol>\n<li>计算 <code>key</code> 的 <code>hashcode</code> 值，将对象的 <code>hashcode</code> 进行高16位和低16位的异或操作。可以看到， <code>HashMap</code> 支持对 <code>null</code> 键的处理</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><code>putValue</code> 主体部分</li>\n</ol>\n<p>在之前的 <code>hash</code> 获取之后，接下来一步就是进行哈希表的一个处理了，由于细节比较多，我直接在源代码里面加注释来解释了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Implements Map.put and related methods.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">      \t<span class=\"comment\">//如果tab没有初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//resize进行空间分配.</span></span><br><span class=\"line\">          \tn = (tab = resize()).length;</span><br><span class=\"line\">      \t<span class=\"comment\">//如果当前桶是空的 , 那么新建节点 , 直接插入</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//当前桶已经有节点 , 需要在后面进行插入</span></span><br><span class=\"line\">      \t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">          \t<span class=\"comment\">//对于桶的第一个节点 p , 如果插入的点和第一个点 p 一样</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">          \t<span class=\"comment\">//如果是红黑树 , 就进行红黑树插入</span></span><br><span class=\"line\">          \t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">            <span class=\"comment\">//如果第一个节点不同 , 并且后面是链表</span></span><br><span class=\"line\">          \t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                  <span class=\"comment\">//遍历链表</span></span><br><span class=\"line\">              \t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\"> \t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//遇到空节点 , 表示可以插入 (1.7进行头插 , 1.8 进行尾插)         </span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                      \t<span class=\"comment\">//插入到尾端</span></span><br><span class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                      \t<span class=\"comment\">//如果 binCount &gt;= 8 - 1 (链表长度为8) , 就把链表转红黑树</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                            treeifyBin(tab, hash);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                  \t<span class=\"comment\">//如果遇到相同的节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    p = e;\t <span class=\"comment\">// p = p.next</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          \t<span class=\"comment\">//如果这个键值对存在 , 就进行覆盖</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">                V oldValue = e.value;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                afterNodeAccess(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">      \t<span class=\"comment\">//如果map大小大于了阈值 , 再次进行 resize</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        afterNodeInsertion(evict);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>有几个细节要提及：</p>\n<ul>\n<li><code>1.8</code> 中 , 链表和红黑树是交替使用的。\n<ul>\n<li>当链表长度达到了 <strong>8</strong> 之后，会转换为红黑树</li>\n<li>当 <code>size</code> 是 <strong>6</strong> 之后，红黑树退化为链表</li>\n<li>原因分析：\n<ul>\n<li>红黑树<strong>平均</strong>查询效率 O(logN) , 链表 O(N) / 2。在长度是 <strong>8</strong> 的时候，红黑树时间复杂度为 3 , 链表是 <em>8 / 2 = 4</em> 。这时候使用红黑树是效率更高的。而另一边退化的阈值设置为 <strong>6</strong> , 主要是中间有一个 <strong>7</strong> 的 <em>gap</em> , 从而避免红黑树和链表直接的频繁切换</li>\n<li>当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>这里还有一个重要的调用函数 <code>resize()</code> 需要看一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Cap 指的是哈希表中 , 链表数组的长度</span></span><br><span class=\"line\"><span class=\"comment\">// Thr 指的是键值对的个数</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//阈值更新 (也就是整个哈希表的可容纳大小)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// 如果旧有oldCap很大 , 就把阈值设置为 Integer.MAX_VALUE</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          \t<span class=\"comment\">//DEFAULT_INITIAL_CAPACITY = 16</span></span><br><span class=\"line\">          \t<span class=\"comment\">//MAXIMUM_CAPACITY = 1 &lt;&lt; 30</span></span><br><span class=\"line\">          \t<span class=\"comment\">//如果 oldCap * 2 比 MAXIMUM_CAPACITY 小 , 那么阈值更新到 2 倍</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">// 把新的链表数组长度设置为原来的 KV 对个数</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">            newCap = oldThr;</span><br><span class=\"line\">        <span class=\"comment\">// 对于初始化的情况</span></span><br><span class=\"line\">  \t\t\t<span class=\"comment\">// 数组长度设置 16</span></span><br><span class=\"line\">  \t\t\t<span class=\"comment\">// 阈值设置 0.75f * 16 = 12</span></span><br><span class=\"line\">  \t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">            newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                      (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//更新阈值 , 替换原有的哈希表. 数组长度为 newCap</span></span><br><span class=\"line\">        threshold = newThr;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">        table = newTab;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//如果不是初始化的情形 , 需要进行rehash</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">//遍历数组每一个桶</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt; e;</span><br><span class=\"line\">              \t<span class=\"comment\">//当前桶非空 , 需要进行rehash</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  \t<span class=\"comment\">//原有桶清空</span></span><br><span class=\"line\">                    oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                  \t<span class=\"comment\">//如果只有一个节点 , 直接再次计算hash , 填入就可以</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                  \t<span class=\"comment\">//如果是红黑树 , 那么红黑树的 split</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                        ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                    <span class=\"comment\">//如果是链表</span></span><br><span class=\"line\">                  \t<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                        Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; next;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                          \t<span class=\"comment\">//获取next节点</span></span><br><span class=\"line\">                            next = e.next;</span><br><span class=\"line\">                          \t<span class=\"comment\">// e 作为前驱节点 , 同时记录下头节点和尾节点</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 低若干位 , 和原来的一致</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 插入到 loTail  , 进行尾插</span></span><br><span class=\"line\">                              \t<span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    loHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    loTail.next = e;</span><br><span class=\"line\">                                loTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    hiHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    hiTail.next = e;</span><br><span class=\"line\">                                hiTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                      \t<span class=\"comment\">//到这里 , 已经形成了单独的链表 </span></span><br><span class=\"line\">                      \t<span class=\"comment\">//如果是低位 , 那么直接重新插入到原来的桶</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j] = loHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                      \t<span class=\"comment\">//插入到高位桶</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"22-hashtable\"><a class=\"markdownIt-Anchor\" href=\"#22-hashtable\"></a> 2.2 HashTable</h4>\n<blockquote>\n<p>基本要点</p>\n<ul>\n<li>采用链表实现</li>\n<li>线程安全 <code>synchronized</code></li>\n<li>默认的 Capacity (链表数组长度)是 <strong>11</strong> , 装载因子 0.75f</li>\n<li><em>index</em> 计算：<code>index = (hash &amp; 0x7FFFFFFF) % tab.length</code></li>\n<li>头插</li>\n<li>rehash的变化为 <code>newCapacity = (oldCapacity &lt;&lt; 1) + 1</code></li>\n<li>KV 不可以为空</li>\n</ul>\n</blockquote>\n<h4 id=\"23-linkedhashmap\"><a class=\"markdownIt-Anchor\" href=\"#23-linkedhashmap\"></a> 2.3 LinkedHashMap</h4>\n<p>这个类继承自 <code>HashMap</code>，内部维护了一个双向链表。这个链表可以决定迭代的遍历顺序</p>\n<p>在添加新节点的时候，将新节点链接在<strong>内部双向链表的尾部</strong>。</p>\n<p><code>accessOrder=true</code>的模式下,在<code>afterNodeAccess()</code>函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。</p>\n<blockquote>\n<p>重点关注：afterNodeAccess()函数中，会修改modCount,因此当你正在accessOrder=true的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</p>\n</blockquote>\n<h4 id=\"24-treemap\"><a class=\"markdownIt-Anchor\" href=\"#24-treemap\"></a> 2.4 TreeMap</h4>\n<blockquote>\n<p>LinkedHashMap保证数据可以保持插入顺序</p>\n<p>而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了</p>\n</blockquote>\n<p>内部采用了红黑树，并不是基于 <strong>hash</strong> 来进行实现的</p>\n<h3 id=\"3-set-大类\"><a class=\"markdownIt-Anchor\" href=\"#3-set-大类\"></a> 3. SET 大类</h3>\n<h4 id=\"31-hashset\"><a class=\"markdownIt-Anchor\" href=\"#31-hashset\"></a> 3.1 HashSet</h4>\n<p>内部实现完全使用了 <code>HashMap</code></p>\n<h4 id=\"32-treeset\"><a class=\"markdownIt-Anchor\" href=\"#32-treeset\"></a> 3.2 TreeSet</h4>\n<p>内部实现采用了 <code>TreeMap</code> ， 持有 <code>NavigableMap</code> 类型的引用</p>\n<h3 id=\"4-线程安全大类\"><a class=\"markdownIt-Anchor\" href=\"#4-线程安全大类\"></a> 4. 线程安全大类</h3>\n<h4 id=\"41-concurrenthashmap\"><a class=\"markdownIt-Anchor\" href=\"#41-concurrenthashmap\"></a> 4.1 ConcurrentHashMap</h4>\n<blockquote>\n<ul>\n<li><em>Key , Value</em> 不可以为空</li>\n<li>Hash计算如下 <code>(h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS</code></li>\n<li>链表 &amp; 红黑树使用。链表进行尾插</li>\n<li>链表和红黑树的临界值也是 <strong>8</strong></li>\n</ul>\n</blockquote>\n<p>主要讲述一下和 <em>HashMap</em> 的不同</p>\n<h5 id=\"node定义\"><a class=\"markdownIt-Anchor\" href=\"#node定义\"></a> Node定义</h5>\n<p>在 <em>ConcurrentHashMap</em> 中，<em>Value,next</em> 都设置为了 <code>volatile</code> 内存可见</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                Thread.yield(); <span class=\"comment\">// lost initialization race; just spin</span></span><br><span class=\"line\">          \t<span class=\"comment\">//CAS控制</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> n = (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class=\"line\">                        <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n];</span><br><span class=\"line\">                        table = tab = nt;</span><br><span class=\"line\">                        sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    sizeCtl = sc;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>yield 和 sleep 的异同</strong></p>\n<p>1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。</p>\n<p>2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。</p>\n<p>3）yield 不能被中断，而 sleep 则可以接受中断。</p>\n<p>在 <em>1.8</em> 之前，采用了 <strong>分段锁</strong> ； 而 <em>1.8</em> 中主要使用了 <strong>CAS</strong> 和 <strong>synchronized</strong> 来进行并发控制</p>\n<p><strong>CAS</strong> 没什么能说的，主要看一下分段锁 <em>Segment</em></p>\n<p>这是一种 <em>ReentrantLock</em>，段的结构和 <em>HashMap</em> 类似，也是数组 + 链表。每一个段包含了 <em>HashEntry</em> 数组。当要对这个数组进行修改的时候，必须要先获得对应的锁(<em>Get</em>不需要获取锁，因为共享变量设置为了 <code>volatile</code>，除非读到的值是空的才会加锁重读)</p>\n<p><em>volatile</em> 底层使用了<strong>内存屏障</strong>来加以完成，实现对内存操作的顺序控制。</p>\n<blockquote>\n<p><em>ReentrantLock</em> 可重入锁，表示已经获取到这个资源的线程，可以再次进入。<em>Synchronized</em> 也是可以重入的。每一个线程进入一次，那么锁计数器+1.直到计数器为0的时候才释放</p>\n<ul>\n<li><em>ReentrantLock</em> 采用 <strong>JDK</strong> 实现；<em>Synchronized</em>则是 <strong>JVM</strong> 实现的</li>\n<li><em>Synchronized</em> 底层使用监视器（管程）实现，管程的本质就是操作系统的 <em>Mutex Lock</em>，需要牵涉到用户态和核心态的切换。 优化之前，性能比可重入锁差；</li>\n<li><em>1.6</em> 之后引入了<em>Synchronized</em> 轻量级锁和偏向锁，也是默认开启的。此外还有自适应自旋锁的优化</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"java-集合类整理\"><a class=\"markdownIt-Anchor\" href=\"#java-集合类整理\"></a> Java 集合类整理</h2>\n<blockquote>\n<p><em>JDK</em> 版本 <strong>1.8</strong></p>\n<p>本文章就最近看的一些jdk源码来进行总结，可能会比较简洁</p>\n</blockquote>\n<h3 id=\"1-list-大类\"><a class=\"markdownIt-Anchor\" href=\"#1-list-大类\"></a> 1. List 大类</h3>\n<p>主要包含了 <strong>ArrayList , Vector , LinkedList</strong></p>\n<h4 id=\"11-arraylist\"><a class=\"markdownIt-Anchor\" href=\"#11-arraylist\"></a> 1.1 ArrayList</h4>\n<blockquote>\n<p>基本思想：</p>\n<ul>\n<li>默认大小为 10 ，初始化的时候不进行对象数组空间分配，直到第一次 <code>add(E e)</code></li>\n<li>缓冲区满才进行扩容。扩容策略采取 <em>OldCapacity</em> * 1.5</li>\n<li><code>remove</code> 不进行容量调整 (会有浪费)</li>\n</ul>\n</blockquote>\n<p>关键代码部分 <code>grow(int minCapacity)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">            Integer.MAX_VALUE :</span><br><span class=\"line\">            MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据之前计算得到的 <code>minCapacity</code> , 进行 <code>ArrayList</code> 的扩容操作。如果计算得到的容量大于了 <code>MAX_ARRAY_SIZE = INT_MAX - 8</code> ，那么会直接扩容到 <code>Integer.MAX_VALUE</code></p>\n<blockquote>\n<p>这里的 <code>MAX_ARRAY_SIZE</code> 设置为 <code>INT_MAX - 8</code> 主要是为了考虑到，有一些<em>JVM</em> 的对象数组 (这里是 <code>Object[] elementData</code>) 会采取一定长度的 <em>header</em> 。如果直接设置为 <code>INT_MAX</code> 可能会引发 OOM</p>\n</blockquote>\n<p>此外，可以看出 <code>ArrayList</code> 扩容其实是采取了复制的方法，将原来空间的所有数据放到了另一块空间。这种做法其实在复制上消耗特别大</p>\n<h4 id=\"12-vector\"><a class=\"markdownIt-Anchor\" href=\"#12-vector\"></a> 1.2 Vector</h4>\n<blockquote>\n<p>基本思想：</p>\n<ul>\n<li>和 <code>ArrayList</code> 颇为类似，它也是以10作为初始容量，初始化不分配对象数组的空间</li>\n<li>扩容采取  <em>OldCapacity</em> * 2</li>\n<li><code>remove</code> 不进行容量调整</li>\n<li>线程安全 <code>synchronized</code></li>\n</ul>\n</blockquote>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class=\"number\">0</span>) ?</span><br><span class=\"line\">                                         capacityIncrement : oldCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = minCapacity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里的 <code>capacityIncrement</code> 是在初始化的时候可以额外指定的变量。如果指定了，那么就不进行乘以二扩容，而是每一次增加这个 <code>capacityIncrement</code> 变量</p>\n</blockquote>\n<h4 id=\"13-linkedlist\"><a class=\"markdownIt-Anchor\" href=\"#13-linkedlist\"></a> 1.3 LinkedList</h4>\n<blockquote>\n<ul>\n<li>双向链表</li>\n<li>内部额外存储头结点和尾结点</li>\n</ul>\n</blockquote>\n<h3 id=\"2-kv-大类\"><a class=\"markdownIt-Anchor\" href=\"#2-kv-大类\"></a> 2. KV 大类</h3>\n<h4 id=\"21-hashmap\"><a class=\"markdownIt-Anchor\" href=\"#21-hashmap\"></a> 2.1 HashMap</h4>\n<blockquote>\n<p>面试里面最喜欢问的了，没有之一</p>\n<p>主要几个流程：</p>\n<ul>\n<li><code>put</code></li>\n<li><code>get</code></li>\n<li><code>remove</code></li>\n</ul>\n<p>线程安全问题</p>\n<ul>\n<li>put的时候导致的多线程数据不一致\n<ul>\n<li>两个线程前后写入，产生数据覆盖</li>\n<li>成环问题</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://i.loli.net/2020/03/14/2WzkGAQVg9Rnpou.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n</blockquote>\n<p>基本数据结构：</p>\n<ul>\n<li><code>class Node&lt;K,V&gt;</code> 是桶节点和链表节点的基本数据结构</li>\n<li><code>Node&lt;K,V&gt;[] table</code> 是哈希表内部的实现，其实就是 <strong>链表数组</strong></li>\n</ul>\n<h5 id=\"211-put-添加-kv-对\"><a class=\"markdownIt-Anchor\" href=\"#211-put-添加-kv-对\"></a> 2.1.1 put 添加 K,V 对</h5>\n<ol>\n<li>计算 <code>key</code> 的 <code>hashcode</code> 值，将对象的 <code>hashcode</code> 进行高16位和低16位的异或操作。可以看到， <code>HashMap</code> 支持对 <code>null</code> 键的处理</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><code>putValue</code> 主体部分</li>\n</ol>\n<p>在之前的 <code>hash</code> 获取之后，接下来一步就是进行哈希表的一个处理了，由于细节比较多，我直接在源代码里面加注释来解释了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Implements Map.put and related methods.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> hash hash for key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> evict if false, the table is in creation mode.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">      \t<span class=\"comment\">//如果tab没有初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">//resize进行空间分配.</span></span><br><span class=\"line\">          \tn = (tab = resize()).length;</span><br><span class=\"line\">      \t<span class=\"comment\">//如果当前桶是空的 , 那么新建节点 , 直接插入</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//当前桶已经有节点 , 需要在后面进行插入</span></span><br><span class=\"line\">      \t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">          \t<span class=\"comment\">//对于桶的第一个节点 p , 如果插入的点和第一个点 p 一样</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">          \t<span class=\"comment\">//如果是红黑树 , 就进行红黑树插入</span></span><br><span class=\"line\">          \t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">            <span class=\"comment\">//如果第一个节点不同 , 并且后面是链表</span></span><br><span class=\"line\">          \t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                  <span class=\"comment\">//遍历链表</span></span><br><span class=\"line\">              \t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\"> \t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//遇到空节点 , 表示可以插入 (1.7进行头插 , 1.8 进行尾插)         </span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                      \t<span class=\"comment\">//插入到尾端</span></span><br><span class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                      \t<span class=\"comment\">//如果 binCount &gt;= 8 - 1 (链表长度为8) , 就把链表转红黑树</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                            treeifyBin(tab, hash);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                  \t<span class=\"comment\">//如果遇到相同的节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    p = e;\t <span class=\"comment\">// p = p.next</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          \t<span class=\"comment\">//如果这个键值对存在 , 就进行覆盖</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">                V oldValue = e.value;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                afterNodeAccess(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">      \t<span class=\"comment\">//如果map大小大于了阈值 , 再次进行 resize</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        afterNodeInsertion(evict);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>有几个细节要提及：</p>\n<ul>\n<li><code>1.8</code> 中 , 链表和红黑树是交替使用的。\n<ul>\n<li>当链表长度达到了 <strong>8</strong> 之后，会转换为红黑树</li>\n<li>当 <code>size</code> 是 <strong>6</strong> 之后，红黑树退化为链表</li>\n<li>原因分析：\n<ul>\n<li>红黑树<strong>平均</strong>查询效率 O(logN) , 链表 O(N) / 2。在长度是 <strong>8</strong> 的时候，红黑树时间复杂度为 3 , 链表是 <em>8 / 2 = 4</em> 。这时候使用红黑树是效率更高的。而另一边退化的阈值设置为 <strong>6</strong> , 主要是中间有一个 <strong>7</strong> 的 <em>gap</em> , 从而避免红黑树和链表直接的频繁切换</li>\n<li>当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>这里还有一个重要的调用函数 <code>resize()</code> 需要看一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Cap 指的是哈希表中 , 链表数组的长度</span></span><br><span class=\"line\"><span class=\"comment\">// Thr 指的是键值对的个数</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//阈值更新 (也就是整个哈希表的可容纳大小)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// 如果旧有oldCap很大 , 就把阈值设置为 Integer.MAX_VALUE</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          \t<span class=\"comment\">//DEFAULT_INITIAL_CAPACITY = 16</span></span><br><span class=\"line\">          \t<span class=\"comment\">//MAXIMUM_CAPACITY = 1 &lt;&lt; 30</span></span><br><span class=\"line\">          \t<span class=\"comment\">//如果 oldCap * 2 比 MAXIMUM_CAPACITY 小 , 那么阈值更新到 2 倍</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">// 把新的链表数组长度设置为原来的 KV 对个数</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">            newCap = oldThr;</span><br><span class=\"line\">        <span class=\"comment\">// 对于初始化的情况</span></span><br><span class=\"line\">  \t\t\t<span class=\"comment\">// 数组长度设置 16</span></span><br><span class=\"line\">  \t\t\t<span class=\"comment\">// 阈值设置 0.75f * 16 = 12</span></span><br><span class=\"line\">  \t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">            newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                      (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//更新阈值 , 替换原有的哈希表. 数组长度为 newCap</span></span><br><span class=\"line\">        threshold = newThr;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">        table = newTab;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//如果不是初始化的情形 , 需要进行rehash</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">//遍历数组每一个桶</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt; e;</span><br><span class=\"line\">              \t<span class=\"comment\">//当前桶非空 , 需要进行rehash</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  \t<span class=\"comment\">//原有桶清空</span></span><br><span class=\"line\">                    oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                  \t<span class=\"comment\">//如果只有一个节点 , 直接再次计算hash , 填入就可以</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                  \t<span class=\"comment\">//如果是红黑树 , 那么红黑树的 split</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                        ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                    <span class=\"comment\">//如果是链表</span></span><br><span class=\"line\">                  \t<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                        Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; next;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                          \t<span class=\"comment\">//获取next节点</span></span><br><span class=\"line\">                            next = e.next;</span><br><span class=\"line\">                          \t<span class=\"comment\">// e 作为前驱节点 , 同时记录下头节点和尾节点</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 低若干位 , 和原来的一致</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 插入到 loTail  , 进行尾插</span></span><br><span class=\"line\">                              \t<span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    loHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    loTail.next = e;</span><br><span class=\"line\">                                loTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                    hiHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    hiTail.next = e;</span><br><span class=\"line\">                                hiTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                      \t<span class=\"comment\">//到这里 , 已经形成了单独的链表 </span></span><br><span class=\"line\">                      \t<span class=\"comment\">//如果是低位 , 那么直接重新插入到原来的桶</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j] = loHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                      \t<span class=\"comment\">//插入到高位桶</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"22-hashtable\"><a class=\"markdownIt-Anchor\" href=\"#22-hashtable\"></a> 2.2 HashTable</h4>\n<blockquote>\n<p>基本要点</p>\n<ul>\n<li>采用链表实现</li>\n<li>线程安全 <code>synchronized</code></li>\n<li>默认的 Capacity (链表数组长度)是 <strong>11</strong> , 装载因子 0.75f</li>\n<li><em>index</em> 计算：<code>index = (hash &amp; 0x7FFFFFFF) % tab.length</code></li>\n<li>头插</li>\n<li>rehash的变化为 <code>newCapacity = (oldCapacity &lt;&lt; 1) + 1</code></li>\n<li>KV 不可以为空</li>\n</ul>\n</blockquote>\n<h4 id=\"23-linkedhashmap\"><a class=\"markdownIt-Anchor\" href=\"#23-linkedhashmap\"></a> 2.3 LinkedHashMap</h4>\n<p>这个类继承自 <code>HashMap</code>，内部维护了一个双向链表。这个链表可以决定迭代的遍历顺序</p>\n<p>在添加新节点的时候，将新节点链接在<strong>内部双向链表的尾部</strong>。</p>\n<p><code>accessOrder=true</code>的模式下,在<code>afterNodeAccess()</code>函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。</p>\n<blockquote>\n<p>重点关注：afterNodeAccess()函数中，会修改modCount,因此当你正在accessOrder=true的模式下,迭代LinkedHashMap时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</p>\n</blockquote>\n<h4 id=\"24-treemap\"><a class=\"markdownIt-Anchor\" href=\"#24-treemap\"></a> 2.4 TreeMap</h4>\n<blockquote>\n<p>LinkedHashMap保证数据可以保持插入顺序</p>\n<p>而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了</p>\n</blockquote>\n<p>内部采用了红黑树，并不是基于 <strong>hash</strong> 来进行实现的</p>\n<h3 id=\"3-set-大类\"><a class=\"markdownIt-Anchor\" href=\"#3-set-大类\"></a> 3. SET 大类</h3>\n<h4 id=\"31-hashset\"><a class=\"markdownIt-Anchor\" href=\"#31-hashset\"></a> 3.1 HashSet</h4>\n<p>内部实现完全使用了 <code>HashMap</code></p>\n<h4 id=\"32-treeset\"><a class=\"markdownIt-Anchor\" href=\"#32-treeset\"></a> 3.2 TreeSet</h4>\n<p>内部实现采用了 <code>TreeMap</code> ， 持有 <code>NavigableMap</code> 类型的引用</p>\n<h3 id=\"4-线程安全大类\"><a class=\"markdownIt-Anchor\" href=\"#4-线程安全大类\"></a> 4. 线程安全大类</h3>\n<h4 id=\"41-concurrenthashmap\"><a class=\"markdownIt-Anchor\" href=\"#41-concurrenthashmap\"></a> 4.1 ConcurrentHashMap</h4>\n<blockquote>\n<ul>\n<li><em>Key , Value</em> 不可以为空</li>\n<li>Hash计算如下 <code>(h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS</code></li>\n<li>链表 &amp; 红黑树使用。链表进行尾插</li>\n<li>链表和红黑树的临界值也是 <strong>8</strong></li>\n</ul>\n</blockquote>\n<p>主要讲述一下和 <em>HashMap</em> 的不同</p>\n<h5 id=\"node定义\"><a class=\"markdownIt-Anchor\" href=\"#node定义\"></a> Node定义</h5>\n<p>在 <em>ConcurrentHashMap</em> 中，<em>Value,next</em> 都设置为了 <code>volatile</code> 内存可见</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                Thread.yield(); <span class=\"comment\">// lost initialization race; just spin</span></span><br><span class=\"line\">          \t<span class=\"comment\">//CAS控制</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> n = (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class=\"line\">                        <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n];</span><br><span class=\"line\">                        table = tab = nt;</span><br><span class=\"line\">                        sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    sizeCtl = sc;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>yield 和 sleep 的异同</strong></p>\n<p>1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。</p>\n<p>2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。</p>\n<p>3）yield 不能被中断，而 sleep 则可以接受中断。</p>\n<p>在 <em>1.8</em> 之前，采用了 <strong>分段锁</strong> ； 而 <em>1.8</em> 中主要使用了 <strong>CAS</strong> 和 <strong>synchronized</strong> 来进行并发控制</p>\n<p><strong>CAS</strong> 没什么能说的，主要看一下分段锁 <em>Segment</em></p>\n<p>这是一种 <em>ReentrantLock</em>，段的结构和 <em>HashMap</em> 类似，也是数组 + 链表。每一个段包含了 <em>HashEntry</em> 数组。当要对这个数组进行修改的时候，必须要先获得对应的锁(<em>Get</em>不需要获取锁，因为共享变量设置为了 <code>volatile</code>，除非读到的值是空的才会加锁重读)</p>\n<p><em>volatile</em> 底层使用了<strong>内存屏障</strong>来加以完成，实现对内存操作的顺序控制。</p>\n<blockquote>\n<p><em>ReentrantLock</em> 可重入锁，表示已经获取到这个资源的线程，可以再次进入。<em>Synchronized</em> 也是可以重入的。每一个线程进入一次，那么锁计数器+1.直到计数器为0的时候才释放</p>\n<ul>\n<li><em>ReentrantLock</em> 采用 <strong>JDK</strong> 实现；<em>Synchronized</em>则是 <strong>JVM</strong> 实现的</li>\n<li><em>Synchronized</em> 底层使用监视器（管程）实现，管程的本质就是操作系统的 <em>Mutex Lock</em>，需要牵涉到用户态和核心态的切换。 优化之前，性能比可重入锁差；</li>\n<li><em>1.6</em> 之后引入了<em>Synchronized</em> 轻量级锁和偏向锁，也是默认开启的。此外还有自适应自旋锁的优化</li>\n</ul>\n</blockquote>\n"},{"title":"论文笔记-FlexSC","date":"2020-12-03T02:35:50.000Z","cover":"https://images.unsplash.com/photo-1601758282715-6446bbde7082?ixid=MXwxMjA3fDF8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1253&q=80","description":"FlexSC","keywords":null,"_content":"\n### 1. 概述\n\n系统调用采用同步的机制，在用户态转移到内核态的过程中，需要把当前上下文保存，但是其中的模式切换成本，与间接的处理器上下文数据污染（影响局部性 *locality*），会对系统调用造成比较大的负面影响\n\n![image.png](https://i.loli.net/2020/12/20/5jrZnDoWebTua9s.png)\n\n文中给出的 *proposal* : ***exception-less system call***，在请求内核服务时，不需要使用同步处理器异常。实现过程中，(*invocation stage*)系统调用通过把内核请求，以普通的内存存储操作写入到一个预留的系统调用页 (*syscall page*)。(*execution stage*)随后的系统调用执行采用 **异步** 的方式 (*special in-kernel **syscall threads***) ，将结果异步载入 *syscall page*\n\n从上可以看出，它其实是把 **invocation** 和 **execution** 解耦。一方面可以在执行流上保证<u>时间的局部性</u>；另一方面能够让 *syscall* 独立运行在一个core上，与 *user mode threads* 隔离，保证每一个core内的<u>空间局部性</u>\n\n与此同时，有一个很关键的 **动态核特化** (*dynamic core specialization*)概念——也就是core可以根据当前OS的*workload*，动态调整某一个core是进行用户态 / 内核态的工作。为了减轻编程负担，给出了一个 ***M-on-N*** 的线程模型(*M*个用户态线程，执行于 *N* 个内核可见的线程) 。关于POSIX线程模型，参见[POSIX线程模型](https://www.yuque.com/barret/giv6pv/ogmd8f)\n\n\n\n### 2. cost of system-call\n\n#### 2.1 模式切换cost\n\n时间损耗发生于：用户态下必要的syscall调用、执行权转交给内核的执行、执行权反交给用户态。现代处理器通过处理器异常来做这个模式切换，切换时会将用户模式下的指令流水线清空、将CPU上下文保存入栈、改变 *protection domain*、重定向到异常处理*handler*\n\n> 这里对 *protection domain* 不是特别理解，详见 [Lampson: Protection Models](https://zhuanlan.zhihu.com/p/59796446)。可以和chcore中的pmo-cap关联起来看，个人理解为一个资源的句柄域，由于内核态和用户态的 *domain* 不同(可以使用的资源范围)，故需要在这里进行*domain* 的改变\n\n\n\n#### 2.2 系统调用cost\n\n处理器状态污染：\n\n进入内核态执行时，处理器的L1缓存数据、指令缓存、TLB、分支预测表，以及L2缓存，都会因为系统调用而被污染，从而在返回用户态之后，极大地影响用户态程序执行速度\n\n![image.png](https://i.loli.net/2020/12/20/vfRDmGitJOsWB6F.png)\n\n\n\n#### 2.3 返回用户态执行cost\n\n> 衡量指标：IPC (*instructions per cycle*)\n\n理想状态下，用户模式下的*IPC* 应当不变化。但是实际实验中，有如下的几个影响因素。\n\n**直接影响**：系统调用关联的异常，将处理器执行流水线清空\n\n**间接影响**：处理器状态污染\n\n\n\n<img src=\"https://i.loli.net/2020/12/20/vFbzLq7xU2ZRiAH.png\" alt=\"image.png\" style=\"zoom: 67%;\" />\n\n实验结果解读：\n\n1. 横轴表示syscall的一个频率，纵轴表示 $1-\\frac{IPC_{user}}{IPC_{base}}$。从这里可以看出，在per-1K条指令一次系统调用的情况下，会造成比较大的损耗。\n2. 使用空的syscall来评估系统调用带来的 *direct* 影响，使用一个 *pwrite* 调用来评估系统调用带来的 *indirect* 影响。可以看出，在syscall频繁的时候(1K)，直接影响占据主导；而当syscall不频繁时，间接影响占据主导\n\n\n\n IPC受syscall频率的影响。可以见到，当系统调用频繁时，内核的状态也能够比较好地被保持。由此看出syscall对 user / kernel mode均会造成局部性的影响\n\n<img src=\"https://i.loli.net/2020/12/20/qDFpQv7kRSaLEnd.png\" alt=\"image.png\" style=\"zoom:67%;\" />\n\n\n\n### 3. Exception-Less system call\n\n> 提供灵活的系统调用执行调度，进而提升用户 / 内核态下的局部性\n\n在两个方面下功夫：\n\n- *System call batching* : 延缓systemcall的执行，让他们以一个batch来一起执行\n- *Core specialization* : 内核特化，*execution* / *invoke* 分开于不同的core上执行\n\n#### 3.1 Exception-Less syscall接口\n\n通过一个 user-kernel共享的内存页支持(*syscall page*)，包含了syscall入口，关联到请求状态、系统调用号、入参、出参\n\n在调用一个exception-less syscall，用户态的线程会找到 *syscall page*内的一个空闲*entry*，将系统调用相关的数据写入。之后用户态线程可以继续执行，不被中断。用户线程后续会读取*entry*中的执行状态，校验系统调用是否已经完成。这些操作中，用户线程不需要通过*exception* \n\n*syscall page* 中的每一个*entry* 结构如下：\n\n> 64-bit系统中，每一个 *entry* 占用 **64 bytes**\n\n![image.png](https://i.loli.net/2020/12/20/Nv5WgtnKT8qSreu.png)\n\n在调用 *exception-less syscall* 时，用户线程需要找到一个 *status = free* 的 *entry*，随后将必要的参数写入到这个入口。写入完成后，*status* 置为 *submitted* 。随后用户线程可以执行自己的代码，后续需要check这个*status* 是否为 *done*，表明系统调用是否完成。若完成，那么用户线程设置 *status* 为 *free*\n\n> ==Question== : 这里会不会有并发问题？ 当一个线程正在write argument，另一个用户线程发现 *status = free*，那么也会进行write argument。这时候会有race ？\n\n\n\n#### 3.2 执行、调用解耦\n\n不同于 *exception-based syscall* ，*exception-less syscall* 采用一种 **异步** 的策略，调用时，用户线程写入 *syscall page*；执行*syscall* 时，***syscall thread*** (必在内核态) 从 *syscall page* 拉取系统调用请求\n\n<img src=\"https://i.loli.net/2020/12/20/2F4gn3JqKUo1pGX.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n\n- 用户线程只在无法进行更多的执行，才会唤醒系统调用线程(*syscall thread*) ——保证时间局部性\n- 系统调用线程可以被调度——保证空间局部性\n\n\n\n#### 3.3 FlexSC\n\n> *exception-less syscall* 的具体实现实践\n\n给出两个新的linux系统调用：\n\n- **flexsc_register()** \n\n在进程初始化的时候**显式**调用，是 *exception-based* 的。由于只需要执行一次，对性能的影响可以忽略\n\n这个系统调用做了两件事：将若干 *syscall pages* 映射至用户虚存空间、为每一个 *entry* 产生一个 *syscall thread*\n\n\n\n- **flexsc_wait()**\n\n对于传统的同步系统调用，用户线程只需要简单地进行 *sleep* ，等待*syscall* 执行完毕。当前的执行模式中，用户线程会显示地与内核 *communicate*，告知自己无法进行进一步的执行，直到调用的*syscall* 已经完成。这一个函数调用是 *exception-based* ，调用过后能够在至少一个syscall完成后，唤醒用户空间的线程\n\n\n\n#### 3.4 syscall thread\n\n之前说到，**syscall thread** 从 *syscall pages* 拉取请求。\n\n在 *flexsc_register()* 阶段，*syscall thread* 从注册的进程中克隆得到，他们也就拥有相同的虚拟地址空间。这一点能够让后续的数据迁移变得容易(不需要重新定义虚存映射)\n\n针对每一个entry，都会在kernel mode创建一个 *syscall thread*。但是只有一个 *syscall thread* (per core) 是处于active状态。当系统调用线程需要立即阻塞时，FlexSC会notify工作队列，使另一个线程wake up，立即开始执行下一个 *syscall*。 当资源空闲时，当前的Linux代码会唤醒等待的线程，并恢复其执行\n\n\n\n#### 3.5 syscall thread调度器\n\n单核：\n\n调度器假设用户空间会尝试调用尽可能多的*syscall*，调度器随后会唤醒其中的一个空闲 *syscall thread*，用来执行第一个 *syscall*。\n\n- 如果这个系统调用不会被阻塞，那么当前的 *syscall thread* 会继续执行下一个 *syscall*\n- 如果会被阻塞，那么阻塞时，调度器会唤醒下一个 *syscall thread*，来执行下一个系统调用\n\n调度器不会唤醒用户线程，直到所有的系统调用已经被 *issued*，\n\n\n\n多核：\n\n通过尝试使用预定义的静态core list调度。\n\n- 选择*list*中的第一个核，如果某个进程的系统调用线程当前正在该核上运行，则选择列表中下一个核\n- 如果所core当前未执行系统调用线程，则将处理器间中断发送到core，以表明它必须唤醒系统调用线程\n\n每一个core上只能同时运行一个进程的*syscall thread*，但是之前的问题也提到了一个并发竞争问题。这里通过对 page 加锁来避免并发的问题，直到所有 *submitted* 系统调用请求都被发出了才进行解锁\n\n\n\n\n\n### 4. FlexSC - Threads\n\n*Exception-less syscall* 更加类似于 **事件驱动** 模型，能够让IO相关的操作在未来执行，并且能够请求、验证完成、处理任何系统调用\n\n文中着重探讨了实现 ***FlexSC-Threads***，一个 $M-on-N$ 线程模型。依赖于仅在用户空间中进行线程切换的能力，来让同步系统调用透明地转变为 *exception-less syscall*。\n\n\n\n*FlexSC-Threads* 工作流程如下：\n\n1. 将每个libc调用重定向到我们的库。 通常应用程序不直接嵌入代码以发出系统调用，而是在**动态加载**的libc中调用包装器，故采用Linux的动态加载功能将此类调用的执行重定向到我们的库\n2. 随后将对应的 *exception-less syscall* 写入到 *syscall page*，切换至另一个就绪的用户线程\n3. 如果没有就绪用户线程，那么*FlexSC*检查那些 *status = completed* 的 *syscall page*，将对应的线程唤醒，来获取系统调用完成后的*result*\n4. 当所有的用户线程都等待系统调用，FlexSC Thread lib将调用**flexsc_wait()**，使内核可见线程进入睡眠状态，直到一个挂起的系统调用完成。\n\n多核环境下的每一个进程，为每一个core建立一个内核可见线程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/论文笔记-FlexSC.md","raw":"---\ntitle: 论文笔记-FlexSC\ndate: 2020-12-03 10:35:50\ntags:\ncover: https://images.unsplash.com/photo-1601758282715-6446bbde7082?ixid=MXwxMjA3fDF8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1253&q=80\ndescription: FlexSC\nkeywords:\n---\n\n### 1. 概述\n\n系统调用采用同步的机制，在用户态转移到内核态的过程中，需要把当前上下文保存，但是其中的模式切换成本，与间接的处理器上下文数据污染（影响局部性 *locality*），会对系统调用造成比较大的负面影响\n\n![image.png](https://i.loli.net/2020/12/20/5jrZnDoWebTua9s.png)\n\n文中给出的 *proposal* : ***exception-less system call***，在请求内核服务时，不需要使用同步处理器异常。实现过程中，(*invocation stage*)系统调用通过把内核请求，以普通的内存存储操作写入到一个预留的系统调用页 (*syscall page*)。(*execution stage*)随后的系统调用执行采用 **异步** 的方式 (*special in-kernel **syscall threads***) ，将结果异步载入 *syscall page*\n\n从上可以看出，它其实是把 **invocation** 和 **execution** 解耦。一方面可以在执行流上保证<u>时间的局部性</u>；另一方面能够让 *syscall* 独立运行在一个core上，与 *user mode threads* 隔离，保证每一个core内的<u>空间局部性</u>\n\n与此同时，有一个很关键的 **动态核特化** (*dynamic core specialization*)概念——也就是core可以根据当前OS的*workload*，动态调整某一个core是进行用户态 / 内核态的工作。为了减轻编程负担，给出了一个 ***M-on-N*** 的线程模型(*M*个用户态线程，执行于 *N* 个内核可见的线程) 。关于POSIX线程模型，参见[POSIX线程模型](https://www.yuque.com/barret/giv6pv/ogmd8f)\n\n\n\n### 2. cost of system-call\n\n#### 2.1 模式切换cost\n\n时间损耗发生于：用户态下必要的syscall调用、执行权转交给内核的执行、执行权反交给用户态。现代处理器通过处理器异常来做这个模式切换，切换时会将用户模式下的指令流水线清空、将CPU上下文保存入栈、改变 *protection domain*、重定向到异常处理*handler*\n\n> 这里对 *protection domain* 不是特别理解，详见 [Lampson: Protection Models](https://zhuanlan.zhihu.com/p/59796446)。可以和chcore中的pmo-cap关联起来看，个人理解为一个资源的句柄域，由于内核态和用户态的 *domain* 不同(可以使用的资源范围)，故需要在这里进行*domain* 的改变\n\n\n\n#### 2.2 系统调用cost\n\n处理器状态污染：\n\n进入内核态执行时，处理器的L1缓存数据、指令缓存、TLB、分支预测表，以及L2缓存，都会因为系统调用而被污染，从而在返回用户态之后，极大地影响用户态程序执行速度\n\n![image.png](https://i.loli.net/2020/12/20/vfRDmGitJOsWB6F.png)\n\n\n\n#### 2.3 返回用户态执行cost\n\n> 衡量指标：IPC (*instructions per cycle*)\n\n理想状态下，用户模式下的*IPC* 应当不变化。但是实际实验中，有如下的几个影响因素。\n\n**直接影响**：系统调用关联的异常，将处理器执行流水线清空\n\n**间接影响**：处理器状态污染\n\n\n\n<img src=\"https://i.loli.net/2020/12/20/vFbzLq7xU2ZRiAH.png\" alt=\"image.png\" style=\"zoom: 67%;\" />\n\n实验结果解读：\n\n1. 横轴表示syscall的一个频率，纵轴表示 $1-\\frac{IPC_{user}}{IPC_{base}}$。从这里可以看出，在per-1K条指令一次系统调用的情况下，会造成比较大的损耗。\n2. 使用空的syscall来评估系统调用带来的 *direct* 影响，使用一个 *pwrite* 调用来评估系统调用带来的 *indirect* 影响。可以看出，在syscall频繁的时候(1K)，直接影响占据主导；而当syscall不频繁时，间接影响占据主导\n\n\n\n IPC受syscall频率的影响。可以见到，当系统调用频繁时，内核的状态也能够比较好地被保持。由此看出syscall对 user / kernel mode均会造成局部性的影响\n\n<img src=\"https://i.loli.net/2020/12/20/qDFpQv7kRSaLEnd.png\" alt=\"image.png\" style=\"zoom:67%;\" />\n\n\n\n### 3. Exception-Less system call\n\n> 提供灵活的系统调用执行调度，进而提升用户 / 内核态下的局部性\n\n在两个方面下功夫：\n\n- *System call batching* : 延缓systemcall的执行，让他们以一个batch来一起执行\n- *Core specialization* : 内核特化，*execution* / *invoke* 分开于不同的core上执行\n\n#### 3.1 Exception-Less syscall接口\n\n通过一个 user-kernel共享的内存页支持(*syscall page*)，包含了syscall入口，关联到请求状态、系统调用号、入参、出参\n\n在调用一个exception-less syscall，用户态的线程会找到 *syscall page*内的一个空闲*entry*，将系统调用相关的数据写入。之后用户态线程可以继续执行，不被中断。用户线程后续会读取*entry*中的执行状态，校验系统调用是否已经完成。这些操作中，用户线程不需要通过*exception* \n\n*syscall page* 中的每一个*entry* 结构如下：\n\n> 64-bit系统中，每一个 *entry* 占用 **64 bytes**\n\n![image.png](https://i.loli.net/2020/12/20/Nv5WgtnKT8qSreu.png)\n\n在调用 *exception-less syscall* 时，用户线程需要找到一个 *status = free* 的 *entry*，随后将必要的参数写入到这个入口。写入完成后，*status* 置为 *submitted* 。随后用户线程可以执行自己的代码，后续需要check这个*status* 是否为 *done*，表明系统调用是否完成。若完成，那么用户线程设置 *status* 为 *free*\n\n> ==Question== : 这里会不会有并发问题？ 当一个线程正在write argument，另一个用户线程发现 *status = free*，那么也会进行write argument。这时候会有race ？\n\n\n\n#### 3.2 执行、调用解耦\n\n不同于 *exception-based syscall* ，*exception-less syscall* 采用一种 **异步** 的策略，调用时，用户线程写入 *syscall page*；执行*syscall* 时，***syscall thread*** (必在内核态) 从 *syscall page* 拉取系统调用请求\n\n<img src=\"https://i.loli.net/2020/12/20/2F4gn3JqKUo1pGX.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n\n- 用户线程只在无法进行更多的执行，才会唤醒系统调用线程(*syscall thread*) ——保证时间局部性\n- 系统调用线程可以被调度——保证空间局部性\n\n\n\n#### 3.3 FlexSC\n\n> *exception-less syscall* 的具体实现实践\n\n给出两个新的linux系统调用：\n\n- **flexsc_register()** \n\n在进程初始化的时候**显式**调用，是 *exception-based* 的。由于只需要执行一次，对性能的影响可以忽略\n\n这个系统调用做了两件事：将若干 *syscall pages* 映射至用户虚存空间、为每一个 *entry* 产生一个 *syscall thread*\n\n\n\n- **flexsc_wait()**\n\n对于传统的同步系统调用，用户线程只需要简单地进行 *sleep* ，等待*syscall* 执行完毕。当前的执行模式中，用户线程会显示地与内核 *communicate*，告知自己无法进行进一步的执行，直到调用的*syscall* 已经完成。这一个函数调用是 *exception-based* ，调用过后能够在至少一个syscall完成后，唤醒用户空间的线程\n\n\n\n#### 3.4 syscall thread\n\n之前说到，**syscall thread** 从 *syscall pages* 拉取请求。\n\n在 *flexsc_register()* 阶段，*syscall thread* 从注册的进程中克隆得到，他们也就拥有相同的虚拟地址空间。这一点能够让后续的数据迁移变得容易(不需要重新定义虚存映射)\n\n针对每一个entry，都会在kernel mode创建一个 *syscall thread*。但是只有一个 *syscall thread* (per core) 是处于active状态。当系统调用线程需要立即阻塞时，FlexSC会notify工作队列，使另一个线程wake up，立即开始执行下一个 *syscall*。 当资源空闲时，当前的Linux代码会唤醒等待的线程，并恢复其执行\n\n\n\n#### 3.5 syscall thread调度器\n\n单核：\n\n调度器假设用户空间会尝试调用尽可能多的*syscall*，调度器随后会唤醒其中的一个空闲 *syscall thread*，用来执行第一个 *syscall*。\n\n- 如果这个系统调用不会被阻塞，那么当前的 *syscall thread* 会继续执行下一个 *syscall*\n- 如果会被阻塞，那么阻塞时，调度器会唤醒下一个 *syscall thread*，来执行下一个系统调用\n\n调度器不会唤醒用户线程，直到所有的系统调用已经被 *issued*，\n\n\n\n多核：\n\n通过尝试使用预定义的静态core list调度。\n\n- 选择*list*中的第一个核，如果某个进程的系统调用线程当前正在该核上运行，则选择列表中下一个核\n- 如果所core当前未执行系统调用线程，则将处理器间中断发送到core，以表明它必须唤醒系统调用线程\n\n每一个core上只能同时运行一个进程的*syscall thread*，但是之前的问题也提到了一个并发竞争问题。这里通过对 page 加锁来避免并发的问题，直到所有 *submitted* 系统调用请求都被发出了才进行解锁\n\n\n\n\n\n### 4. FlexSC - Threads\n\n*Exception-less syscall* 更加类似于 **事件驱动** 模型，能够让IO相关的操作在未来执行，并且能够请求、验证完成、处理任何系统调用\n\n文中着重探讨了实现 ***FlexSC-Threads***，一个 $M-on-N$ 线程模型。依赖于仅在用户空间中进行线程切换的能力，来让同步系统调用透明地转变为 *exception-less syscall*。\n\n\n\n*FlexSC-Threads* 工作流程如下：\n\n1. 将每个libc调用重定向到我们的库。 通常应用程序不直接嵌入代码以发出系统调用，而是在**动态加载**的libc中调用包装器，故采用Linux的动态加载功能将此类调用的执行重定向到我们的库\n2. 随后将对应的 *exception-less syscall* 写入到 *syscall page*，切换至另一个就绪的用户线程\n3. 如果没有就绪用户线程，那么*FlexSC*检查那些 *status = completed* 的 *syscall page*，将对应的线程唤醒，来获取系统调用完成后的*result*\n4. 当所有的用户线程都等待系统调用，FlexSC Thread lib将调用**flexsc_wait()**，使内核可见线程进入睡眠状态，直到一个挂起的系统调用完成。\n\n多核环境下的每一个进程，为每一个core建立一个内核可见线程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"论文笔记-FlexSC","published":1,"updated":"2020-12-20T07:53:17.225Z","_id":"cki889m8m0000fimeg0jp2bya","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-概述\"><a class=\"markdownIt-Anchor\" href=\"#1-概述\"></a> 1. 概述</h3>\n<p>系统调用采用同步的机制，在用户态转移到内核态的过程中，需要把当前上下文保存，但是其中的模式切换成本，与间接的处理器上下文数据污染（影响局部性 <em>locality</em>），会对系统调用造成比较大的负面影响</p>\n<p><img src=\"https://i.loli.net/2020/12/20/5jrZnDoWebTua9s.png\" alt=\"image.png\" /></p>\n<p>文中给出的 <em>proposal</em> : <em><strong>exception-less system call</strong></em>，在请求内核服务时，不需要使用同步处理器异常。实现过程中，(<em>invocation stage</em>)系统调用通过把内核请求，以普通的内存存储操作写入到一个预留的系统调用页 (<em>syscall page</em>)。(<em>execution stage</em>)随后的系统调用执行采用 <strong>异步</strong> 的方式 (<em>special in-kernel <strong>syscall threads</strong></em>) ，将结果异步载入 <em>syscall page</em></p>\n<p>从上可以看出，它其实是把 <strong>invocation</strong> 和 <strong>execution</strong> 解耦。一方面可以在执行流上保证<u>时间的局部性</u>；另一方面能够让 <em>syscall</em> 独立运行在一个core上，与 <em>user mode threads</em> 隔离，保证每一个core内的<u>空间局部性</u></p>\n<p>与此同时，有一个很关键的 <strong>动态核特化</strong> (<em>dynamic core specialization</em>)概念——也就是core可以根据当前OS的<em>workload</em>，动态调整某一个core是进行用户态 / 内核态的工作。为了减轻编程负担，给出了一个 <em><strong>M-on-N</strong></em> 的线程模型(<em>M</em>个用户态线程，执行于 <em>N</em> 个内核可见的线程) 。关于POSIX线程模型，参见<a href=\"https://www.yuque.com/barret/giv6pv/ogmd8f\">POSIX线程模型</a></p>\n<h3 id=\"2-cost-of-system-call\"><a class=\"markdownIt-Anchor\" href=\"#2-cost-of-system-call\"></a> 2. cost of system-call</h3>\n<h4 id=\"21-模式切换cost\"><a class=\"markdownIt-Anchor\" href=\"#21-模式切换cost\"></a> 2.1 模式切换cost</h4>\n<p>时间损耗发生于：用户态下必要的syscall调用、执行权转交给内核的执行、执行权反交给用户态。现代处理器通过处理器异常来做这个模式切换，切换时会将用户模式下的指令流水线清空、将CPU上下文保存入栈、改变 <em>protection domain</em>、重定向到异常处理<em>handler</em></p>\n<blockquote>\n<p>这里对 <em>protection domain</em> 不是特别理解，详见 <a href=\"https://zhuanlan.zhihu.com/p/59796446\">Lampson: Protection Models</a>。可以和chcore中的pmo-cap关联起来看，个人理解为一个资源的句柄域，由于内核态和用户态的 <em>domain</em> 不同(可以使用的资源范围)，故需要在这里进行<em>domain</em> 的改变</p>\n</blockquote>\n<h4 id=\"22-系统调用cost\"><a class=\"markdownIt-Anchor\" href=\"#22-系统调用cost\"></a> 2.2 系统调用cost</h4>\n<p>处理器状态污染：</p>\n<p>进入内核态执行时，处理器的L1缓存数据、指令缓存、TLB、分支预测表，以及L2缓存，都会因为系统调用而被污染，从而在返回用户态之后，极大地影响用户态程序执行速度</p>\n<p><img src=\"https://i.loli.net/2020/12/20/vfRDmGitJOsWB6F.png\" alt=\"image.png\" /></p>\n<h4 id=\"23-返回用户态执行cost\"><a class=\"markdownIt-Anchor\" href=\"#23-返回用户态执行cost\"></a> 2.3 返回用户态执行cost</h4>\n<blockquote>\n<p>衡量指标：IPC (<em>instructions per cycle</em>)</p>\n</blockquote>\n<p>理想状态下，用户模式下的<em>IPC</em> 应当不变化。但是实际实验中，有如下的几个影响因素。</p>\n<p><strong>直接影响</strong>：系统调用关联的异常，将处理器执行流水线清空</p>\n<p><strong>间接影响</strong>：处理器状态污染</p>\n<img src=\"https://i.loli.net/2020/12/20/vFbzLq7xU2ZRiAH.png\" alt=\"image.png\" style=\"zoom: 67%;\" />\n<p>实验结果解读：</p>\n<ol>\n<li>横轴表示syscall的一个频率，纵轴表示 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>−</mo><mfrac><mrow><mi>I</mi><mi>P</mi><msub><mi>C</mi><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi></mrow></msub></mrow><mrow><mi>I</mi><mi>P</mi><msub><mi>C</mi><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">1-\\frac{IPC_{user}}{IPC_{base}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3392909999999998em;vertical-align:-0.4508599999999999em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8884309999999999em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3487714285714287em;margin-left:-0.07153em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">b</span><span class=\"mord mathdefault mtight\">a</span><span class=\"mord mathdefault mtight\">s</span><span class=\"mord mathdefault mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15122857142857138em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4101em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16454285714285719em;\"><span style=\"top:-2.357em;margin-left:-0.07153em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">u</span><span class=\"mord mathdefault mtight\">s</span><span class=\"mord mathdefault mtight\">e</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4508599999999999em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。从这里可以看出，在per-1K条指令一次系统调用的情况下，会造成比较大的损耗。</li>\n<li>使用空的syscall来评估系统调用带来的 <em>direct</em> 影响，使用一个 <em>pwrite</em> 调用来评估系统调用带来的 <em>indirect</em> 影响。可以看出，在syscall频繁的时候(1K)，直接影响占据主导；而当syscall不频繁时，间接影响占据主导</li>\n</ol>\n<p>IPC受syscall频率的影响。可以见到，当系统调用频繁时，内核的状态也能够比较好地被保持。由此看出syscall对 user / kernel mode均会造成局部性的影响</p>\n<img src=\"https://i.loli.net/2020/12/20/qDFpQv7kRSaLEnd.png\" alt=\"image.png\" style=\"zoom:67%;\" />\n<h3 id=\"3-exception-less-system-call\"><a class=\"markdownIt-Anchor\" href=\"#3-exception-less-system-call\"></a> 3. Exception-Less system call</h3>\n<blockquote>\n<p>提供灵活的系统调用执行调度，进而提升用户 / 内核态下的局部性</p>\n</blockquote>\n<p>在两个方面下功夫：</p>\n<ul>\n<li><em>System call batching</em> : 延缓systemcall的执行，让他们以一个batch来一起执行</li>\n<li><em>Core specialization</em> : 内核特化，<em>execution</em> / <em>invoke</em> 分开于不同的core上执行</li>\n</ul>\n<h4 id=\"31-exception-less-syscall接口\"><a class=\"markdownIt-Anchor\" href=\"#31-exception-less-syscall接口\"></a> 3.1 Exception-Less syscall接口</h4>\n<p>通过一个 user-kernel共享的内存页支持(<em>syscall page</em>)，包含了syscall入口，关联到请求状态、系统调用号、入参、出参</p>\n<p>在调用一个exception-less syscall，用户态的线程会找到 <em>syscall page</em>内的一个空闲<em>entry</em>，将系统调用相关的数据写入。之后用户态线程可以继续执行，不被中断。用户线程后续会读取<em>entry</em>中的执行状态，校验系统调用是否已经完成。这些操作中，用户线程不需要通过<em>exception</em></p>\n<p><em>syscall page</em> 中的每一个<em>entry</em> 结构如下：</p>\n<blockquote>\n<p>64-bit系统中，每一个 <em>entry</em> 占用 <strong>64 bytes</strong></p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2020/12/20/Nv5WgtnKT8qSreu.png\" alt=\"image.png\" /></p>\n<p>在调用 <em>exception-less syscall</em> 时，用户线程需要找到一个 <em>status = free</em> 的 <em>entry</em>，随后将必要的参数写入到这个入口。写入完成后，<em>status</em> 置为 <em>submitted</em> 。随后用户线程可以执行自己的代码，后续需要check这个<em>status</em> 是否为 <em>done</em>，表明系统调用是否完成。若完成，那么用户线程设置 <em>status</em> 为 <em>free</em></p>\n<blockquote>\n<p><mark>Question</mark> : 这里会不会有并发问题？ 当一个线程正在write argument，另一个用户线程发现 <em>status = free</em>，那么也会进行write argument。这时候会有race ？</p>\n</blockquote>\n<h4 id=\"32-执行-调用解耦\"><a class=\"markdownIt-Anchor\" href=\"#32-执行-调用解耦\"></a> 3.2 执行、调用解耦</h4>\n<p>不同于 <em>exception-based syscall</em> ，<em>exception-less syscall</em> 采用一种 <strong>异步</strong> 的策略，调用时，用户线程写入 <em>syscall page</em>；执行<em>syscall</em> 时，<em><strong>syscall thread</strong></em> (必在内核态) 从 <em>syscall page</em> 拉取系统调用请求</p>\n<img src=\"https://i.loli.net/2020/12/20/2F4gn3JqKUo1pGX.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n<ul>\n<li>用户线程只在无法进行更多的执行，才会唤醒系统调用线程(<em>syscall thread</em>) ——保证时间局部性</li>\n<li>系统调用线程可以被调度——保证空间局部性</li>\n</ul>\n<h4 id=\"33-flexsc\"><a class=\"markdownIt-Anchor\" href=\"#33-flexsc\"></a> 3.3 FlexSC</h4>\n<blockquote>\n<p><em>exception-less syscall</em> 的具体实现实践</p>\n</blockquote>\n<p>给出两个新的linux系统调用：</p>\n<ul>\n<li><strong>flexsc_register()</strong></li>\n</ul>\n<p>在进程初始化的时候<strong>显式</strong>调用，是 <em>exception-based</em> 的。由于只需要执行一次，对性能的影响可以忽略</p>\n<p>这个系统调用做了两件事：将若干 <em>syscall pages</em> 映射至用户虚存空间、为每一个 <em>entry</em> 产生一个 <em>syscall thread</em></p>\n<ul>\n<li><strong>flexsc_wait()</strong></li>\n</ul>\n<p>对于传统的同步系统调用，用户线程只需要简单地进行 <em>sleep</em> ，等待<em>syscall</em> 执行完毕。当前的执行模式中，用户线程会显示地与内核 <em>communicate</em>，告知自己无法进行进一步的执行，直到调用的<em>syscall</em> 已经完成。这一个函数调用是 <em>exception-based</em> ，调用过后能够在至少一个syscall完成后，唤醒用户空间的线程</p>\n<h4 id=\"34-syscall-thread\"><a class=\"markdownIt-Anchor\" href=\"#34-syscall-thread\"></a> 3.4 syscall thread</h4>\n<p>之前说到，<strong>syscall thread</strong> 从 <em>syscall pages</em> 拉取请求。</p>\n<p>在 <em>flexsc_register()</em> 阶段，<em>syscall thread</em> 从注册的进程中克隆得到，他们也就拥有相同的虚拟地址空间。这一点能够让后续的数据迁移变得容易(不需要重新定义虚存映射)</p>\n<p>针对每一个entry，都会在kernel mode创建一个 <em>syscall thread</em>。但是只有一个 <em>syscall thread</em> (per core) 是处于active状态。当系统调用线程需要立即阻塞时，FlexSC会notify工作队列，使另一个线程wake up，立即开始执行下一个 <em>syscall</em>。 当资源空闲时，当前的Linux代码会唤醒等待的线程，并恢复其执行</p>\n<h4 id=\"35-syscall-thread调度器\"><a class=\"markdownIt-Anchor\" href=\"#35-syscall-thread调度器\"></a> 3.5 syscall thread调度器</h4>\n<p>单核：</p>\n<p>调度器假设用户空间会尝试调用尽可能多的<em>syscall</em>，调度器随后会唤醒其中的一个空闲 <em>syscall thread</em>，用来执行第一个 <em>syscall</em>。</p>\n<ul>\n<li>如果这个系统调用不会被阻塞，那么当前的 <em>syscall thread</em> 会继续执行下一个 <em>syscall</em></li>\n<li>如果会被阻塞，那么阻塞时，调度器会唤醒下一个 <em>syscall thread</em>，来执行下一个系统调用</li>\n</ul>\n<p>调度器不会唤醒用户线程，直到所有的系统调用已经被 <em>issued</em>，</p>\n<p>多核：</p>\n<p>通过尝试使用预定义的静态core list调度。</p>\n<ul>\n<li>选择<em>list</em>中的第一个核，如果某个进程的系统调用线程当前正在该核上运行，则选择列表中下一个核</li>\n<li>如果所core当前未执行系统调用线程，则将处理器间中断发送到core，以表明它必须唤醒系统调用线程</li>\n</ul>\n<p>每一个core上只能同时运行一个进程的<em>syscall thread</em>，但是之前的问题也提到了一个并发竞争问题。这里通过对 page 加锁来避免并发的问题，直到所有 <em>submitted</em> 系统调用请求都被发出了才进行解锁</p>\n<h3 id=\"4-flexsc-threads\"><a class=\"markdownIt-Anchor\" href=\"#4-flexsc-threads\"></a> 4. FlexSC - Threads</h3>\n<p><em>Exception-less syscall</em> 更加类似于 <strong>事件驱动</strong> 模型，能够让IO相关的操作在未来执行，并且能够请求、验证完成、处理任何系统调用</p>\n<p>文中着重探讨了实现 <em><strong>FlexSC-Threads</strong></em>，一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>M</mi><mo>−</mo><mi>o</mi><mi>n</mi><mo>−</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M-on-N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 线程模型。依赖于仅在用户空间中进行线程切换的能力，来让同步系统调用透明地转变为 <em>exception-less syscall</em>。</p>\n<p><em>FlexSC-Threads</em> 工作流程如下：</p>\n<ol>\n<li>将每个libc调用重定向到我们的库。 通常应用程序不直接嵌入代码以发出系统调用，而是在<strong>动态加载</strong>的libc中调用包装器，故采用Linux的动态加载功能将此类调用的执行重定向到我们的库</li>\n<li>随后将对应的 <em>exception-less syscall</em> 写入到 <em>syscall page</em>，切换至另一个就绪的用户线程</li>\n<li>如果没有就绪用户线程，那么<em>FlexSC</em>检查那些 <em>status = completed</em> 的 <em>syscall page</em>，将对应的线程唤醒，来获取系统调用完成后的<em>result</em></li>\n<li>当所有的用户线程都等待系统调用，FlexSC Thread lib将调用<strong>flexsc_wait()</strong>，使内核可见线程进入睡眠状态，直到一个挂起的系统调用完成。</li>\n</ol>\n<p>多核环境下的每一个进程，为每一个core建立一个内核可见线程</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-概述\"><a class=\"markdownIt-Anchor\" href=\"#1-概述\"></a> 1. 概述</h3>\n<p>系统调用采用同步的机制，在用户态转移到内核态的过程中，需要把当前上下文保存，但是其中的模式切换成本，与间接的处理器上下文数据污染（影响局部性 <em>locality</em>），会对系统调用造成比较大的负面影响</p>\n<p><img src=\"https://i.loli.net/2020/12/20/5jrZnDoWebTua9s.png\" alt=\"image.png\" /></p>\n<p>文中给出的 <em>proposal</em> : <em><strong>exception-less system call</strong></em>，在请求内核服务时，不需要使用同步处理器异常。实现过程中，(<em>invocation stage</em>)系统调用通过把内核请求，以普通的内存存储操作写入到一个预留的系统调用页 (<em>syscall page</em>)。(<em>execution stage</em>)随后的系统调用执行采用 <strong>异步</strong> 的方式 (<em>special in-kernel <strong>syscall threads</strong></em>) ，将结果异步载入 <em>syscall page</em></p>\n<p>从上可以看出，它其实是把 <strong>invocation</strong> 和 <strong>execution</strong> 解耦。一方面可以在执行流上保证<u>时间的局部性</u>；另一方面能够让 <em>syscall</em> 独立运行在一个core上，与 <em>user mode threads</em> 隔离，保证每一个core内的<u>空间局部性</u></p>\n<p>与此同时，有一个很关键的 <strong>动态核特化</strong> (<em>dynamic core specialization</em>)概念——也就是core可以根据当前OS的<em>workload</em>，动态调整某一个core是进行用户态 / 内核态的工作。为了减轻编程负担，给出了一个 <em><strong>M-on-N</strong></em> 的线程模型(<em>M</em>个用户态线程，执行于 <em>N</em> 个内核可见的线程) 。关于POSIX线程模型，参见<a href=\"https://www.yuque.com/barret/giv6pv/ogmd8f\">POSIX线程模型</a></p>\n<h3 id=\"2-cost-of-system-call\"><a class=\"markdownIt-Anchor\" href=\"#2-cost-of-system-call\"></a> 2. cost of system-call</h3>\n<h4 id=\"21-模式切换cost\"><a class=\"markdownIt-Anchor\" href=\"#21-模式切换cost\"></a> 2.1 模式切换cost</h4>\n<p>时间损耗发生于：用户态下必要的syscall调用、执行权转交给内核的执行、执行权反交给用户态。现代处理器通过处理器异常来做这个模式切换，切换时会将用户模式下的指令流水线清空、将CPU上下文保存入栈、改变 <em>protection domain</em>、重定向到异常处理<em>handler</em></p>\n<blockquote>\n<p>这里对 <em>protection domain</em> 不是特别理解，详见 <a href=\"https://zhuanlan.zhihu.com/p/59796446\">Lampson: Protection Models</a>。可以和chcore中的pmo-cap关联起来看，个人理解为一个资源的句柄域，由于内核态和用户态的 <em>domain</em> 不同(可以使用的资源范围)，故需要在这里进行<em>domain</em> 的改变</p>\n</blockquote>\n<h4 id=\"22-系统调用cost\"><a class=\"markdownIt-Anchor\" href=\"#22-系统调用cost\"></a> 2.2 系统调用cost</h4>\n<p>处理器状态污染：</p>\n<p>进入内核态执行时，处理器的L1缓存数据、指令缓存、TLB、分支预测表，以及L2缓存，都会因为系统调用而被污染，从而在返回用户态之后，极大地影响用户态程序执行速度</p>\n<p><img src=\"https://i.loli.net/2020/12/20/vfRDmGitJOsWB6F.png\" alt=\"image.png\" /></p>\n<h4 id=\"23-返回用户态执行cost\"><a class=\"markdownIt-Anchor\" href=\"#23-返回用户态执行cost\"></a> 2.3 返回用户态执行cost</h4>\n<blockquote>\n<p>衡量指标：IPC (<em>instructions per cycle</em>)</p>\n</blockquote>\n<p>理想状态下，用户模式下的<em>IPC</em> 应当不变化。但是实际实验中，有如下的几个影响因素。</p>\n<p><strong>直接影响</strong>：系统调用关联的异常，将处理器执行流水线清空</p>\n<p><strong>间接影响</strong>：处理器状态污染</p>\n<img src=\"https://i.loli.net/2020/12/20/vFbzLq7xU2ZRiAH.png\" alt=\"image.png\" style=\"zoom: 67%;\" />\n<p>实验结果解读：</p>\n<ol>\n<li>横轴表示syscall的一个频率，纵轴表示 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>−</mo><mfrac><mrow><mi>I</mi><mi>P</mi><msub><mi>C</mi><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi></mrow></msub></mrow><mrow><mi>I</mi><mi>P</mi><msub><mi>C</mi><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">1-\\frac{IPC_{user}}{IPC_{base}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3392909999999998em;vertical-align:-0.4508599999999999em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8884309999999999em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3487714285714287em;margin-left:-0.07153em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">b</span><span class=\"mord mathdefault mtight\">a</span><span class=\"mord mathdefault mtight\">s</span><span class=\"mord mathdefault mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15122857142857138em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4101em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16454285714285719em;\"><span style=\"top:-2.357em;margin-left:-0.07153em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">u</span><span class=\"mord mathdefault mtight\">s</span><span class=\"mord mathdefault mtight\">e</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4508599999999999em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>。从这里可以看出，在per-1K条指令一次系统调用的情况下，会造成比较大的损耗。</li>\n<li>使用空的syscall来评估系统调用带来的 <em>direct</em> 影响，使用一个 <em>pwrite</em> 调用来评估系统调用带来的 <em>indirect</em> 影响。可以看出，在syscall频繁的时候(1K)，直接影响占据主导；而当syscall不频繁时，间接影响占据主导</li>\n</ol>\n<p>IPC受syscall频率的影响。可以见到，当系统调用频繁时，内核的状态也能够比较好地被保持。由此看出syscall对 user / kernel mode均会造成局部性的影响</p>\n<img src=\"https://i.loli.net/2020/12/20/qDFpQv7kRSaLEnd.png\" alt=\"image.png\" style=\"zoom:67%;\" />\n<h3 id=\"3-exception-less-system-call\"><a class=\"markdownIt-Anchor\" href=\"#3-exception-less-system-call\"></a> 3. Exception-Less system call</h3>\n<blockquote>\n<p>提供灵活的系统调用执行调度，进而提升用户 / 内核态下的局部性</p>\n</blockquote>\n<p>在两个方面下功夫：</p>\n<ul>\n<li><em>System call batching</em> : 延缓systemcall的执行，让他们以一个batch来一起执行</li>\n<li><em>Core specialization</em> : 内核特化，<em>execution</em> / <em>invoke</em> 分开于不同的core上执行</li>\n</ul>\n<h4 id=\"31-exception-less-syscall接口\"><a class=\"markdownIt-Anchor\" href=\"#31-exception-less-syscall接口\"></a> 3.1 Exception-Less syscall接口</h4>\n<p>通过一个 user-kernel共享的内存页支持(<em>syscall page</em>)，包含了syscall入口，关联到请求状态、系统调用号、入参、出参</p>\n<p>在调用一个exception-less syscall，用户态的线程会找到 <em>syscall page</em>内的一个空闲<em>entry</em>，将系统调用相关的数据写入。之后用户态线程可以继续执行，不被中断。用户线程后续会读取<em>entry</em>中的执行状态，校验系统调用是否已经完成。这些操作中，用户线程不需要通过<em>exception</em></p>\n<p><em>syscall page</em> 中的每一个<em>entry</em> 结构如下：</p>\n<blockquote>\n<p>64-bit系统中，每一个 <em>entry</em> 占用 <strong>64 bytes</strong></p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2020/12/20/Nv5WgtnKT8qSreu.png\" alt=\"image.png\" /></p>\n<p>在调用 <em>exception-less syscall</em> 时，用户线程需要找到一个 <em>status = free</em> 的 <em>entry</em>，随后将必要的参数写入到这个入口。写入完成后，<em>status</em> 置为 <em>submitted</em> 。随后用户线程可以执行自己的代码，后续需要check这个<em>status</em> 是否为 <em>done</em>，表明系统调用是否完成。若完成，那么用户线程设置 <em>status</em> 为 <em>free</em></p>\n<blockquote>\n<p><mark>Question</mark> : 这里会不会有并发问题？ 当一个线程正在write argument，另一个用户线程发现 <em>status = free</em>，那么也会进行write argument。这时候会有race ？</p>\n</blockquote>\n<h4 id=\"32-执行-调用解耦\"><a class=\"markdownIt-Anchor\" href=\"#32-执行-调用解耦\"></a> 3.2 执行、调用解耦</h4>\n<p>不同于 <em>exception-based syscall</em> ，<em>exception-less syscall</em> 采用一种 <strong>异步</strong> 的策略，调用时，用户线程写入 <em>syscall page</em>；执行<em>syscall</em> 时，<em><strong>syscall thread</strong></em> (必在内核态) 从 <em>syscall page</em> 拉取系统调用请求</p>\n<img src=\"https://i.loli.net/2020/12/20/2F4gn3JqKUo1pGX.png\" alt=\"image.png\" style=\"zoom:80%;\" />\n<ul>\n<li>用户线程只在无法进行更多的执行，才会唤醒系统调用线程(<em>syscall thread</em>) ——保证时间局部性</li>\n<li>系统调用线程可以被调度——保证空间局部性</li>\n</ul>\n<h4 id=\"33-flexsc\"><a class=\"markdownIt-Anchor\" href=\"#33-flexsc\"></a> 3.3 FlexSC</h4>\n<blockquote>\n<p><em>exception-less syscall</em> 的具体实现实践</p>\n</blockquote>\n<p>给出两个新的linux系统调用：</p>\n<ul>\n<li><strong>flexsc_register()</strong></li>\n</ul>\n<p>在进程初始化的时候<strong>显式</strong>调用，是 <em>exception-based</em> 的。由于只需要执行一次，对性能的影响可以忽略</p>\n<p>这个系统调用做了两件事：将若干 <em>syscall pages</em> 映射至用户虚存空间、为每一个 <em>entry</em> 产生一个 <em>syscall thread</em></p>\n<ul>\n<li><strong>flexsc_wait()</strong></li>\n</ul>\n<p>对于传统的同步系统调用，用户线程只需要简单地进行 <em>sleep</em> ，等待<em>syscall</em> 执行完毕。当前的执行模式中，用户线程会显示地与内核 <em>communicate</em>，告知自己无法进行进一步的执行，直到调用的<em>syscall</em> 已经完成。这一个函数调用是 <em>exception-based</em> ，调用过后能够在至少一个syscall完成后，唤醒用户空间的线程</p>\n<h4 id=\"34-syscall-thread\"><a class=\"markdownIt-Anchor\" href=\"#34-syscall-thread\"></a> 3.4 syscall thread</h4>\n<p>之前说到，<strong>syscall thread</strong> 从 <em>syscall pages</em> 拉取请求。</p>\n<p>在 <em>flexsc_register()</em> 阶段，<em>syscall thread</em> 从注册的进程中克隆得到，他们也就拥有相同的虚拟地址空间。这一点能够让后续的数据迁移变得容易(不需要重新定义虚存映射)</p>\n<p>针对每一个entry，都会在kernel mode创建一个 <em>syscall thread</em>。但是只有一个 <em>syscall thread</em> (per core) 是处于active状态。当系统调用线程需要立即阻塞时，FlexSC会notify工作队列，使另一个线程wake up，立即开始执行下一个 <em>syscall</em>。 当资源空闲时，当前的Linux代码会唤醒等待的线程，并恢复其执行</p>\n<h4 id=\"35-syscall-thread调度器\"><a class=\"markdownIt-Anchor\" href=\"#35-syscall-thread调度器\"></a> 3.5 syscall thread调度器</h4>\n<p>单核：</p>\n<p>调度器假设用户空间会尝试调用尽可能多的<em>syscall</em>，调度器随后会唤醒其中的一个空闲 <em>syscall thread</em>，用来执行第一个 <em>syscall</em>。</p>\n<ul>\n<li>如果这个系统调用不会被阻塞，那么当前的 <em>syscall thread</em> 会继续执行下一个 <em>syscall</em></li>\n<li>如果会被阻塞，那么阻塞时，调度器会唤醒下一个 <em>syscall thread</em>，来执行下一个系统调用</li>\n</ul>\n<p>调度器不会唤醒用户线程，直到所有的系统调用已经被 <em>issued</em>，</p>\n<p>多核：</p>\n<p>通过尝试使用预定义的静态core list调度。</p>\n<ul>\n<li>选择<em>list</em>中的第一个核，如果某个进程的系统调用线程当前正在该核上运行，则选择列表中下一个核</li>\n<li>如果所core当前未执行系统调用线程，则将处理器间中断发送到core，以表明它必须唤醒系统调用线程</li>\n</ul>\n<p>每一个core上只能同时运行一个进程的<em>syscall thread</em>，但是之前的问题也提到了一个并发竞争问题。这里通过对 page 加锁来避免并发的问题，直到所有 <em>submitted</em> 系统调用请求都被发出了才进行解锁</p>\n<h3 id=\"4-flexsc-threads\"><a class=\"markdownIt-Anchor\" href=\"#4-flexsc-threads\"></a> 4. FlexSC - Threads</h3>\n<p><em>Exception-less syscall</em> 更加类似于 <strong>事件驱动</strong> 模型，能够让IO相关的操作在未来执行，并且能够请求、验证完成、处理任何系统调用</p>\n<p>文中着重探讨了实现 <em><strong>FlexSC-Threads</strong></em>，一个 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>M</mi><mo>−</mo><mi>o</mi><mi>n</mi><mo>−</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M-on-N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 线程模型。依赖于仅在用户空间中进行线程切换的能力，来让同步系统调用透明地转变为 <em>exception-less syscall</em>。</p>\n<p><em>FlexSC-Threads</em> 工作流程如下：</p>\n<ol>\n<li>将每个libc调用重定向到我们的库。 通常应用程序不直接嵌入代码以发出系统调用，而是在<strong>动态加载</strong>的libc中调用包装器，故采用Linux的动态加载功能将此类调用的执行重定向到我们的库</li>\n<li>随后将对应的 <em>exception-less syscall</em> 写入到 <em>syscall page</em>，切换至另一个就绪的用户线程</li>\n<li>如果没有就绪用户线程，那么<em>FlexSC</em>检查那些 <em>status = completed</em> 的 <em>syscall page</em>，将对应的线程唤醒，来获取系统调用完成后的<em>result</em></li>\n<li>当所有的用户线程都等待系统调用，FlexSC Thread lib将调用<strong>flexsc_wait()</strong>，使内核可见线程进入睡眠状态，直到一个挂起的系统调用完成。</li>\n</ol>\n<p>多核环境下的每一个进程，为每一个core建立一个内核可见线程</p>\n"},{"title":"2020 小结","date":"2021-01-24T07:34:43.000Z","cover":"https://images.unsplash.com/photo-1611159604444-6598d2d8d9ab?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=934&q=80","cover_img":null,"feature_img":null,"description":null,"keywords":null,"_content":"\n\n\n...","source":"_posts/2020-小结.md","raw":"---\ntitle: 2020 小结\ndate: 2021-01-24 15:34:43\ntags: 随笔\ncover: https://images.unsplash.com/photo-1611159604444-6598d2d8d9ab?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=934&q=80\ncover_img:\nfeature_img:\ndescription:\nkeywords:\n---\n\n\n\n...","slug":"2020-小结","published":1,"updated":"2021-01-24T07:36:21.441Z","_id":"ckkatursp0000mmme390pcdwk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>…</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckgk7k808000106me4nqo0eh0","category_id":"ckgk7k80d000406me7ucohizs","_id":"ckgk7k80k000g06mebjmcar07"},{"post_id":"ckgk7k80b000306mefb3td4ie","category_id":"ckgk7k80h000b06meblnh3tlv","_id":"ckgk7k80m000l06me57051hga"},{"post_id":"ckgk7k80k000i06mefkv2dfia","category_id":"ckgk7k80h000b06meblnh3tlv","_id":"ckgk7k80o000r06me0b9memte"},{"post_id":"ckgk7k80m000o06meagz10lse","category_id":"ckgk7k80o000s06me3seg0wpf","_id":"ckgk7k80t001406me8m2kbr75"},{"post_id":"ckgk7k80n000q06me3860ffam","category_id":"ckgk7k80s001106me5h3ocrgn","_id":"ckgk7k80u001706me2p2obum2"}],"PostTag":[{"post_id":"ckgk7k808000106me4nqo0eh0","tag_id":"ckgk7k80e000506me4g6whrj6","_id":"ckgk7k80i000d06mecq9cdxnt"},{"post_id":"ckgk7k80b000306mefb3td4ie","tag_id":"ckgk7k80i000c06me114d23db","_id":"ckgk7k80l000j06me0125cdne"},{"post_id":"ckgk7k80k000i06mefkv2dfia","tag_id":"ckgk7k80i000c06me114d23db","_id":"ckgk7k80m000n06meeiy73hcl"},{"post_id":"ckgk7k80f000706me653b5qee","tag_id":"ckgk7k80k000h06mefflpbdul","_id":"ckgk7k80n000p06me2zje8wth"},{"post_id":"ckgk7k80l000k06mefb0g7u7t","tag_id":"ckgk7k80k000h06mefflpbdul","_id":"ckgk7k80o000t06meaim12bdc"},{"post_id":"ckgk7k80m000o06meagz10lse","tag_id":"ckgk7k80k000h06mefflpbdul","_id":"ckgk7k80q000w06me4xxj5p6d"},{"post_id":"ckgk7k80g000906me3cy3gi8g","tag_id":"ckgk7k80m000m06meawuvd5zl","_id":"ckgk7k80r000y06meafx91wbk"},{"post_id":"ckgk7k80h000a06me347nhw48","tag_id":"ckgk7k80k000h06mefflpbdul","_id":"ckgk7k80s001206meddc12ah2"},{"post_id":"ckgk7k80i000e06me1rjjfcpv","tag_id":"ckgk7k80r000z06me3fjl3vp3","_id":"ckgk7k80u001606meb2d66z7q"},{"post_id":"ckgk7k80n000q06me3860ffam","tag_id":"ckgk7k80t001506mefedn3133","_id":"ckgk7k80v001906meg93f7wou"},{"post_id":"ckgk7k80q000x06me0njl69y3","tag_id":"ckgk7k80u001806medws7bul2","_id":"ckgk7k80w001b06me4u4o8gp5"},{"post_id":"ckgk7k80r001006me1oh13du2","tag_id":"ckgk7k80w001a06megtbyfkyj","_id":"ckgk7k80w001d06mea3bd2cqa"},{"post_id":"ckgk7k80t001306me4k7t2pv9","tag_id":"ckgk7k80w001c06medjws5n6i","_id":"ckgk7k80w001e06medx519q7s"},{"post_id":"ckgk7k819001f06mefylxh90m","tag_id":"ckgk7k80k000h06mefflpbdul","_id":"ckgk7k81a001g06me2zsiggn0"},{"post_id":"ckkatursp0000mmme390pcdwk","tag_id":"ckkaturst0001mmme0sqz3vpq","_id":"ckkatursy0002mmme29fb8knh"}],"Tag":[{"name":"K8S","_id":"ckgk7k80e000506me4g6whrj6"},{"name":"competition","_id":"ckgk7k80i000c06me114d23db"},{"name":"笔记","_id":"ckgk7k80k000h06mefflpbdul"},{"name":"读书笔记","_id":"ckgk7k80m000m06meawuvd5zl"},{"name":"整理","_id":"ckgk7k80r000z06me3fjl3vp3"},{"name":"UpUp","_id":"ckgk7k80t001506mefedn3133"},{"name":"算法","_id":"ckgk7k80u001806medws7bul2"},{"name":"coding","_id":"ckgk7k80w001a06megtbyfkyj"},{"name":"设计模式","_id":"ckgk7k80w001c06medjws5n6i"},{"name":"随笔","_id":"ckkaturst0001mmme0sqz3vpq"}]}}