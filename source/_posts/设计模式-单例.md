---
title: 设计模式-单例
date: 2019-12-07 16:47:11
tags: 设计模式
cover_img: https://images.unsplash.com/photo-1507580433829-a0989f4d4469?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80
cover: https://images.unsplash.com/photo-1507580433829-a0989f4d4469?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80
feature_img: https://images.unsplash.com/photo-1472512946974-cc09a294e210?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1115&q=80
---

## 单例模式

给出最原始的代码

```java
public class Singleton {

    //一个静态的实例
    private static Singleton singleton;
    //私有化构造函数
    private Singleton(){}
    //给出一个公共的静态方法返回一个单一实例
    public static Singleton getInstance(){
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
```

现在我们就需要考虑==多线程环境==下的单例模式实现了

**懒汉模式**

```java
public class Singleton {
    private static Singleton instance;
    private Singleton(){}
    public static Singleton getInstance(){
        if (instance == null) {
            //Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。
            instance = new Singleton();
        }
        return instance;
    }
}
```

**饿汉模式**

```java
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton getInstance(){
        return instance;
    }
}
```

> 多线程下的懒汉模式会出现问题——在判定是 *null* 的时候，还没来得及进行创建实例，另一个进程就进入进行判定

#### 解决办法1

方法上添加 **synchronized** 关键字

```java
public class Singleton {
    private static Singleton instance;
    private Singleton(){}
    public static synchronized Singleton getInstance(){
        if (instance == null) {
            //Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。
            instance = new Singleton();
        }
        return instance;
    }
}
```

> 问题：如果两个线程都要获取单例引用，只能等一个线程获取后，另一个线程才能获取。

#### 解决方法2

双检查锁机制（Double Check Locking）,也叫”DCL“

> 双锁的意思，是指 检测两次instance是否为空。

```java
public class Singleton {  
      
    //使用volatile关键字保其可见性  
    volatile private static Singleton instance = null;  
      
    private MySingleton(){}  
       
    public static MySingleton getInstance() {   
            if(instance == null){//懒汉式   
                  synchronized (Singleton.class) {  
                    if(instance == null){//二次检查  
                        instance = new MySingleton();  
                    }  
                } 
            }
        return instance;  
    }  
}  
```

#### 解决办法3

当然，我们最好还是采取**饿汉式**

```java
public class Singleton{
    //类加载时就初始化
    private static final Singleton instance = new Singleton();
    
    private Singleton(){}

    public static Singleton getInstance(){
        return instance;
    }
}
```

#### 解决办法4

采取 **静态内部类**

```java
public class Singleton {  
    private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    
    public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE; 
    }  
}
```

#### 解决办法5

枚举 Enum

```java
public enum EasySingleton{
    INSTANCE;
}
```

