---
title: LC周赛 2019-09-15
date: 2019-09-15 16:41:44
tags: 
  - competition
categories: 
  - 算法
description: 20190915周赛记录
cover_img: https://images.unsplash.com/photo-1516575448682-93a05df8bf59?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80
feature_img: https://images.unsplash.com/photo-1484278786775-527ac0d0b608?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=956&q=80
---

## 1. 寻找字符串中Balloon个数

给你一个字符串 `text`，你需要使用 `text` 中的字母来拼凑尽可能多的单词 **"balloon"（气球）**。

字符串 `text` 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 **"balloon"**。

### 思路：

很快可以通过哈希表来建立一个 `字符到字符在text中出现次数`的映射, 然后根据`ballon ` 来进行对照得出最终结果: 一定是 { `b` 出现次数 , `a` 出现次数 , `n` 出现次数 , `l` 出现次数的一半 , `o` 出现次数的一半 } 中的最小值, 即满足



```java
public int maxNumberOfBalloons(String text) {
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < text.length(); ++i) {
            map.put(text.charAt(i), map.getOrDefault(text.charAt(i), 0) + 1);
        }
        int b = map.getOrDefault('b', 0),
                a = map.getOrDefault('a', 0),
                l = map.getOrDefault('l', 0) / 2,
                o = map.getOrDefault('o', 0) / 2,
                n = map.getOrDefault('n', 0);
        return Math.min(b, Math.min(a, Math.min(l, Math.min(o, n))));
    }
```

##  2. 反转每对括号间的子串

给出一个字符串 `s`（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 **不应** 包含任何括号。

### 思路：

很明显这是一个 **递归** 问题. 举例说明

```
输入：s = "(u(love)i)"
```

我们需要先找出 **最小匹配括号子串** , 将其翻转之后, 再对其父级的子串进行翻转. 



但是有一个比较坑的点, 测试用例里面有这样的 `a()b(((c)))de` ， 也就是说，可以存在平级的括号. 这一点当时没想到. 从这里我们需要改变想法：

- 当遇到同级的括号，先处理过当前的 `()` 对，然后继续使用 ReverseParentheses 来对后续同级括号进行翻转. 这个属于迭代式的处理
- 当遇到子级括号, 也就是正常的 `(d(c))`这样的情况，就使用递归函数解决

```java
    public String reverseParentheses(String s) {
        int begin = 0;
        int end;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(')
                begin = i;
            if (s.charAt(i) == ')') {
                end = i;
                String temp = s.substring(begin + 1, end);//最小 ()
                return reverseParentheses(s.substring(0, begin) + reverseString(temp) + s.substring(end + 1));
            }
        }
        return s;
    }

    String reverseString(String s) {
        char[] temp = s.toCharArray();
        StringBuilder r = new StringBuilder();
        for (int i = temp.length - 1; i >= 0; i--)
            r.append(temp[i]);

        return r.toString();
    }
```

## 3. k次串联数组之后的最大子数组之和

给你一个整数数组 `arr` 和一个整数 `k`。

首先，我们要对该数组进行修改，即把原数组 `arr` 重复 `k` 次。

> 举个例子，如果 `arr = [1, 2]` 且 `k = 3`，那么修改后的数组就是 `[1, 2, 1, 2, 1, 2]`。

然后，请你返回修改后的数组中的最大的子数组之和。

注意，子数组长度可以是 `0`，在这种情况下它的总和也是 `0`。

由于 **结果可能会很大**，所以需要 **模（mod）** `10^9 + 7` 后再返回。 

### 思路：

一看，这个不就是最大子数组的翻版吗 hhh , 那么直接贪心上啊 

```java
private static final long MOD = 1000_000_007;

private int sumHelper(int[] arr, int k) {
        int totalLen = arr.length * k;
        int max = 0;
        int sum = 0;
        for (int i = 0; i < totalLen; ++i) {
            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);
            if (sum < 0) {
                sum = 0;
            } else {
                max = Math.max(sum, max);
            }
        }
        return max;
    }
```

那么问题来了，**TLE** 了. 也就是说，这个算法不容忍 **O(N)** 的时间复杂度. 我们需要找到数组在进行串联的时候的一个和数关系来进行快速获取答案.

#### 分析：

前缀和判断，一共如下可能

- 答案为 0

- 答案仅从当前不串联的数组中得到, 即 k = 1时的最大子数组和

- 答案从 k = 2 的串联结果得到，第一部分的后缀和的最大值加上第二部分的前缀和的最大值。

- 答案从整个串联 k > 2 次后的结果得到，且一定是第一部分的后缀和的最大值，中间部分的总和，加上最后一部分的前缀和的最大值。

第二种可能从**当前前缀和**减去**当前前缀和的最小值**得到。

前缀和的最大值直接可以维护出来，后缀和的最大值可以通过总和减去前缀和的最小值得到。

#### 实现

需要维护数组的 **总和**, **最大前缀和** , **最小前缀和**

```java
    private static final long MOD = 1000_000_007;

    public int kConcatenationMaxSum(int[] arr, int k) {
        int n = arr.length;
        if (k == 1)
            return sumHelper(arr);
        long[] sum = new long[n + 1];
        long[] maxL = new long[n + 1];
        long[] minL = new long[n + 1];
        for (int i = 1; i < n + 1; ++i) {
            sum[i] = sum[i - 1] + arr[i];
            maxL[i] = Math.max(maxL[i - 1], sum[i]);
            minL[i] = Math.min(minL[i - 1], sum[i]);
        }
        long ans = 0;
        return (int) (Math.max(ans,
                Math.max(
                        sum[n] - minL[n] + maxL[n],
                        sum[n] - minL[n] + maxL[n] + sum[n] * (k - 2)
                )
        ) % MOD);
    }

    private int sumHelper(int[] arr) {
        int totalLen = arr.length;
        int max = 0;
        int sum = 0;
        for (int i = 0; i < totalLen; ++i) {
            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);
            if (sum < 0) {
                sum = 0;
            } else {
                max = Math.max(sum, max);
            }
        }
        return max;
    }
```

## 4. 查找集群内的「关键连接」

力扣数据中心有 `n` 台服务器，分别按从 `0` 到 `n-1` 的方式进行了编号。

它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 `connections` 是无向的。

从形式上讲，`connections[i] = [a, b]` 表示服务器 `a` 和 `b` 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。

「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。

请你以任意顺序返回该集群内的所有 「关键连接」。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png)