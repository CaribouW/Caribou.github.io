---
title: leetcode-406 Reconstruct Queue
date: 2019-09-14 23:23:08
tags: 
  - Queue
categories: 
  - 算法
description: 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。
---

## 406 队列重组问题

题干：给予的队列中，每一个元素表示了这个人的身高、他之前不比他矮的人的个数。

```
思路:
* 比较菜，看了第一个hint.
* 第一个hint里面提到, 我们可以先对 h 值最小的入手.
* 我们得到最小的h 一个人 P0 之后,是可以直接定位他重排之后的位置的. 假设从0计数，那么最矮的人的位置和k的关系就是
* P0 处在位置k.
* 当然,如果存在多个身高最小的人,那么他们的k大小必然是连续的. 依次根据k值从小到大排列即可
*
* 一个人的位置定下之后,我们就可以继续找身高第二小的人. 注意这时候也可能会有身高一样的情况发生.
* 假设身高第二小的人 P1 (h1,k1) . 他重排之后的位置为index. 重排之后在他前面的身高比他小的人数为pre .
* 那么不难得出如下等式
*      index = k1 + pre
* 这样一来程序就不难写了
```

如上是第一次写的想法. 其实是被hint带进去了。我想着从最矮的人入手，但是在当最矮的人入队列之后，第二个参数 `k` 的条件将会被打破. 

- 注意：这时我的初始排序策略为 : `优先判定身高进行升序排列，身高相同者第二个参数升序排列`

### 题解

#### 最矮方案不行那就重新审视题目

hint里面提到了 ： 如果找到了最矮的人，那么可以马上确定他的位置. 这句话其实有另一层含义 ——如果一个人最后被插入队列，那么只有当其身高是最矮的时候，那么肯定可以确定他需要插入到 `k` 这个位置上. 那么我们转变排序策略, 进行 `优先判定身高进行降序排列, 身高相同者第二个参数升序排列`，以此来保证其排序完成后，可以根据该排序的先后顺序，依次进行插入.

#### 题解代码

```Cpp
vector<vector<int>> Solution::reconstructQueue(vector<vector<int>> &people) {
    sort(people.begin(),people.end(),[](const vector<int>& a, const vector<int>& b)
    { return a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]); });

    vector<vector<int>> ans;
    for(auto v : people)
        ans.insert(ans.begin()+v[1], v);
    return ans;
}
```

