---
title: 背包问题
date: 2020-01-15 17:13:36
tags: 算法
description: 关注背包九讲中的内容, 重点考察DP的思考想法
cover_img: https://images.unsplash.com/photo-1581463455583-40abcfc90be7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1234&q=80
feature_img: https://images.unsplash.com/photo-1581463455583-40abcfc90be7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1234&q=80
---

### 1. 01背包问题

有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。

分析：

- 每一个背包只有 **拿出 or 不拿出** 两种情况
- 对于 **dp** 数组，我们某一个状态 `dp[i][j]` 表示 **前i种背包的情况下，他们的总重量是 j 的最优解**
  - 如果 **i** 背包不拿，那么 `dp[i][j] = dp[i - 1][j]`
  - 如果 **i** 背包拿取，那么 `dp[i][j] = dp[i - 1][j - weights[i]] + values[i]`
    - 也就是说，拿取之后，需要看剩下的部分最优解

#### 算法优化

根据之前的状态转移方程，我们可以约减一维的 **dp** 空间

改进之后的 **dp** 状态转移方程如下：

`dp[i] = max(dp[j], dp[j - weights[i]] + values[i])`

> 为什么在内层循环，**j** 需要逆序？
>
> 在没有开始计算的时候，**dp[i]表示的是dp\[i-1]\[j]** 。而当我们需要计算 `dp[i] = max(dp[j], dp[j - weights[i]] + values[i])`的时候，需要保证 `dp[j - w[i]]` 是 **没有被改变的**。因此需要**从后往前**

### 2. 完全背包问题

每一件物品可以 **无限次** 拿取

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;

int main(){
    int N , V;
    cin >> N >> V;
    vector<int> w(N + 1) , v(N + 1);
    for(int i = 1 ; i <= N ; ++i) cin >> w[i] >> v[i];
    
    vector<vector<int>> dp(N + 1 , vector<int>(V + 1 , 0));
    
    for(int i = 1; i <= N ; ++i){
        for(int j = 0 ;j <= V; ++j){
            dp[i][j] = dp[i - 1][j];
            for(int k = 0 ; k*w[i] <= j; ++k){
                dp[i][j] = max(dp[i][j] , dp[i][j - k * w[i]] + k * v[i]);
            }
        }
    }
    
    cout << dp[N][V] << endl;
    
}
```

最重要的状态转移方程对比

- **01背包** ：`dp[i][j] = max(dp[i-1][j],dp[i - 1][j - w[i]] + v[i])`
- **完全背包** ：`dp[i][j] = max(dp[i][j] , dp[i - 1][j - k * w[i]] + k * v[i]);`

不难看出，两者其实非常的类似。根据下标我们可以给出压缩之后的优化版本完全背包解法

> **01背包** 和 **完全背包** 的不同
>
> ```cpp
> //01背包
> for i  in 0 ... N
>     for  j = V ... 0
>         f[j] = max{f[j], f[j - weight[i]] + value[i]}
> //完全背包
> for i int 0 ... N
>   	for	 j = 0 ... V
>       	f[j] = max{f[j] , f[j - weight[j]] + value[i]}
> ```
>
> 可以看出，只有内层循环的执行顺序不同

给出 **完全背包问题** 的优化方案

```cpp
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

int main(){
    int n , capacity;
    cin >> n >> capacity;
    vector<int> c(n + 1) , w(n + 1);
    vector<int> dp(max(n , capacity));
    for(int i = 1 ; i <= n ;++i) cin >> c[i] >> w[i];
    
    for(int i = 1; i <= n ;++i)
        for(int j = c[i] ; j <= capacity ; ++j)
            dp[j] = max(dp[j] , dp[j - c[i]] + w[i]);
    
    cout << dp[capacity];
}
```

