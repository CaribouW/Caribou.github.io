---
title: LC周赛 2019-09-29
date: 2019-09-29 07:50:40
tags: 
  - competition
categories: 
  - 算法
description: 20190915周赛记录
---

## 1. Unique Number of Occurrences

### 描述

Given an array of integers `arr`, write a function that returns `true` if and only if the number of occurrences of each value in the array is unique.

给出一个`int`数组中的各个数的 **出现次数** 是否唯一

### 实现

可以直接利用 **map** 来存储各个数的出现次数, 而后进行 value-set 的值的比较即可

```java
public boolean uniqueOccurrences(int[] arr) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : arr) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        Set<Integer> set = new HashSet<>();
        for (int key : map.keySet()) {
            set.add(map.get(key));
        }
        return map.keySet().size() == set.size();
    }
```

## 2. Get Equal Substrings Within Budget

### 描述

You are given two strings `s` and `t` of the same length. You want to change `s` to `t`. Changing the `i`-th character of `s` to `i`-th character of `t` costs `|s[i] - t[i]|` that is, the absolute difference between the ASCII values of the characters.

You are also given an integer `maxCost`.

Return the maximum length of a substring of `s` that can be changed to be the same as the corresponding substring of `t`with a cost less than or equal to `maxCost`.

If there is no substring from `s` that can be changed to its corresponding substring from `t`, return `0`

给出两个长度**相等**的字符串,和一个 `cost`, 我们需要给出最长的子串长度, 来让其`|s[i] - t[i]|`之和不大于cost

### 实现

首先可以把两个字符串相减——逐字符进行减计算，得到绝对值, 由此获取一个 `int` 数组

而后的问题变为：给定一个 `int` 数组和一个 `cost` , 求出最大子数组，来满足不大于 `cost`

```java
public int equalSubstring(String s, String t, int maxCost) {
        int ans = 0;
        int n = s.length();
        int[] costs = new int[n];
        for (int i = 0; i < n; ++i) {
            costs[i] = Math.abs(s.charAt(i) - t.charAt(i));
        }
        for (int i = 0; i < n; ++i) {
            int sum = 0;
            for (int j = i; j < n; ++j) {
                sum += costs[j];
                if (sum > maxCost) {
                    ans = Math.max(ans, j - i);
                    break;
                } else {
                    ans = Math.max(ans, j - i + 1);
                }
            }
        }

        return ans;
    }
```

## 3.Remove All Adjacent Duplicates in String II

### 描述

Given a string `s`, a *k* *duplicate removal* consists of choosing `k` adjacent and equal letters from `s` and removing them causing the left and the right side of the deleted substring to concatenate together.

We repeatedly make `k` duplicate removals on `s` until we no longer can.

Return the final string after all such duplicate removals have been made.

It is guaranteed that the answer is unique.

给定一个字符串 `s` 和一个整数 `k` , 每次我们可以一次性删除 `s` 中的 `k` 个连续的并且所有字符相同的子串, 求出最后的结果

### 实现

每一次根据 s , k 来从左往右查找满足该条件的子串, 返回一个长度为 **2** 的 `int` 数组, 作为满足该条件的 **第一个** 子串的指针, 逐个进行删除即可. 

之后也可以进行进一步优化 ： 每一次查找的时候查询所有满足该条件的子串，一次性删除 , 再进行下一轮的查询

```java
		public String removeDuplicates(String s, int k) {
        int[] indexes = findDuplicates(s, k);
        String ans = s;
        while (indexes != null) {
            ans = ans.substring(0, indexes[0]) + ans.substring(indexes[1] + 1);
            indexes = findDuplicates(ans, k);
        }
        return ans;
    }

    private int[] findDuplicates(String s, int k) {
        int n = s.length();
        for (int i = 0; i < n; ++i) {
            char ch = s.charAt(i);
            for (int j = i + 1; j < n; ++j) {
                if (s.charAt(j) != ch)
                    break;
                else if (j - i + 1 == k) return new int[]{i, j};
            }
        }
        return null;
    }
```

## 4. Minimum Moves to Reach Target with Rotations

### 描述

In an `n*n` grid, there is a snake that spans 2 cells and starts moving from the top left corner at `(0, 0)` and `(0, 1)`. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at `(n-1, n-2)` and `(n-1, n-1)`.

In one move the snake can:

- Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
- Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
- Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from `(r, c)` and `(r, c+1)` to `(r, c)` and `(r+1, c)`.
  ![img](https://assets.leetcode.com/uploads/2019/09/24/image-2.png)
- Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from `(r, c)` and `(r+1, c)` to `(r, c)` and `(r, c+1)`.
  ![img](https://assets.leetcode.com/uploads/2019/09/24/image-1.png)

Return the minimum number of moves to reach the target.

If there is no way to reach the target, return `-1`.

###  思路

很典型的DFS题目，下一步的行走都将影响后续的结果. 蛇很有可能进入 **死胡同** , 也就是我们无法进行下一步的查找.

我这里单独实现了蛇的位置 (水平 / 垂直) 判定 , 蛇进行 **左移、右移、顺时针旋转、逆时针旋转** 的逻辑. 而后穷举所有可能的情况

//TODO: 这个代码还没AC ， 只过了 17 / 42 

```java
public int minimumMoves(int[][] grid) {
        int[][] originPos = {{0, 0}, {0, 1}};
        int ans = dfs(grid, 0, originPos);
        return ans == Integer.MAX_VALUE ? -1 : ans;
    }

    private int dfs(int[][] grid, int number, int[][] pos) {
        //visited
        grid[pos[0][0]][pos[0][1]] = grid[pos[1][0]][pos[1][1]] = 1;
        if (isDestination(pos, grid)) {
            return number;
        }
        int a = pos[0][0], b = pos[0][1], c = pos[1][0], d = pos[1][1];
        int m = grid.length;
        int n = grid[0].length;
        if (isHorizen(pos)) {
            // --->
            boolean isInfi = true;
            int A = Integer.MAX_VALUE, B = Integer.MAX_VALUE;
            if (d + 1 < n && grid[a][d + 1] == 0) {     //You could move right
                isInfi = false;
                A = dfs(grid, number + 1, moveRight(pos));
            }
            if (a + 1 < m && grid[a + 1][b] == 0 && grid[a + 1][b + 1] == 0) {   //You could rotate clock or down
                isInfi = false;
                B = Math.min(dfs(grid, number + 1, clockRotate(pos)), dfs(grid, number + 1, moveDown(pos)));
            }                                //死胡同
            if (isInfi)
                return Integer.MAX_VALUE;
            else
                return Math.min(A, B);
        } else if (isVertical(pos)) {
            boolean isInfi = true;
            int A = Integer.MAX_VALUE, B = Integer.MAX_VALUE;
            if (c + 1 < m && grid[c + 1][b] == 0) {             //You could move downWard
                isInfi = false;
                A = dfs(grid, number + 1, moveDown(pos));
            } else if (b + 1 < n && grid[a][b + 1] == 0 && grid[c][b + 1] == 0) {   //You could rotate counter or right
                isInfi = false;
                B = Math.min(dfs(grid, number + 1, counterClockRotate(pos)), dfs(grid, number + 1, moveRight(pos)));
            }
            if (isInfi)
                return Integer.MAX_VALUE;
            else
                return Math.min(A, B);
        } else {//死胡同
            return Integer.MAX_VALUE;
        }
    }

    private boolean isDestination(int[][] pos, int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        return pos[0][0] == m - 1 && pos[0][1] == n - 2 &&
                pos[1][0] == m - 1 && pos[1][1] == n - 1;
    }

    private boolean isHorizen(int[][] pos) {
        return pos[0][0] == pos[1][0];
    }

    private boolean isVertical(int[][] pos) {
        return pos[0][1] == pos[1][1];
    }

    private int[][] moveRight(int[][] pos) {
        return new int[][]{{pos[0][0], pos[0][1] + 1},
                {pos[1][0], pos[1][1] + 1}};
    }

    private int[][] moveDown(int[][] pos) {
        return new int[][]{{pos[0][0] + 1, pos[0][1]},
                {pos[1][0] + 1, pos[1][1]}};
    }

    //需要是水平的朝向
    private int[][] clockRotate(int[][] pos) {
        return new int[][]{
                {pos[0][0], pos[0][1]},
                {1 + pos[1][0], pos[0][1]}
        };

    }

    private int[][] counterClockRotate(int[][] pos) {
        return new int[][]{
                {pos[0][0], pos[0][1]},
                {pos[0][0], 1 + pos[0][1]},
        };
    }
```

这里我借鉴了讨论区大家的想法，在这里做一个分享

遇到 `shortest path` , 大家的反应是使用 **BFS** . 

**BFS**的最简单形式为

```
在某一个点上, 遍历所有的邻接点 , 将邻接点全部push到队列中 ;
下一轮迭代中对出队列的节点做同样的操作
```

这里贴出我觉得写得比较清楚的答案。反思一下, 我并没有进行对象化, 其实抽象成对象可以让实现变得方便很多

```java
class Solution {
    public int minimumMoves(int[][] grid) {
        int n = grid.length, res = 0;
        Queue<Snake> q = new ArrayDeque<>();
        int[][] seen = new int[n][n];
        // Tail has been pos (i,j), the horizontal/vertical direcitional traversed has been represented as 1 & 2 respectively
        seen[0][0] = 1; 
        q.offer(new Snake('H', 0, 0));
        while(!q.isEmpty()) {
            int size = q.size();
            System.out.println(size);
            for(int i = 0; i < size; i++) {
                Snake s = q.poll();
                if (s.dir == 'H' && s.r == n -1 && s.c == n -2) return res;
                Snake down = move(grid, seen, new Snake(s.dir, s.r + 1, s.c), 'D');
                Snake right = move(grid, seen, new Snake(s.dir, s.r, s.c + 1), 'R');
                char dir = (s.dir == 'H' ? 'V' : 'H');
                Snake clock = move(grid, seen, new Snake(dir,s.r,s.c), 'C');
                if (right != null) q.offer(right);
                if (down != null) q.offer(down);
                if (clock != null) q.offer(clock);
            }
            res++;
        }
        return -1;
    }
    
    Snake move(int[][] grid, int[][] seen, Snake s, char action) {
        int r0 = s.r, c0 = s.c, n = grid.length, r1 = r0, c1 = c0;
        char dir= s.dir;
        if (r0 >= n || c0 >= n || grid[r0][c0] == 1 || seen[r0][c0] == 3 || (seen[r0][c0] == 1 && dir == 'H') || (seen[r0][c0] == 2 && dir == 'V')) return null;
        if (dir == 'H') {
            c1 = c0 + 1;
            r1 = r0;
        } else if (dir == 'V') {
            c1 = c0;
            r1 = r0 + 1;
        }
        if (r1 >= n || c1 >= n || grid[r1][c1] == 1) return null;
        if (action == 'C' && (grid[r0 + 1][c0+1] == 1 || grid[r0 + 1][c0] == 1 && grid[r0][c0+1] == 1)) return null;
        seen[r0][c0] += dir == 'H' ? 1 : 2;
        return s;
    }
    
    class Snake {
        char dir; // 'H' or 'V'
        int r; // tail row
        int c; //tail column
        public Snake(char dir, int r, int c) {
            this.dir = dir;
            this.r = r;
            this.c = c;
        }
    }
}
```

基于这个, 我们继续把之前的代码进行修改, 如下

```java
import java.util.ArrayDeque;
import java.util.Queue;

public class Solution {
    class Snake {
        int tail_r;
        int tail_c;
        char direction; //'H' / 'V'

        public Snake(int tail_r, int tail_c, char d) {
            this.tail_r = tail_r;
            this.tail_c = tail_c;
            this.direction = d;
        }

        public Snake moveRight() {
            return new Snake(this.tail_r, this.tail_c + 1, direction);
        }

        public Snake moveDown() {
            return new Snake(this.tail_r + 1, this.tail_c, direction);
        }

        public Snake rotate() {
            char direction = this.direction == 'H' ? 'V' : 'H';
            return new Snake(this.tail_r, this.tail_c, direction);
        }

        public int[][] fetchPos() {
            if (this.direction == 'H') {
                return new int[][]{
                        {tail_r, tail_c},
                        {tail_r, tail_c + 1}
                };
            } else {
                return new int[][]{
                        {tail_r, tail_c},
                        {tail_r + 1, tail_c}
                };
            }
        }
    }

    public int minimumMoves(int[][] grid) {
        Snake s = new Snake(0, 0, 'H');
        int n = grid.length;
        int ans = 0;
        Queue<Snake> q = new ArrayDeque<>();
        q.offer(s);
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; ++i) {
                Snake snake = q.poll();
                if (isDestination(snake.fetchPos(), grid)) return ans;
                Snake down = null, right = null, rotate = null;
                //move down
                if (snake.direction == 'H' && snake.tail_r + 1 < n && snake.tail_c + 1 < n) {
                    if (grid[snake.tail_r + 1][snake.tail_c] == 0 &&
                            grid[snake.tail_r + 1][snake.tail_c + 1] == 0) {
                        grid[snake.tail_r + 1][snake.tail_c]
                                = grid[snake.tail_r + 1][snake.tail_c + 1]
                                = 1;
                        down = snake.moveDown();
                    }
                } else if (snake.direction == 'V' && snake.tail_r + 2 < n) {
                    if (grid[snake.tail_r + 2][snake.tail_c] == 0) {
                        grid[snake.tail_r + 2][snake.tail_c] = 1;
                        down = snake.moveDown();
                    }
                }
                //move right
                if (snake.direction == 'H' && snake.tail_c + 2 < n) {
                    if (grid[snake.tail_r][snake.tail_c + 2] == 0) {
                        grid[snake.tail_r][snake.tail_c + 2] = 1;
                        right = snake.moveRight();
                    }
                } else if (snake.direction == 'V' && snake.tail_c + 1 < n && snake.tail_r + 1 < n) {
                    if (grid[snake.tail_r + 1][snake.tail_c] == 0 &&
                            grid[snake.tail_r + 1][snake.tail_c + 1] == 0) {
                        grid[snake.tail_r + 1][snake.tail_c] = grid[snake.tail_r + 1][snake.tail_c + 1] = 1;
                        right = snake.moveRight();
                    }
                }
                //rotate clockwise
                if (snake.direction == 'H' && snake.tail_c + 1 < n && snake.tail_r + 1 < n) {
                    if (grid[snake.tail_r + 1][snake.tail_c] == 0 &&
                            grid[snake.tail_r + 1][snake.tail_c + 1] == 0) {
                        rotate = snake.rotate();
                    }
                } else if (snake.direction == 'V' && snake.tail_c + 1 < n && snake.tail_r + 1 < n) {
                    if (grid[snake.tail_r][snake.tail_c + 1] == 0 &&
                            grid[snake.tail_r + 1][snake.tail_c + 1] == 0) {
                        rotate = snake.rotate();
                    }
                }
                if (null != right) q.offer(right);
                if (null != down) q.offer(down);
                if (null != rotate) q.offer(rotate);
            }
            ++ans;
        }

        return -1;
    }

    private boolean isDestination(int[][] pos, int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        return pos[0][0] == m - 1 && pos[0][1] == n - 2 &&
                pos[1][0] == m - 1 && pos[1][1] == n - 1;
    }


    //[[0,0,0,0,0,1],[1,1,0,0,1,0],[0,0,0,0,1,1],[0,0,1,0,1,0],[0,1,1,0,0,0],[0,1,1,0,0,0]]
    public static void main(String[] args) {
        System.out.println(new Solution().minimumMoves(new int[][]{
                {0, 0, 0, 0, 0, 1}, {1, 1, 0, 0, 1, 0}, {0, 0, 0, 0, 1, 1}, {0, 0, 1, 0, 1, 0}, {0, 1, 1, 0, 0, 0}, {0, 1, 1, 0, 0, 0}
        }));
    }
}

```



## 总结

这次周赛 AC 了三个题, 前面三个题目用时30分钟. 最后一个题抖抖索索不太敢写下去, 其实还是深度优先遍历的使用, 也暴露了我对于这些算法使用的不熟悉

