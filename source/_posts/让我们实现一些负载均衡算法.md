---
title: 自己动手实现负载均衡算法
date: 2020-04-02 22:32:27
tags: coding
cover_img: https://images.unsplash.com/photo-1584843863029-1bf7e8312a64?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1349&q=80
feature_img: https://images.unsplash.com/12/car.jpg?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1429&q=80
description:
keywords:
---

#### 背景

最近在看 `dubbo` ，它的服务治理当中有很大一个方面讲的就是负载均衡。由于我们的服务提供者可以有多个 `replication` ，究竟选择哪一个比较合适，就成为了我们需要去思考的一个问题。完全出于兴趣使然，我打算动手实现一下常见的负载均衡算法，来让自己加深一下理解。根据一个非常常见的请求调用，以参数作为请求内容，来判定多个备用选项中的选择策略制定

设计了类 `Provider` 和 `Consumer` ，分别表示服务提供者和消费者。由消费者进行触发，来选取 `N` 个服务提供者的负载均衡策略。

```java
/**
 * Entity
 */
public class Provider {
	private String id;                //id信息
	private double weight;            //价值权重
	private long milliseconds;        //响应时间

	public Provider(String id,  double weight, long milliseconds) {
		this.id = id;
		this.weight = weight;
		this.milliseconds = milliseconds;
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public double getWeight() {
		return weight;
	}

	public void setWeight(double weight) {
		this.weight = weight;
	}

	public long getMilliseconds() {
		return milliseconds;
	}

	public void setMilliseconds(long milliseconds) {
		this.milliseconds = milliseconds;
	}

	@Override
	public String toString() {
		return String.format("id:%s\tweight:%f\tlatency:%d",
				id, weight, milliseconds);
	}
}
```



#### LRU算法

如下是我的实现策略，内部维护一个 `lruQueue` 队列，队头表示最少访问的节点，当访问某一个节点之后，直接把这个节点移动到队尾即可

```java
/**
 * 最近最少使用优先
 */
public class LruHandler implements BalanceHandler {
	private Queue<Provider> lruQueue = new LinkedList<>();
	private int providerCnt =0;

	public void run(List<Provider> providerList) {
		this.providerCnt = providerList.size();
		lruQueue.addAll(providerList);
		assert this.providerCnt >= 1;
		System.out.println(String.format("Start choosing from all of the %d providers", this.providerCnt));
		while (true) {
			try {
				//choose random first
				Random ran = new Random();
				int idx = ran.nextInt(this.providerCnt - 1);
				System.out.println(String.format("Choose provider %d", idx));
				//choose idx and move it to
				Provider chosenP = providerList.get(idx);
				System.out.println(String.format("The provider infomation is %s", chosenP.toString()
				));
				lruQueue.remove(chosenP);
				lruQueue.offer(chosenP);
				System.out.println(String.format("The current queue:%s", queueToStr()));
				System.out.println("============================================================");

				Thread.sleep(4000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	private String queueToStr() {
		StringBuilder sb = new StringBuilder();
		sb.append('\t');
		for (Provider p : this.lruQueue) {
			sb.append(p.getId()).append("\t");
		}
		return sb.toString();
	}
}
```

#### 随机选取算法

这一个随机化的选取算法主要采取了 `weight` 来进行权重排序，其实 `Dubbo` 里面基于最少活跃度的算法，也是一个特定的优先级队列。这些基于优先级队列的负载均衡算法，直接可以根据权值排序就能够得到

```java
/**
 * 随机加权选取
 */
public class RandomWeightHandler implements BalanceHandler {

	@Override
	public void run(List<Provider> providerList) {
		int size = providerList.size();

		while (true) {
			try {
				System.out.println(String.format("The pre queue:%s", queueToStr(providerList)));
				// change all of the provider weight
				for (int i = 0; i < size; ++i) {
					Provider en = providerList.get(i);
					en.setWeight(new Random().nextDouble());
					providerList.set(i, en);
				}
				providerList.sort((o1, o2) -> {
					if (o1.getWeight() < o2.getWeight()) return 1;
					else return -1;
				});
				Provider p = providerList.get(0);
				System.out.println(String.format("The provider information is %s", p.toString()));
				System.out.println(String.format("The current queue:%s", queueToStr(providerList)));
				System.out.println("========================================================");

				Thread.sleep(4000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	private String queueToStr(List<Provider> queue) {
		StringBuilder sb = new StringBuilder();
		sb.append('\t');
		for (Provider p : queue) {
			sb.append(p.getId()).append("\t");
		}
		return sb.toString();
	}
}
```

