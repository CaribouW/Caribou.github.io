---
title: 数据库-索引
date: 2019-12-05 21:54:56
author: Caribou
tags: 
  - 笔记
categories: 
  - 笔记
description: 数据库索引相关内容
cover_img: https://images.unsplash.com/photo-1533750204176-3b0d38e9ac1e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80
feature_img: https://images.unsplash.com/photo-1504639725590-34d0984388bd?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80
---

## 索引

#### 页存储

<img src="https://i.loli.net/2019/12/05/dQE6NVkHZJcWfye.png" style="zoom:50%;" />

如上就是数据库在Disk Storage的一个存储方式。一个页包含若干 *Data Rows* , 通过 *Row directory* 来进行索引

> A row in a table can be uniquely specified with the page number (P) and slot number (S).

##### 位图索引

https://www.cnblogs.com/LBSer/p/3322630.html

位图索引中只维护distinct值，也就是说重复的值是不维护在树中

对于每一个列建立一个

- 位图索引适合只有几个固定值的列，如性别、婚姻状况、行政区等等，而身份证号这种类型不适合用位图索引。

- 此外，位图索引适合静态数据，而不适合索引频繁更新的列

##### 散列索引

散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。

散列索引根据对应键的散列码来找到最终的索引项的技术，其实和B树就差不多，也就是一种索引之上的二级辅助索引，我理解散列索引都是二级或更高级的稀疏索引，否则桶就太多了，效率也不会很高

##### 聚簇索引

所谓聚簇索引，就是指**主索引文件**和**数据文件**为==同一份文件==，聚簇索引主要用在**Innodb**存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，如下图所示：

在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

##### 非聚簇索引

聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接**指向对应数据块**。

##### 辅助索引

在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要**二次查找**。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据叶，再通过数据叶中的Page Directory找到数据行

##### 唯一索引

表明此索引的==每一个索引值只对应唯一的数据记录==，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复

##### 主键索引

在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问

---

数据库引擎 ：myISAM , innodb

myisam索引：因为myisam的索引和数据是分开存储存储的，myisam通过**key_buffer**把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因  

innodb索引：innodb的数据和索引放在一起，当找到索引也就找到了数据

<img src="https://img-blog.csdn.net/20161102111454921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:75%;" />

1.对于**非聚簇索引表**来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。

2.对于**聚簇索引表**来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)

> ##### 聚簇索引的优点
>
> 1.当你需要取出==一定范围内==的数据时，用聚簇索引也比用非聚簇索引好。
>
> 2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。
>
> 3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。
>
> ##### 聚簇索引的缺点
>
> 1.**插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。
>
> 2.**更新主键的代价很高，因为将会导致被更新的行移动**。因此，对于InnoDB表，我们一般定义主键为不可更新。
>
> 3.**二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。**
>
> 二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。
>
> 4.**采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多**，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。



