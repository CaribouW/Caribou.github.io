---
title: TCP-IP-阅读笔记-2 加密算法
date: 2020-02-17 19:50:35
tags: 笔记
cover_img: https://images.unsplash.com/photo-1566664345779-062ed10879e0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1267&q=80
feature_img: https://images.unsplash.com/photo-1581893106728-1e2197903b0a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
description:
keywords:
---

## 从HTTPs说起

现实中和加密有关的网络攻击可以大致分为两种：**被动攻击**和 **主动攻击**。其中被动指的是攻击者窃听数据，信息传输双方很可能不知道攻击者的存在；而主动攻击更多的就是数据的伪造，直接导致信息传输中的数据改变。

我们常见的数据传输有如下

### 对称加密

指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。
常见的对称加密算法：DES，AES等。

一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下：

```
明文 <-> 密钥 <-> 密文
```

这样的一种信息传输方式虽然**高效**，但是非常容易被第三方获取到密钥。一旦密钥泄露，那么被动攻击和主动攻击就都有可能。

### 非对称加密

每个人生成一个“私钥-公钥”对

> 使用私钥加密的信息，只能由该私钥对应的公钥才能解密，使用公钥加密的信息，只能由该公钥对应的私钥才能解密

```
然后可以把你的public key分发给想给你传密文的用户，然后用户使用该public key加密过得密文，只有使用你的private key才能解密
```

简而言之，每一方自己生成 *private-public* 对，私钥由自己所有，而公钥可以自由地进行分享。通过这种方式进行的数据传输，相比之前的对称加密明显要安全很多——第三方在不知道私钥的情况下，无法窃听到传输的明文内容

但这种方式无法避免**主动攻击**，也就是说，如果第三方在中间截获了某一方(**A**)的公钥，随后将自己的公钥进行替换 (美其名曰**偷梁换柱**)，让另一方(**B**)用 **假的** 公钥进行数据加密，那么这样第三方就可以轻松获取到**B**发送的信息；同时也可以往他们其中的某一方进行虚假数据的传输

### HTTPs协议出场

> 在我个人的理解当中，https兼并了对称加密和非对称加密，通过 **三对随机数** 来进行协商，随后实现 **每一次交互都可以生成不同的密钥条件下的对称加密传输**
>

 加粗的句话略有点绕口，我们慢慢说开来。

在HTTPs下，我们的研究对象从原来的两个，增加另一个第三方——**证书(颁发者)**。我们可以简单地想成另外一对公钥私钥。那么现在我们就有了三对公钥和私钥，接下来的工作就是依据某一个协议来利用好这三对。

#### 准备工作

假定证书一方足够可靠 (也会出现证书造假的不安全情况发生，这里不提)，另外两方我们设定为**服务端**和**客户端**。

- 对于服务端和客户端，都可以获取到证书的**公钥**
- 服务端需要在协商之前 (连接建立之前)，将自己的公钥发给证书一方，如果服务端可以进行认证，那么服务端可以收到 **由证书方的私钥加密过后的公钥**，如下图：

<img src="https://showme.codes/assets/images/2017-2-20-292372-f3dd4b7370df950e.png" alt="第一版数字证书的内容"  />

#### 协商

这样一来，我们的准备工作也就差不多了。那么之前那个密钥协商过程是如何进行的呢？

- 首先进行常规的 TCP 三次握手工作
- SSL一层建立在 TCP之上，HTTP之下。三次握手结束之后，**客户端** 发送一个 `client hello` 给服务端，其中包含了如下内容：
  - 可支持的加密算法和版本
  - 客户端生成的第一个随机数 **random1**

- **服务端** 收到信息之后，需要验证是否兼容 **加密算法和版本** (不兼容就不能继续进行接下来的协商了)；若兼容，那么服务端生成第二个随机数 **random2** ，并且把我们之前服务端向证书机构加密过后的公钥也一起发送给 **客户端**。称这一步为 `serverhello`
- **客户端** 需要先对服务端进行一下身份验证，在 CA 中验证合法性。验证通过之后，就可以使用证书颁发者的公钥，解密**得到服务端的公钥**。随后，客户端生成第三个随机数 **random3** ，使用服务端的公钥进行加密，再送回给服务端，我们称这个密文为 `PreMaster Key`
- 服务端可以用自己的私钥，解密 `PreMaster Key` ， 得到第三个随机数。至此，三个随机数、此次HTTPs交互的加密算法，在两边都已经协商完成。只需要根据`加密算法 + 三个随机数`共同生成一个密钥，两方就可以得到一致的对称密钥
- 此后的传输，直接可以使用该对称密钥进行加密解密

#### 更多的思考

> 为什么需要三个随机数？
>
> 保证每一次交互 (http连接) 之初生成的密钥具有随机性(加密算法可变，三个随机数可变)，那么居心叵测之人就无法得到密钥和加密算法内容