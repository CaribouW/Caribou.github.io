---
title: LC周赛 2019-10-05
date: 2019-10-08 09:57:04
tags: 
  - competition
categories: 
  - 算法
description: 20191005周赛记录
---

## 1. Play with Chips

### 描述

There are some chips, and the i-th chip is at position `chips[i]`.

You can perform any of the two following types of moves **any number of times** (possibly zero) **on any chip**:

- Move the `i`-th chip by 2 units to the left or to the right with a cost of **0**.
- Move the `i`-th chip by 1 unit to the left or to the right with a cost of **1**.

There can be two or more chips at the same position initially.

Return the minimum cost needed to move all the chips to the same position (any position).

### 思路 

如果两个chip的位置相差为偶数, 则 `cost = 0`. 否则 `coust = 1 `

我们预先获取chip的一个哈希来进行缓存, 之后遍历哈希中的每一个数, 作为 **目的地**.

那么我们的问题就变成 ： 找出那一个 **目的地** , 使得 `cost` 最小即可

```java
    public int minCostToMoveChips(int[] chips) {
        Set<Integer> set = new HashSet<>();
        for (int num : chips) {
            set.add(num);
        }
        int min = Integer.MAX_VALUE;
        for (int num : set) {
            int sum = 0;
            for (int chip : chips) {
                int dis = Math.abs(num - chip);
                sum += dis % 2;
                if (sum > min) break;
            }
            min = Math.min(sum, min);
        }
        return min;
    }
```

## 2. Longest Arithmetic Subsequence of Given Difference

### 描述

Given an integer array `arr` and an integer `difference`, return the length of the longest subsequence in `arr` which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals `difference`.

**Example 1:**

```
Input: arr = [1,2,3,4], difference = 1
Output: 4
Explanation: The longest arithmetic subsequence is [1,2,3,4].
```

**Example 2:**

```
Input: arr = [1,3,5,7], difference = 1
Output: 1
Explanation: The longest arithmetic subsequence is any single element.
```

**Example 3:**

```
Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2
Output: 4
Explanation: The longest arithmetic subsequence is [7,5,3,1].
```

### 思路

一开始很明显想到用 `DP` 来解决. 每一步前进的同时需要缓存下当前位置, 便于后续的查找

我们缓存如下的内容：

- 每一个数字和它所处可能位置 `Set` 的哈希映射
- DP 数组，用于当前 `dp[i]` 的确定

一开始就这样做了，但是 error 了一次. 原因就是这里的 dp 数组并不是单调上升，因为可能会出现中间断层的情况，例如 `[1,2,3,1,2,3,4]` , 中间的 `1` 位置就是断层的出现点. (之后一想，其实也可以通过自己的维护来进行避免，问题不大)

最终代码如下

```java
 public int longestSubsequence(int[] arr, int difference) {
        int n = arr.length;
        int[] dp = new int[n];
        Map<Integer, Set<Integer>> map = new HashMap<>();
        dp[0] = 1;
        Set<Integer> set = new HashSet<>();
        set.add(0);
        map.put(arr[0], set);
        for (int i = 1; i < n; ++i) {
            if (!map.containsKey(arr[i])) {
                set = new HashSet<>();
                set.add(i);
                map.put(arr[i], set);
            } else {
                set = map.get(arr[i]);
                set.add(i);
                map.put(arr[i], set);
            }

            int target = arr[i] - difference;
            if (!map.containsKey(target)) { //不包含前一个数
                dp[i] = 1;
            } else {
                set = map.get(target);
                int maxLen = 0;
                for (int num : set) {
                    maxLen = Math.max(maxLen, dp[num]);
                }
                dp[i] = maxLen + 1;
            }
        }
        int ans = 0;
        for (int num : dp) {
            ans = Math.max(num, ans);
        }
        return ans;
    }
```

## 3. Path with Maximum Gold

### 描述

In a gold mine `grid` of size `m * n`, each cell in this mine has an integer representing the amount of gold in that cell, `0` if it is empty.

Return the maximum amount of gold you can collect under the conditions:

- Every time you are located in a cell you will collect all the gold in that cell.
- From your position you can walk one step to the left, right, up or down.
- You can't visit the same cell more than once.
- Never visit a cell with `0` gold.
- You can start and stop collecting gold from **any** position in the grid that has some gold. 

**Example 1:**

```
Input: grid = [[0,6,0],[5,8,7],[0,9,0]]
Output: 24
Explanation:
[[0,6,0],
 [5,8,7],
 [0,9,0]]
Path to get the maximum gold, 9 -> 8 -> 7.
```

**Example 2:**

```
Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
Output: 28
Explanation:
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
Path to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.
```

### 思路

很简单的 DFS 算法实现, 没什么好说的

```java
public int getMaximumGold(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int max = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] != 0) {
                    max = Math.max(max, dfs(grid, new int[]{i, j}, 0));
                }
            }
        }
        return max;
    }

    private int dfs(int[][] grid, int[] startPos, int gold) {
        int m = grid.length, n = grid[0].length;
        int r = startPos[0], c = startPos[1];
        if (r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == 0) return gold;
        gold += grid[r][c];
        int[][] nums = new int[m][n];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                nums[i][j] = grid[i][j];
            }
        }
        nums[r][c] = 0;             //Get the gold
        int a1 = dfs(nums, new int[]{r, c + 1}, gold);
        int b1 = dfs(nums, new int[]{r, c - 1}, gold);
        int c1 = dfs(nums, new int[]{r + 1, c}, gold);
        int d1 = dfs(nums, new int[]{r - 1, c}, gold);
        return Arrays.stream(new int[]{a1, b1, c1, d1}).max().getAsInt();
    }
```

## 4. Count Vowels Permutation

### 描述

Given an integer `n`, your task is to count how many strings of length `n` can be formed under the following rules:

- Each character is a lower case vowel (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`)
- Each vowel `'a'` may only be followed by an `'e'`.
- Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.
- Each vowel `'i'` **may not** be followed by another `'i'`.
- Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.
- Each vowel `'u'` may only be followed by an `'a'.`

Since the answer may be too large, return it modulo `10^9 + 7.`

**Example 1:**

```
Input: n = 1
Output: 5
Explanation: All possible strings are: "a", "e", "i" , "o" and "u".
```

**Example 2:**

```
Input: n = 2
Output: 10
Explanation: All possible strings are: "ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" and "ua".
```

**Example 3:** 

```
Input: n = 5
Output: 68
```

### 思路

假定某一步的最末位中, ‘a’ , ‘e’ , ‘i’ , ‘o’ , ‘u’ 的个数分别是 a , e , i , o , u ，那么下一步末位的个数就分别是 `u+e+i`, `a + i`, `e + o` , `i` , `o +i` 

我这里用了一个hash来保存 (小声：这个hard题是简单题的赶脚233)

```java
class Solution {
private final long mod = 1_000_000_007;
    public int countVowelPermutation(int n) {
        Map<Character, Long> map = new HashMap<>();
        map.put('a', 1L);
        map.put('e', 1L);
        map.put('i', 1L);
        map.put('o', 1L);
        map.put('u', 1L);
        for (int i = 1; i < n; ++i) {
            Map<Character, Long> tmp = new HashMap<>();
            tmp.put('a', (map.get('u') + map.get('e') + map.get('i')) % mod);
            tmp.put('e', (map.get('a') + map.get('i')) % mod);
            tmp.put('i', (map.get('e') + map.get('o')) % mod);
            tmp.put('o', (map.get('i')) % mod);
            tmp.put('u', (map.get('o') + map.get('i')) % mod);

            map = tmp;
        }
        return (int) (map.values().stream().reduce(Long::sum).get() % mod);
    }
}
```

## 结语

这次周赛4个题目全部 AC , RANK  740