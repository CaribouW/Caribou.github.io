<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Caribou</title>
  
  
  <link href="/Caribou.github.io/atom.xml" rel="self"/>
  
  <link href="https://caribouw.github.io/Caribou.github.io/"/>
  <updated>2019-10-08T02:13:59.368Z</updated>
  <id>https://caribouw.github.io/Caribou.github.io/</id>
  
  <author>
    <name>Fangming Lu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LC周赛 2019-10-05</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/10/08/leetcode-%E5%91%A8%E8%B5%9B20191005/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/10/08/leetcode-周赛20191005/</id>
    <published>2019-10-08T01:57:04.000Z</published>
    <updated>2019-10-08T02:13:59.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Play-with-Chips"><a href="#1-Play-with-Chips" class="headerlink" title="1. Play with Chips"></a>1. Play with Chips</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>There are some chips, and the i-th chip is at position <code>chips[i]</code>.</p><p>You can perform any of the two following types of moves <strong>any number of times</strong> (possibly zero) <strong>on any chip</strong>:</p><ul><li>Move the <code>i</code>-th chip by 2 units to the left or to the right with a cost of <strong>0</strong>.</li><li>Move the <code>i</code>-th chip by 1 unit to the left or to the right with a cost of <strong>1</strong>.</li></ul><p>There can be two or more chips at the same position initially.</p><p>Return the minimum cost needed to move all the chips to the same position (any position).</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果两个chip的位置相差为偶数, 则 <code>cost = 0</code>. 否则 <code>coust = 1</code></p><p>我们预先获取chip的一个哈希来进行缓存, 之后遍历哈希中的每一个数, 作为 <strong>目的地</strong>.</p><p>那么我们的问题就变成 ： 找出那一个 <strong>目的地</strong> , 使得 <code>cost</code> 最小即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostToMoveChips</span><span class="params">(<span class="keyword">int</span>[] chips)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : chips) &#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : set) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> chip : chips) &#123;</span><br><span class="line">            <span class="keyword">int</span> dis = Math.abs(num - chip);</span><br><span class="line">            sum += dis % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; min) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        min = Math.min(sum, min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Longest-Arithmetic-Subsequence-of-Given-Difference"><a href="#2-Longest-Arithmetic-Subsequence-of-Given-Difference" class="headerlink" title="2. Longest Arithmetic Subsequence of Given Difference"></a>2. Longest Arithmetic Subsequence of Given Difference</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>Given an integer array <code>arr</code> and an integer <code>difference</code>, return the length of the longest subsequence in <code>arr</code> which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals <code>difference</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,2,3,4], difference = 1</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest arithmetic subsequence is [1,2,3,4].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,3,5,7], difference = 1</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The longest arithmetic subsequence is any single element.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest arithmetic subsequence is [7,5,3,1].</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>一开始很明显想到用 <code>DP</code> 来解决. 每一步前进的同时需要缓存下当前位置, 便于后续的查找</p><p>我们缓存如下的内容：</p><ul><li>每一个数字和它所处可能位置 <code>Set</code> 的哈希映射</li><li>DP 数组，用于当前 <code>dp[i]</code> 的确定</li></ul><p>一开始就这样做了，但是 error 了一次. 原因就是这里的 dp 数组并不是单调上升，因为可能会出现中间断层的情况，例如 <code>[1,2,3,1,2,3,4]</code> , 中间的 <code>1</code> 位置就是断层的出现点. (之后一想，其实也可以通过自己的维护来进行避免，问题不大)</p><p>最终代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = arr.length;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       Map&lt;Integer, Set&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       set.add(<span class="number">0</span>);</span><br><span class="line">       map.put(arr[<span class="number">0</span>], set);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!map.containsKey(arr[i])) &#123;</span><br><span class="line">               set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">               set.add(i);</span><br><span class="line">               map.put(arr[i], set);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               set = map.get(arr[i]);</span><br><span class="line">               set.add(i);</span><br><span class="line">               map.put(arr[i], set);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> target = arr[i] - difference;</span><br><span class="line">           <span class="keyword">if</span> (!map.containsKey(target)) &#123; <span class="comment">//不包含前一个数</span></span><br><span class="line">               dp[i] = <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               set = map.get(target);</span><br><span class="line">               <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> num : set) &#123;</span><br><span class="line">                   maxLen = Math.max(maxLen, dp[num]);</span><br><span class="line">               &#125;</span><br><span class="line">               dp[i] = maxLen + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num : dp) &#123;</span><br><span class="line">           ans = Math.max(num, ans);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3-Path-with-Maximum-Gold"><a href="#3-Path-with-Maximum-Gold" class="headerlink" title="3. Path with Maximum Gold"></a>3. Path with Maximum Gold</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>In a gold mine <code>grid</code> of size <code>m * n</code>, each cell in this mine has an integer representing the amount of gold in that cell, <code>0</code> if it is empty.</p><p>Return the maximum amount of gold you can collect under the conditions:</p><ul><li>Every time you are located in a cell you will collect all the gold in that cell.</li><li>From your position you can walk one step to the left, right, up or down.</li><li>You can’t visit the same cell more than once.</li><li>Never visit a cell with <code>0</code> gold.</li><li>You can start and stop collecting gold from <strong>any</strong> position in the grid that has some gold. </li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[0,6,0],[5,8,7],[0,9,0]]</span><br><span class="line">Output: 24</span><br><span class="line">Explanation:</span><br><span class="line">[[0,6,0],</span><br><span class="line"> [5,8,7],</span><br><span class="line"> [0,9,0]]</span><br><span class="line">Path to get the maximum gold, 9 -&gt; 8 -&gt; 7.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]</span><br><span class="line">Output: 28</span><br><span class="line">Explanation:</span><br><span class="line">[[1,0,7],</span><br><span class="line"> [2,0,6],</span><br><span class="line"> [3,4,5],</span><br><span class="line"> [0,3,0],</span><br><span class="line"> [9,0,20]]</span><br><span class="line">Path to get the maximum gold, 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7.</span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>很简单的 DFS 算法实现, 没什么好说的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximumGold</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    max = Math.max(max, dfs(grid, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span>[] startPos, <span class="keyword">int</span> gold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> r = startPos[<span class="number">0</span>], c = startPos[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= m || c &gt;= n || grid[r][c] == <span class="number">0</span>) <span class="keyword">return</span> gold;</span><br><span class="line">        gold += grid[r][c];</span><br><span class="line">        <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                nums[i][j] = grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[r][c] = <span class="number">0</span>;             <span class="comment">//Get the gold</span></span><br><span class="line">        <span class="keyword">int</span> a1 = dfs(nums, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c + <span class="number">1</span>&#125;, gold);</span><br><span class="line">        <span class="keyword">int</span> b1 = dfs(nums, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c - <span class="number">1</span>&#125;, gold);</span><br><span class="line">        <span class="keyword">int</span> c1 = dfs(nums, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r + <span class="number">1</span>, c&#125;, gold);</span><br><span class="line">        <span class="keyword">int</span> d1 = dfs(nums, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r - <span class="number">1</span>, c&#125;, gold);</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a1, b1, c1, d1&#125;).max().getAsInt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-Count-Vowels-Permutation"><a href="#4-Count-Vowels-Permutation" class="headerlink" title="4. Count Vowels Permutation"></a>4. Count Vowels Permutation</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>Given an integer <code>n</code>, your task is to count how many strings of length <code>n</code> can be formed under the following rules:</p><ul><li>Each character is a lower case vowel (<code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;u&#39;</code>)</li><li>Each vowel <code>&#39;a&#39;</code> may only be followed by an <code>&#39;e&#39;</code>.</li><li>Each vowel <code>&#39;e&#39;</code> may only be followed by an <code>&#39;a&#39;</code> or an <code>&#39;i&#39;</code>.</li><li>Each vowel <code>&#39;i&#39;</code> <strong>may not</strong> be followed by another <code>&#39;i&#39;</code>.</li><li>Each vowel <code>&#39;o&#39;</code> may only be followed by an <code>&#39;i&#39;</code> or a <code>&#39;u&#39;</code>.</li><li>Each vowel <code>&#39;u&#39;</code> may only be followed by an <code>&#39;a&#39;.</code></li></ul><p>Since the answer may be too large, return it modulo <code>10^9 + 7.</code></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: All possible strings are: &quot;a&quot;, &quot;e&quot;, &quot;i&quot; , &quot;o&quot; and &quot;u&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: All possible strings are: &quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; and &quot;ua&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 5</span><br><span class="line">Output: 68</span><br></pre></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>假定某一步的最末位中, ‘a’ , ‘e’ , ‘i’ , ‘o’ , ‘u’ 的个数分别是 a , e , i , o , u ，那么下一步末位的个数就分别是 <code>u+e+i</code>, <code>a + i</code>, <code>e + o</code> , <code>i</code> , <code>o +i</code> </p><p>我这里用了一个hash来保存 (小声：这个hard题是简单题的赶脚233)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mod = <span class="number">1_000_000_007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelPermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'a'</span>, <span class="number">1L</span>);</span><br><span class="line">        map.put(<span class="string">'e'</span>, <span class="number">1L</span>);</span><br><span class="line">        map.put(<span class="string">'i'</span>, <span class="number">1L</span>);</span><br><span class="line">        map.put(<span class="string">'o'</span>, <span class="number">1L</span>);</span><br><span class="line">        map.put(<span class="string">'u'</span>, <span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            Map&lt;Character, Long&gt; tmp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            tmp.put(<span class="string">'a'</span>, (map.get(<span class="string">'u'</span>) + map.get(<span class="string">'e'</span>) + map.get(<span class="string">'i'</span>)) % mod);</span><br><span class="line">            tmp.put(<span class="string">'e'</span>, (map.get(<span class="string">'a'</span>) + map.get(<span class="string">'i'</span>)) % mod);</span><br><span class="line">            tmp.put(<span class="string">'i'</span>, (map.get(<span class="string">'e'</span>) + map.get(<span class="string">'o'</span>)) % mod);</span><br><span class="line">            tmp.put(<span class="string">'o'</span>, (map.get(<span class="string">'i'</span>)) % mod);</span><br><span class="line">            tmp.put(<span class="string">'u'</span>, (map.get(<span class="string">'o'</span>) + map.get(<span class="string">'i'</span>)) % mod);</span><br><span class="line"></span><br><span class="line">            map = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (map.values().stream().reduce(Long::sum).get() % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次周赛4个题目全部 AC , RANK  740</p>]]></content>
    
    <summary type="html">
    
      20191005周赛记录
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="competition" scheme="https://caribouw.github.io/Caribou.github.io/tags/competition/"/>
    
  </entry>
  
  <entry>
    <title>LC周赛 2019-09-29</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/29/leetcode-20190929%E5%91%A8%E8%B5%9B/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/29/leetcode-20190929周赛/</id>
    <published>2019-09-28T23:50:40.000Z</published>
    <updated>2019-09-30T01:25:27.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Unique-Number-of-Occurrences"><a href="#1-Unique-Number-of-Occurrences" class="headerlink" title="1. Unique Number of Occurrences"></a>1. Unique Number of Occurrences</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Given an array of integers <code>arr</code>, write a function that returns <code>true</code> if and only if the number of occurrences of each value in the array is unique.</p><p>给出一个<code>int</code>数组中的各个数的 <strong>出现次数</strong> 是否唯一</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>可以直接利用 <strong>map</strong> 来存储各个数的出现次数, 而后进行 value-set 的值的比较即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : map.keySet()) &#123;</span><br><span class="line">            set.add(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().size() == set.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-Get-Equal-Substrings-Within-Budget"><a href="#2-Get-Equal-Substrings-Within-Budget" class="headerlink" title="2. Get Equal Substrings Within Budget"></a>2. Get Equal Substrings Within Budget</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>You are given two strings <code>s</code> and <code>t</code> of the same length. You want to change <code>s</code> to <code>t</code>. Changing the <code>i</code>-th character of <code>s</code> to <code>i</code>-th character of <code>t</code> costs <code>|s[i] - t[i]|</code> that is, the absolute difference between the ASCII values of the characters.</p><p>You are also given an integer <code>maxCost</code>.</p><p>Return the maximum length of a substring of <code>s</code> that can be changed to be the same as the corresponding substring of <code>t</code>with a cost less than or equal to <code>maxCost</code>.</p><p>If there is no substring from <code>s</code> that can be changed to its corresponding substring from <code>t</code>, return <code>0</code></p><p>给出两个长度<strong>相等</strong>的字符串,和一个 <code>cost</code>, 我们需要给出最长的子串长度, 来让其<code>|s[i] - t[i]|</code>之和不大于cost</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>首先可以把两个字符串相减——逐字符进行减计算，得到绝对值, 由此获取一个 <code>int</code> 数组</p><p>而后的问题变为：给定一个 <code>int</code> 数组和一个 <code>cost</code> , 求出最大子数组，来满足不大于 <code>cost</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(String s, String t, <span class="keyword">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] costs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            costs[i] = Math.abs(s.charAt(i) - t.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                sum += costs[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; maxCost) &#123;</span><br><span class="line">                    ans = Math.max(ans, j - i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-Remove-All-Adjacent-Duplicates-in-String-II"><a href="#3-Remove-All-Adjacent-Duplicates-in-String-II" class="headerlink" title="3.Remove All Adjacent Duplicates in String II"></a>3.Remove All Adjacent Duplicates in String II</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>Given a string <code>s</code>, a <em>k</em> <em>duplicate removal</em> consists of choosing <code>k</code> adjacent and equal letters from <code>s</code> and removing them causing the left and the right side of the deleted substring to concatenate together.</p><p>We repeatedly make <code>k</code> duplicate removals on <code>s</code> until we no longer can.</p><p>Return the final string after all such duplicate removals have been made.</p><p>It is guaranteed that the answer is unique.</p><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code> , 每次我们可以一次性删除 <code>s</code> 中的 <code>k</code> 个连续的并且所有字符相同的子串, 求出最后的结果</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>每一次根据 s , k 来从左往右查找满足该条件的子串, 返回一个长度为 <strong>2</strong> 的 <code>int</code> 数组, 作为满足该条件的 <strong>第一个</strong> 子串的指针, 逐个进行删除即可. </p><p>之后也可以进行进一步优化 ： 每一次查找的时候查询所有满足该条件的子串，一次性删除 , 再进行下一轮的查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] indexes = findDuplicates(s, k);</span><br><span class="line">      String ans = s;</span><br><span class="line">      <span class="keyword">while</span> (indexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">          ans = ans.substring(<span class="number">0</span>, indexes[<span class="number">0</span>]) + ans.substring(indexes[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">          indexes = findDuplicates(ans, k);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] findDuplicates(String s, <span class="keyword">int</span> k) &#123;</span><br><span class="line">      <span class="keyword">int</span> n = s.length();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">          <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">              <span class="keyword">if</span> (s.charAt(j) != ch)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (j - i + <span class="number">1</span> == k) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="4-Minimum-Moves-to-Reach-Target-with-Rotations"><a href="#4-Minimum-Moves-to-Reach-Target-with-Rotations" class="headerlink" title="4. Minimum Moves to Reach Target with Rotations"></a>4. Minimum Moves to Reach Target with Rotations</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>In an <code>n*n</code> grid, there is a snake that spans 2 cells and starts moving from the top left corner at <code>(0, 0)</code> and <code>(0, 1)</code>. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at <code>(n-1, n-2)</code> and <code>(n-1, n-1)</code>.</p><p>In one move the snake can:</p><ul><li>Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.</li><li>Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.</li><li>Rotate clockwise if it’s in a horizontal position and the two cells under it are both empty. In that case the snake moves from <code>(r, c)</code> and <code>(r, c+1)</code> to <code>(r, c)</code> and <code>(r+1, c)</code>.<br><img src="https://assets.leetcode.com/uploads/2019/09/24/image-2.png" alt="img"></li><li>Rotate counterclockwise if it’s in a vertical position and the two cells to its right are both empty. In that case the snake moves from <code>(r, c)</code> and <code>(r+1, c)</code> to <code>(r, c)</code> and <code>(r, c+1)</code>.<br><img src="https://assets.leetcode.com/uploads/2019/09/24/image-1.png" alt="img"></li></ul><p>Return the minimum number of moves to reach the target.</p><p>If there is no way to reach the target, return <code>-1</code>.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很典型的DFS题目，下一步的行走都将影响后续的结果. 蛇很有可能进入 <strong>死胡同</strong> , 也就是我们无法进行下一步的查找.</p><p>我这里单独实现了蛇的位置 (水平 / 垂直) 判定 , 蛇进行 <strong>左移、右移、顺时针旋转、逆时针旋转</strong> 的逻辑. 而后穷举所有可能的情况</p><p>//TODO: 这个代码还没AC ， 只过了 17 / 42 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] originPos = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = dfs(grid, <span class="number">0</span>, originPos);</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> number, <span class="keyword">int</span>[][] pos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//visited</span></span><br><span class="line">        grid[pos[<span class="number">0</span>][<span class="number">0</span>]][pos[<span class="number">0</span>][<span class="number">1</span>]] = grid[pos[<span class="number">1</span>][<span class="number">0</span>]][pos[<span class="number">1</span>][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (isDestination(pos, grid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = pos[<span class="number">0</span>][<span class="number">0</span>], b = pos[<span class="number">0</span>][<span class="number">1</span>], c = pos[<span class="number">1</span>][<span class="number">0</span>], d = pos[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (isHorizen(pos)) &#123;</span><br><span class="line">            <span class="comment">// ---&gt;</span></span><br><span class="line">            <span class="keyword">boolean</span> isInfi = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> A = Integer.MAX_VALUE, B = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (d + <span class="number">1</span> &lt; n &amp;&amp; grid[a][d + <span class="number">1</span>] == <span class="number">0</span>) &#123;     <span class="comment">//You could move right</span></span><br><span class="line">                isInfi = <span class="keyword">false</span>;</span><br><span class="line">                A = dfs(grid, number + <span class="number">1</span>, moveRight(pos));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a + <span class="number">1</span> &lt; m &amp;&amp; grid[a + <span class="number">1</span>][b] == <span class="number">0</span> &amp;&amp; grid[a + <span class="number">1</span>][b + <span class="number">1</span>] == <span class="number">0</span>) &#123;   <span class="comment">//You could rotate clock or down</span></span><br><span class="line">                isInfi = <span class="keyword">false</span>;</span><br><span class="line">                B = Math.min(dfs(grid, number + <span class="number">1</span>, clockRotate(pos)), dfs(grid, number + <span class="number">1</span>, moveDown(pos)));</span><br><span class="line">            &#125;                                <span class="comment">//死胡同</span></span><br><span class="line">            <span class="keyword">if</span> (isInfi)</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Math.min(A, B);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isVertical(pos)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isInfi = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> A = Integer.MAX_VALUE, B = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; m &amp;&amp; grid[c + <span class="number">1</span>][b] == <span class="number">0</span>) &#123;             <span class="comment">//You could move downWard</span></span><br><span class="line">                isInfi = <span class="keyword">false</span>;</span><br><span class="line">                A = dfs(grid, number + <span class="number">1</span>, moveDown(pos));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b + <span class="number">1</span> &lt; n &amp;&amp; grid[a][b + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; grid[c][b + <span class="number">1</span>] == <span class="number">0</span>) &#123;   <span class="comment">//You could rotate counter or right</span></span><br><span class="line">                isInfi = <span class="keyword">false</span>;</span><br><span class="line">                B = Math.min(dfs(grid, number + <span class="number">1</span>, counterClockRotate(pos)), dfs(grid, number + <span class="number">1</span>, moveRight(pos)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isInfi)</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Math.min(A, B);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//死胡同</span></span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDestination</span><span class="params">(<span class="keyword">int</span>[][] pos, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">return</span> pos[<span class="number">0</span>][<span class="number">0</span>] == m - <span class="number">1</span> &amp;&amp; pos[<span class="number">0</span>][<span class="number">1</span>] == n - <span class="number">2</span> &amp;&amp;</span><br><span class="line">                pos[<span class="number">1</span>][<span class="number">0</span>] == m - <span class="number">1</span> &amp;&amp; pos[<span class="number">1</span>][<span class="number">1</span>] == n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isHorizen</span><span class="params">(<span class="keyword">int</span>[][] pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pos[<span class="number">0</span>][<span class="number">0</span>] == pos[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isVertical</span><span class="params">(<span class="keyword">int</span>[][] pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pos[<span class="number">0</span>][<span class="number">1</span>] == pos[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] moveRight(<span class="keyword">int</span>[][] pos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;pos[<span class="number">0</span>][<span class="number">0</span>], pos[<span class="number">0</span>][<span class="number">1</span>] + <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;pos[<span class="number">1</span>][<span class="number">0</span>], pos[<span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] moveDown(<span class="keyword">int</span>[][] pos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;pos[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1</span>, pos[<span class="number">0</span>][<span class="number">1</span>]&#125;,</span><br><span class="line">                &#123;pos[<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>, pos[<span class="number">1</span>][<span class="number">1</span>]&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要是水平的朝向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] clockRotate(<span class="keyword">int</span>[][] pos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;pos[<span class="number">0</span>][<span class="number">0</span>], pos[<span class="number">0</span>][<span class="number">1</span>]&#125;,</span><br><span class="line">                &#123;<span class="number">1</span> + pos[<span class="number">1</span>][<span class="number">0</span>], pos[<span class="number">0</span>][<span class="number">1</span>]&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] counterClockRotate(<span class="keyword">int</span>[][] pos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;pos[<span class="number">0</span>][<span class="number">0</span>], pos[<span class="number">0</span>][<span class="number">1</span>]&#125;,</span><br><span class="line">                &#123;pos[<span class="number">0</span>][<span class="number">0</span>], <span class="number">1</span> + pos[<span class="number">0</span>][<span class="number">1</span>]&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我借鉴了讨论区大家的想法，在这里做一个分享</p><p>遇到 <code>shortest path</code> , 大家的反应是使用 <strong>BFS</strong> . </p><p><strong>BFS</strong>的最简单形式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在某一个点上, 遍历所有的邻接点 , 将邻接点全部push到队列中 ;</span><br><span class="line">下一轮迭代中对出队列的节点做同样的操作</span><br></pre></td></tr></table></figure><p>这里贴出我觉得写得比较清楚的答案。反思一下, 我并没有进行对象化, 其实抽象成对象可以让实现变得方便很多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length, res = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Snake&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] seen = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="comment">// Tail has been pos (i,j), the horizontal/vertical direcitional traversed has been represented as 1 &amp; 2 respectively</span></span><br><span class="line">        seen[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        q.offer(<span class="keyword">new</span> Snake(<span class="string">'H'</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            System.out.println(size);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Snake s = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (s.dir == <span class="string">'H'</span> &amp;&amp; s.r == n -<span class="number">1</span> &amp;&amp; s.c == n -<span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">                Snake down = move(grid, seen, <span class="keyword">new</span> Snake(s.dir, s.r + <span class="number">1</span>, s.c), <span class="string">'D'</span>);</span><br><span class="line">                Snake right = move(grid, seen, <span class="keyword">new</span> Snake(s.dir, s.r, s.c + <span class="number">1</span>), <span class="string">'R'</span>);</span><br><span class="line">                <span class="keyword">char</span> dir = (s.dir == <span class="string">'H'</span> ? <span class="string">'V'</span> : <span class="string">'H'</span>);</span><br><span class="line">                Snake clock = move(grid, seen, <span class="keyword">new</span> Snake(dir,s.r,s.c), <span class="string">'C'</span>);</span><br><span class="line">                <span class="keyword">if</span> (right != <span class="keyword">null</span>) q.offer(right);</span><br><span class="line">                <span class="keyword">if</span> (down != <span class="keyword">null</span>) q.offer(down);</span><br><span class="line">                <span class="keyword">if</span> (clock != <span class="keyword">null</span>) q.offer(clock);</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Snake <span class="title">move</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span>[][] seen, Snake s, <span class="keyword">char</span> action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r0 = s.r, c0 = s.c, n = grid.length, r1 = r0, c1 = c0;</span><br><span class="line">        <span class="keyword">char</span> dir= s.dir;</span><br><span class="line">        <span class="keyword">if</span> (r0 &gt;= n || c0 &gt;= n || grid[r0][c0] == <span class="number">1</span> || seen[r0][c0] == <span class="number">3</span> || (seen[r0][c0] == <span class="number">1</span> &amp;&amp; dir == <span class="string">'H'</span>) || (seen[r0][c0] == <span class="number">2</span> &amp;&amp; dir == <span class="string">'V'</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (dir == <span class="string">'H'</span>) &#123;</span><br><span class="line">            c1 = c0 + <span class="number">1</span>;</span><br><span class="line">            r1 = r0;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="string">'V'</span>) &#123;</span><br><span class="line">            c1 = c0;</span><br><span class="line">            r1 = r0 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r1 &gt;= n || c1 &gt;= n || grid[r1][c1] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="string">'C'</span> &amp;&amp; (grid[r0 + <span class="number">1</span>][c0+<span class="number">1</span>] == <span class="number">1</span> || grid[r0 + <span class="number">1</span>][c0] == <span class="number">1</span> &amp;&amp; grid[r0][c0+<span class="number">1</span>] == <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        seen[r0][c0] += dir == <span class="string">'H'</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> dir; <span class="comment">// 'H' or 'V'</span></span><br><span class="line">        <span class="keyword">int</span> r; <span class="comment">// tail row</span></span><br><span class="line">        <span class="keyword">int</span> c; <span class="comment">//tail column</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Snake</span><span class="params">(<span class="keyword">char</span> dir, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.dir = dir;</span><br><span class="line">            <span class="keyword">this</span>.r = r;</span><br><span class="line">            <span class="keyword">this</span>.c = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于这个, 我们继续把之前的代码进行修改, 如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tail_r;</span><br><span class="line">        <span class="keyword">int</span> tail_c;</span><br><span class="line">        <span class="keyword">char</span> direction; <span class="comment">//'H' / 'V'</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Snake</span><span class="params">(<span class="keyword">int</span> tail_r, <span class="keyword">int</span> tail_c, <span class="keyword">char</span> d)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tail_r = tail_r;</span><br><span class="line">            <span class="keyword">this</span>.tail_c = tail_c;</span><br><span class="line">            <span class="keyword">this</span>.direction = d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Snake <span class="title">moveRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Snake(<span class="keyword">this</span>.tail_r, <span class="keyword">this</span>.tail_c + <span class="number">1</span>, direction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Snake <span class="title">moveDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Snake(<span class="keyword">this</span>.tail_r + <span class="number">1</span>, <span class="keyword">this</span>.tail_c, direction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Snake <span class="title">rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">char</span> direction = <span class="keyword">this</span>.direction == <span class="string">'H'</span> ? <span class="string">'V'</span> : <span class="string">'H'</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Snake(<span class="keyword">this</span>.tail_r, <span class="keyword">this</span>.tail_c, direction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] fetchPos() &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.direction == <span class="string">'H'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                        &#123;tail_r, tail_c&#125;,</span><br><span class="line">                        &#123;tail_r, tail_c + <span class="number">1</span>&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                        &#123;tail_r, tail_c&#125;,</span><br><span class="line">                        &#123;tail_r + <span class="number">1</span>, tail_c&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        Snake s = <span class="keyword">new</span> Snake(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'H'</span>);</span><br><span class="line">        <span class="keyword">int</span> n = grid.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Snake&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.offer(s);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                Snake snake = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (isDestination(snake.fetchPos(), grid)) <span class="keyword">return</span> ans;</span><br><span class="line">                Snake down = <span class="keyword">null</span>, right = <span class="keyword">null</span>, rotate = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//move down</span></span><br><span class="line">                <span class="keyword">if</span> (snake.direction == <span class="string">'H'</span> &amp;&amp; snake.tail_r + <span class="number">1</span> &lt; n &amp;&amp; snake.tail_c + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[snake.tail_r + <span class="number">1</span>][snake.tail_c] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            grid[snake.tail_r + <span class="number">1</span>][snake.tail_c + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        grid[snake.tail_r + <span class="number">1</span>][snake.tail_c]</span><br><span class="line">                                = grid[snake.tail_r + <span class="number">1</span>][snake.tail_c + <span class="number">1</span>]</span><br><span class="line">                                = <span class="number">1</span>;</span><br><span class="line">                        down = snake.moveDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snake.direction == <span class="string">'V'</span> &amp;&amp; snake.tail_r + <span class="number">2</span> &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[snake.tail_r + <span class="number">2</span>][snake.tail_c] == <span class="number">0</span>) &#123;</span><br><span class="line">                        grid[snake.tail_r + <span class="number">2</span>][snake.tail_c] = <span class="number">1</span>;</span><br><span class="line">                        down = snake.moveDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//move right</span></span><br><span class="line">                <span class="keyword">if</span> (snake.direction == <span class="string">'H'</span> &amp;&amp; snake.tail_c + <span class="number">2</span> &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[snake.tail_r][snake.tail_c + <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        grid[snake.tail_r][snake.tail_c + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                        right = snake.moveRight();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snake.direction == <span class="string">'V'</span> &amp;&amp; snake.tail_c + <span class="number">1</span> &lt; n &amp;&amp; snake.tail_r + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[snake.tail_r + <span class="number">1</span>][snake.tail_c] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            grid[snake.tail_r + <span class="number">1</span>][snake.tail_c + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        grid[snake.tail_r + <span class="number">1</span>][snake.tail_c] = grid[snake.tail_r + <span class="number">1</span>][snake.tail_c + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                        right = snake.moveRight();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//rotate clockwise</span></span><br><span class="line">                <span class="keyword">if</span> (snake.direction == <span class="string">'H'</span> &amp;&amp; snake.tail_c + <span class="number">1</span> &lt; n &amp;&amp; snake.tail_r + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[snake.tail_r + <span class="number">1</span>][snake.tail_c] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            grid[snake.tail_r + <span class="number">1</span>][snake.tail_c + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        rotate = snake.rotate();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snake.direction == <span class="string">'V'</span> &amp;&amp; snake.tail_c + <span class="number">1</span> &lt; n &amp;&amp; snake.tail_r + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[snake.tail_r][snake.tail_c + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            grid[snake.tail_r + <span class="number">1</span>][snake.tail_c + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        rotate = snake.rotate();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != right) q.offer(right);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != down) q.offer(down);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != rotate) q.offer(rotate);</span><br><span class="line">            &#125;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDestination</span><span class="params">(<span class="keyword">int</span>[][] pos, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">return</span> pos[<span class="number">0</span>][<span class="number">0</span>] == m - <span class="number">1</span> &amp;&amp; pos[<span class="number">0</span>][<span class="number">1</span>] == n - <span class="number">2</span> &amp;&amp;</span><br><span class="line">                pos[<span class="number">1</span>][<span class="number">0</span>] == m - <span class="number">1</span> &amp;&amp; pos[<span class="number">1</span>][<span class="number">1</span>] == n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//[[0,0,0,0,0,1],[1,1,0,0,1,0],[0,0,0,0,1,1],[0,0,1,0,1,0],[0,1,1,0,0,0],[0,1,1,0,0,0]]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().minimumMoves(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次周赛 AC 了三个题, 前面三个题目用时30分钟. 最后一个题抖抖索索不太敢写下去, 其实还是深度优先遍历的使用, 也暴露了我对于这些算法使用的不熟悉</p>]]></content>
    
    <summary type="html">
    
      20190915周赛记录
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="competition" scheme="https://caribouw.github.io/Caribou.github.io/tags/competition/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-413 Arithmetic Slices</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/26/leetcode-413/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/26/leetcode-413/</id>
    <published>2019-09-26T12:15:02.000Z</published>
    <updated>2019-09-26T12:20:44.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p><p>For example, these are arithmetic sequence:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure><p>The following sequence is not arithmetic.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure><p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p><p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p><p>The function should return the number of arithmetic slices in the array A.</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>简单的DP问题. 每一次遇到 <code>dp[i]</code> 的时候, 需要考虑之前的 <strong>最长等差数列的长度</strong> .</p><p>如果最长等差数列的长度为 $n$ , 那么可以得到状态转移方程 <code>dp[i] = dp[i-1] + n​</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; n ; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + countArithLength(A,i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArithLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pad = A[endIndex] - A[endIndex - <span class="number">1</span>] , ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = endIndex<span class="number">-1</span> ; i &gt;= <span class="number">1</span> ; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] - A[i<span class="number">-1</span>] == pad) ++ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>speed 100% ;</p><p>mem 100%</p>]]></content>
    
    <summary type="html">
    
      等差数列计数
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-419 Battleships in a Board</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/24/leetcode-419/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/24/leetcode-419/</id>
    <published>2019-09-24T01:19:23.000Z</published>
    <updated>2019-09-24T01:27:56.546Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Given an 2D board, count how many battleships are in it. The battleships are represented with <code>&#39;X&#39;``&#39;.&#39;</code></p><ul><li>You receive a valid board, made of only battleships or empty slots.</li><li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape <code>1xN</code> (1 row, N columns) or <code>Nx1</code> (N rows, 1 column), where N can be of any size.</li><li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X..X</span><br><span class="line">...X</span><br><span class="line">...X</span><br></pre></td></tr></table></figure><p>In the above board there are <strong>2</strong> battleships.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始想到 DP 来做, 当前位置的数和三个数有关 : <code>dp[i-1][j-1] , dp[i][j-1] , dp[i-1][j]</code> . 当且仅当 : <code>board[i][j] = &#39;X&#39;</code> 并且左节点和上节点都是 <code>.</code> 时 , 战舰数目加一</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Solution::solutionDP(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board) &#123;</span><br><span class="line">    <span class="keyword">int</span> row = board.size();</span><br><span class="line">    <span class="keyword">int</span> col = board[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span> (row * col == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//construct the dp arr</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == dot)</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == ship)</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//首先进行边界的分析. 具体为 : 最左侧和最上侧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; col; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][i - <span class="number">1</span>] == dot &amp;&amp; board[<span class="number">0</span>][i] == ship)</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i - <span class="number">1</span>][<span class="number">0</span>] == dot &amp;&amp; board[i][<span class="number">0</span>] == ship)</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> basic = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//add a ship</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == ship &amp;&amp; board[i - <span class="number">1</span>][j] == dot &amp;&amp; board[i][j - <span class="number">1</span>] == dot) &#123;</span><br><span class="line">                dp[i][j] = basic + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = basic;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是后来一想，根本不需要这么麻烦啊. 谨记 ：当状态转移方程出现了 <code>dp[i][0] = dp[i - 1][0]</code> 这样的方式, 都是可以进行空间复杂度上的优化的 . 在这里就可以直接优化到 <code>O(1)</code>.</p><p>我们判定当前的 <code>board[i][j]</code>:</p><ul><li>如果是 <code>X</code>, 那么当且仅当 <code>board[i-1][j] , board[i][j-1]</code>都是 <code>.</code> 时需要把计数器加一</li><li>其他所有情况, 计数器不变即可</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Mem rank : 100 %</p><p>Speed rank : 99.4 %</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Solution::solutionOnePass(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board) &#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = board.size();</span><br><span class="line">    <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == ship &amp;&amp;</span><br><span class="line">                ((i == <span class="number">0</span> || board[i - <span class="number">1</span>][j] == dot)) &amp;&amp; (j == <span class="number">0</span> || board[i][j - <span class="number">1</span>] == dot)) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      计数二维矩阵中的战舰数目
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="One way pass" scheme="https://caribouw.github.io/Caribou.github.io/tags/One-way-pass/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-740 Delete and earn</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/23/leetcode-740%20/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/23/leetcode-740 /</id>
    <published>2019-09-23T15:23:08.000Z</published>
    <updated>2019-09-23T09:53:58.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除每个等于 <code>nums[i] - 1</code> 或 <code>nums[i] + 1</code> 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>典型的使用 DP . 每一次的pick选取都会导致近邻的元素被同时删除. 这时候我们就需要考虑 <code>选取pick的时候进行profit最大化</code> . 这样也有一点贪心算法的味道. 具体是不是我也不清楚hhh</p><p>首先需要得到数组的各个数产生的 <code>profit</code> 大小 , 这里我使用了一个数组 <code>profits</code> 来进行表示.</p><p>此后进行 <code>dp</code> 数组的维护, 状态转移方程分析如下 :</p><p>在选取位置 <strong>i</strong> 处的总效益时</p><ol><li>如果选取 <code>profit[i]</code> ，那么 <code>profit[i-1]</code> 必定没有被选取. 我们得到 <code>profit[i] + dp[i-2]</code></li><li>如果不选取 <code>profit[i]</code> , 那么就有 <code>dp[i] = dp[i-1]</code></li></ol><p>将如上两种情况进行最大值比较，状态转移方程如下 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max (dp[i-1] , dp[i-2] + profit[i])</span><br></pre></td></tr></table></figure><h3 id="Post-on-LC"><a href="#Post-on-LC" class="headerlink" title="Post on LC"></a>Post on LC</h3><p>The  <code>profit</code> means the total profit of the single number.<br>For example , the array [2,2,3,3,4] . The profit of <strong>2</strong> is <strong>4</strong>  and the profit of <strong>3</strong> is <strong>6</strong>. </p><p>Then we could maintain the <strong>dp</strong> array. That is : If we choose the current <strong>i</strong> to pick , the we cannot pick <strong>i-1</strong> . So if <strong>i-1</strong> is chosen , we have to check the dp[i-2] + profits[i] to see the total profit , otherwise we compare it with the dp[i-1]<br>Thus the <code>dp[i]=max(dp[i-1],dp[i-2]+profits[i])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10001</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; profits = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : nums)</span><br><span class="line">            profits[n]+=n;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>] = profits[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">2</span> ; i&lt; n ;++i)&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>],profits[i] + dp[i<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DP" scheme="https://caribouw.github.io/Caribou.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-513 Find Bottom Left Tree Value</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/17/leetcode-513/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/17/leetcode-513/</id>
    <published>2019-09-17T15:23:08.000Z</published>
    <updated>2019-09-17T02:22:02.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="513-寻找最深最左二叉树节点"><a href="#513-寻找最深最左二叉树节点" class="headerlink" title="513 寻找最深最左二叉树节点"></a>513 寻找最深最左二叉树节点</h2><p>Given a binary tree, find the leftmost value in the last row of the tree.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉树的层次序遍历. 但是有所不同的是, 需要判定每一层的开始位置 。所以我们在每一层queue push 进入之后，添加一个nullptr来进行标记</p><ul><li>当队列中第一次遇到 <code>nullptr</code> 处在队列末尾, 表示队首节点是最左侧 , 更新 <code>ans</code>。后续再次遇到 <code>nullptr</code> 在队尾时不再计入</li><li>当<code>nullptr</code>处在队首, 表示一行已经被遍历完全. 直接把 <code>nullptr</code> 重新放置到队尾. 置标记位为 <code>true</code></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>首先我们来看一下简单的二叉树层次序遍历的逻辑</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Solution::levelPrint(TreeNode *root) &#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">queue</span>.empty()) &#123;</span><br><span class="line">        <span class="comment">//visit</span></span><br><span class="line">        TreeNode *node = <span class="built_in">queue</span>.front();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; node-&gt;val &lt;&lt; <span class="string">","</span>;</span><br><span class="line">        <span class="comment">//pop</span></span><br><span class="line">        <span class="built_in">queue</span>.pop();</span><br><span class="line">        <span class="comment">//push back</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            <span class="built_in">queue</span>.push(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            <span class="built_in">queue</span>.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常明显，我们一直进行队列的出、入, 当队列为空时, 表示我们已经完成了层次序遍历</p><ul><li>我们继续看本题. 由于队尾标识 <code>nullptr</code> 会一直存在, 我们无法根据 <code>队列为空</code> 来进行遍历终结的判定. 那么什么时候已经遍历完了呢？ 非常简单，整个队列只有 <code>nullptr</code> 一个元素. </li></ul><p>具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Solution::findBottomLeftValue(TreeNode *root) &#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">auto</span> *ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">queue</span>.push(root);</span><br><span class="line">    <span class="built_in">queue</span>.push(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">bool</span> endFlag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">queue</span>.empty()) &#123;</span><br><span class="line">        <span class="comment">//visit</span></span><br><span class="line">        TreeNode *node = <span class="built_in">queue</span>.front();</span><br><span class="line">        <span class="built_in">queue</span>.pop();</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;<span class="comment">//第一个不是空</span></span><br><span class="line">            <span class="keyword">if</span> (endFlag &amp;&amp; !<span class="built_in">queue</span>.back()) &#123;</span><br><span class="line">                ans-&gt;val = node-&gt;val;</span><br><span class="line">                endFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//push back</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                <span class="built_in">queue</span>.push(node-&gt;left);</span><br><span class="line">                endFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                <span class="built_in">queue</span>.push(node-&gt;right);</span><br><span class="line">                endFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>.front() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">queue</span>.pop();</span><br><span class="line">            <span class="built_in">queue</span>.push(<span class="literal">nullptr</span>);</span><br><span class="line">            endFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      寻找二叉树中最深一层的最左侧节点
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Tree" scheme="https://caribouw.github.io/Caribou.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>如果可以选择更加友好的方式</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/15/review2019-09-15/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/15/review2019-09-15/</id>
    <published>2019-09-15T14:04:54.000Z</published>
    <updated>2019-09-15T14:08:56.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Review-for-20190915"><a href="#Review-for-20190915" class="headerlink" title="Review for 20190915"></a>Review for 20190915</h2>]]></content>
    
    <summary type="html">
    
      9月到了中旬，时已过中秋
    
    </summary>
    
      <category term="Review" scheme="https://caribouw.github.io/Caribou.github.io/categories/Review/"/>
    
    
  </entry>
  
  <entry>
    <title>LC周赛 2019-09-15</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/15/LC%E5%91%A8%E8%B5%9B-2019-09-15/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/15/LC周赛-2019-09-15/</id>
    <published>2019-09-15T08:41:44.000Z</published>
    <updated>2019-09-15T09:26:47.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-寻找字符串中Balloon个数"><a href="#1-寻找字符串中Balloon个数" class="headerlink" title="1. 寻找字符串中Balloon个数"></a>1. 寻找字符串中Balloon个数</h2><p>给你一个字符串 <code>text</code>，你需要使用 <code>text</code> 中的字母来拼凑尽可能多的单词 <strong>“balloon”（气球）</strong>。</p><p>字符串 <code>text</code> 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 <strong>“balloon”</strong>。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>很快可以通过哈希表来建立一个 <code>字符到字符在text中出现次数</code>的映射, 然后根据<code>ballon</code> 来进行对照得出最终结果: 一定是 { <code>b</code> 出现次数 , <code>a</code> 出现次数 , <code>n</code> 出现次数 , <code>l</code> 出现次数的一半 , <code>o</code> 出现次数的一半 } 中的最小值, 即满足</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNumberOfBalloons</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length(); ++i) &#123;</span><br><span class="line">            map.put(text.charAt(i), map.getOrDefault(text.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = map.getOrDefault(<span class="string">'b'</span>, <span class="number">0</span>),</span><br><span class="line">                a = map.getOrDefault(<span class="string">'a'</span>, <span class="number">0</span>),</span><br><span class="line">                l = map.getOrDefault(<span class="string">'l'</span>, <span class="number">0</span>) / <span class="number">2</span>,</span><br><span class="line">                o = map.getOrDefault(<span class="string">'o'</span>, <span class="number">0</span>) / <span class="number">2</span>,</span><br><span class="line">                n = map.getOrDefault(<span class="string">'n'</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(b, Math.min(a, Math.min(l, Math.min(o, n))));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-反转每对括号间的子串"><a href="#2-反转每对括号间的子串" class="headerlink" title="2. 反转每对括号间的子串"></a>2. 反转每对括号间的子串</h2><p>给出一个字符串 <code>s</code>（仅含有小写英文字母和括号）。</p><p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p><p>注意，您的结果中 <strong>不应</strong> 包含任何括号。</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>很明显这是一个 <strong>递归</strong> 问题. 举例说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(u(love)i)&quot;</span><br></pre></td></tr></table></figure><p>我们需要先找出 <strong>最小匹配括号子串</strong> , 将其翻转之后, 再对其父级的子串进行翻转. </p><p>但是有一个比较坑的点, 测试用例里面有这样的 <code>a()b(((c)))de</code> ， 也就是说，可以存在平级的括号. 这一点当时没想到. 从这里我们需要改变想法：</p><ul><li>当遇到同级的括号，先处理过当前的 <code>()</code> 对，然后继续使用 ReverseParentheses 来对后续同级括号进行翻转. 这个属于迭代式的处理</li><li>当遇到子级括号, 也就是正常的 <code>(d(c))</code>这样的情况，就使用递归函数解决</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>)</span><br><span class="line">            begin = i;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">            end = i;</span><br><span class="line">            String temp = s.substring(begin + <span class="number">1</span>, end);<span class="comment">//最小 ()</span></span><br><span class="line">            <span class="keyword">return</span> reverseParentheses(s.substring(<span class="number">0</span>, begin) + reverseString(temp) + s.substring(end + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] temp = s.toCharArray();</span><br><span class="line">    StringBuilder r = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = temp.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        r.append(temp[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-k次串联数组之后的最大子数组之和"><a href="#3-k次串联数组之后的最大子数组之和" class="headerlink" title="3. k次串联数组之后的最大子数组之和"></a>3. k次串联数组之后的最大子数组之和</h2><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code>。</p><p>首先，我们要对该数组进行修改，即把原数组 <code>arr</code> 重复 <code>k</code> 次。</p><blockquote><p>举个例子，如果 <code>arr = [1, 2]</code> 且 <code>k = 3</code>，那么修改后的数组就是 <code>[1, 2, 1, 2, 1, 2]</code>。</p></blockquote><p>然后，请你返回修改后的数组中的最大的子数组之和。</p><p>注意，子数组长度可以是 <code>0</code>，在这种情况下它的总和也是 <code>0</code>。</p><p>由于 <strong>结果可能会很大</strong>，所以需要 <strong>模（mod）</strong> <code>10^9 + 7</code> 后再返回。 </p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>一看，这个不就是最大子数组的翻版吗 hhh , 那么直接贪心上啊 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MOD = <span class="number">1000_000_007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumHelper</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalLen = arr.length * k;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalLen; ++i) &#123;</span><br><span class="line">            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = Math.max(sum, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，<strong>TLE</strong> 了. 也就是说，这个算法不容忍 <strong>O(N)</strong> 的时间复杂度. 我们需要找到数组在进行串联的时候的一个和数关系来进行快速获取答案.</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>前缀和判断，一共如下可能</p><ul><li><p>答案为 0</p></li><li><p>答案仅从当前不串联的数组中得到, 即 k = 1时的最大子数组和</p></li><li><p>答案从 k = 2 的串联结果得到，第一部分的后缀和的最大值加上第二部分的前缀和的最大值。</p></li><li><p>答案从整个串联 k &gt; 2 次后的结果得到，且一定是第一部分的后缀和的最大值，中间部分的总和，加上最后一部分的前缀和的最大值。</p></li></ul><p>第二种可能从<strong>当前前缀和</strong>减去<strong>当前前缀和的最小值</strong>得到。</p><p>前缀和的最大值直接可以维护出来，后缀和的最大值可以通过总和减去前缀和的最小值得到。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>需要维护数组的 <strong>总和</strong>, <strong>最大前缀和</strong> , <strong>最小前缀和</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MOD = <span class="number">1000_000_007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kConcatenationMaxSum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> sumHelper(arr);</span><br><span class="line">    <span class="keyword">long</span>[] sum = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">long</span>[] maxL = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">long</span>[] minL = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">        maxL[i] = Math.max(maxL[i - <span class="number">1</span>], sum[i]);</span><br><span class="line">        minL[i] = Math.min(minL[i - <span class="number">1</span>], sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.max(ans,</span><br><span class="line">            Math.max(</span><br><span class="line">                    sum[n] - minL[n] + maxL[n],</span><br><span class="line">                    sum[n] - minL[n] + maxL[n] + sum[n] * (k - <span class="number">2</span>)</span><br><span class="line">            )</span><br><span class="line">    ) % MOD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumHelper</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalLen = arr.length;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalLen; ++i) &#123;</span><br><span class="line">        sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(sum, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-查找集群内的「关键连接」"><a href="#4-查找集群内的「关键连接」" class="headerlink" title="4. 查找集群内的「关键连接」"></a>4. 查找集群内的「关键连接」</h2><p>力扣数据中心有 <code>n</code> 台服务器，分别按从 <code>0</code> 到 <code>n-1</code> 的方式进行了编号。</p><p>它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 <code>connections</code> 是无向的。</p><p>从形式上讲，<code>connections[i] = [a, b]</code> 表示服务器 <code>a</code> 和 <code>b</code> 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。</p><p>「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。</p><p>请你以任意顺序返回该集群内的所有 「关键连接」。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      20190915周赛记录
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="competition" scheme="https://caribouw.github.io/Caribou.github.io/tags/competition/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-406 Reconstruct Queue</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/14/leetcode-406-ReconstructQueue/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/14/leetcode-406-ReconstructQueue/</id>
    <published>2019-09-14T15:23:08.000Z</published>
    <updated>2019-09-15T08:40:59.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="406-队列重组问题"><a href="#406-队列重组问题" class="headerlink" title="406 队列重组问题"></a>406 队列重组问题</h2><p>题干：给予的队列中，每一个元素表示了这个人的身高、他之前不比他矮的人的个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">思路:</span><br><span class="line">* 比较菜，看了第一个hint.</span><br><span class="line">* 第一个hint里面提到, 我们可以先对 h 值最小的入手.</span><br><span class="line">* 我们得到最小的h 一个人 P0 之后,是可以直接定位他重排之后的位置的. 假设从0计数，那么最矮的人的位置和k的关系就是</span><br><span class="line">* P0 处在位置k.</span><br><span class="line">* 当然,如果存在多个身高最小的人,那么他们的k大小必然是连续的. 依次根据k值从小到大排列即可</span><br><span class="line">*</span><br><span class="line">* 一个人的位置定下之后,我们就可以继续找身高第二小的人. 注意这时候也可能会有身高一样的情况发生.</span><br><span class="line">* 假设身高第二小的人 P1 (h1,k1) . 他重排之后的位置为index. 重排之后在他前面的身高比他小的人数为pre .</span><br><span class="line">* 那么不难得出如下等式</span><br><span class="line">*      index = k1 + pre</span><br><span class="line">* 这样一来程序就不难写了</span><br></pre></td></tr></table></figure><p>如上是第一次写的想法. 其实是被hint带进去了。我想着从最矮的人入手，但是在当最矮的人入队列之后，第二个参数 <code>k</code> 的条件将会被打破. </p><ul><li>注意：这时我的初始排序策略为 : <code>优先判定身高进行升序排列，身高相同者第二个参数升序排列</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="最矮方案不行那就重新审视题目"><a href="#最矮方案不行那就重新审视题目" class="headerlink" title="最矮方案不行那就重新审视题目"></a>最矮方案不行那就重新审视题目</h4><p>hint里面提到了 ： 如果找到了最矮的人，那么可以马上确定他的位置. 这句话其实有另一层含义 ——如果一个人最后被插入队列，那么只有当其身高是最矮的时候，那么肯定可以确定他需要插入到 <code>k</code> 这个位置上. 那么我们转变排序策略, 进行 <code>优先判定身高进行降序排列, 身高相同者第二个参数升序排列</code>，以此来保证其排序完成后，可以根据该排序的先后顺序，依次进行插入.</p><h4 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Solution::reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;people) &#123;</span><br><span class="line">    sort(people.begin(),people.end(),[](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span><br><span class="line">    &#123; <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : people)</span><br><span class="line">        ans.insert(ans.begin()+v[<span class="number">1</span>], v);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Queue" scheme="https://caribouw.github.io/Caribou.github.io/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>Kubernets 进行集群部署</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/12/Kebernets%20%E8%BF%9B%E8%A1%8C%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/12/Kebernets 进行集群部署/</id>
    <published>2019-09-12T15:23:08.000Z</published>
    <updated>2019-09-15T08:40:59.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kubernets-进行集群部署"><a href="#Kubernets-进行集群部署" class="headerlink" title="Kubernets 进行集群部署"></a>Kubernets 进行集群部署</h2><h3 id="关键定义"><a href="#关键定义" class="headerlink" title="关键定义"></a>关键定义</h3><ul><li><h5 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h5></li></ul><p>运行在Node节点上的若干个容器集合，是一个在容器基础上的更高的抽象。主要由 <code>master</code> 节点进行调度，将生成实例化的 Pod 调度到某一个 Node 上进行绑定；</p><p>当某一个 Node 宕机，可以进行重新调度，将 Pod 调度到其他的 Node 节点上.</p><ul><li><h5 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h5></li></ul><p>我们一般不会手动自己创建Pod，这样很难管理。利用Replication Controller，可以定义Pod运行内容，副本的个数等信息，它的升级版本是 ReplicaSet。现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。</p><ul><li><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5></li></ul><p>可以把一组Pod组成服务 Service，Service有一个虚拟的ClusterIP，服务访问可以通过ClusterIP作为统一请求入口，因为一个 Service 对应一组Pod，所以可以做到负载均衡。服务可以通过 NodePort，LoadBalancer的方式暴露对外服务。注意 type = LoadBalancer需要云服务平台提供基础的服务，自建的K8S集群默认是没有这个东西的。如果在阿里云上定义服务 type = LoadBalancer 后，你会发现，在管理后台的负载均衡页面，会增加一个负载均衡器</p><p>从以上的定义中看出, 一个Node可以认为是一台主机, 而Service作为一个服务提供者, 下包含了多个冗余Node. 能够在某一个Node宕机时及时进行其他备用节点的替补. </p><p>我们需要把docker镜像push到远端的某一个镜像管理平台，而后通过配置文件的形式来定义Pod和Service的内容,实现分布式部署.</p><h3 id="K8s-YAML配置文件"><a href="#K8s-YAML配置文件" class="headerlink" title="K8s YAML配置文件"></a>K8s YAML配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># yaml格式的pod定义文件完整内容：</span><br><span class="line">apiVersion: v1       #必选，版本号，例如v1</span><br><span class="line">kind: Pod       #必选，Pod</span><br><span class="line">metadata:       #必选，元数据</span><br><span class="line">  name: string       #必选，Pod名称</span><br><span class="line">  namespace: string    #必选，Pod所属的命名空间</span><br><span class="line">  labels:      #自定义标签</span><br><span class="line">    - name: string     #自定义标签名字</span><br><span class="line">  annotations:       #自定义注释列表</span><br><span class="line">    - name: string</span><br><span class="line">spec:         #必选，Pod中容器的详细定义</span><br><span class="line">  containers:      #必选，Pod中容器列表</span><br><span class="line">  - name: string     #必选，容器名称</span><br><span class="line">    image: string    #必选，容器的镜像名称</span><br><span class="line">    imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像</span><br><span class="line">    command: [string]    #容器的启动命令列表，如不指定，使用打包时使用的启动命令</span><br><span class="line">    args: [string]     #容器的启动命令参数列表</span><br><span class="line">    workingDir: string     #容器的工作目录</span><br><span class="line">    volumeMounts:    #挂载到容器内部的存储卷配置</span><br><span class="line">    - name: string     #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span><br><span class="line">      mountPath: string    #存储卷在容器内mount的绝对路径，应少于512字符</span><br><span class="line">      readOnly: boolean    #是否为只读模式</span><br><span class="line">    ports:       #需要暴露的端口库号列表</span><br><span class="line">    - name: string     #端口号名称</span><br><span class="line">      containerPort: int   #容器需要监听的端口号</span><br><span class="line">      hostPort: int    #容器所在主机需要监听的端口号，默认与Container相同</span><br><span class="line">      protocol: string     #端口协议，支持TCP和UDP，默认TCP</span><br><span class="line">    env:       #容器运行前需设置的环境变量列表</span><br><span class="line">    - name: string     #环境变量名称</span><br><span class="line">      value: string    #环境变量的值</span><br><span class="line">    resources:       #资源限制和请求的设置</span><br><span class="line">      limits:      #资源限制的设置</span><br><span class="line">        cpu: string    #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span><br><span class="line">        memory: string     #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span><br><span class="line">      requests:      #资源请求的设置</span><br><span class="line">        cpu: string    #Cpu请求，容器启动的初始可用数量</span><br><span class="line">        memory: string     #内存清楚，容器启动的初始可用数量</span><br><span class="line">    livenessProbe:     #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span><br><span class="line">      exec:      #对Pod容器内检查方式设置为exec方式</span><br><span class="line">        command: [string]  #exec方式需要制定的命令或脚本</span><br><span class="line">      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span><br><span class="line">        path: string</span><br><span class="line">        port: number</span><br><span class="line">        host: string</span><br><span class="line">        scheme: string</span><br><span class="line">        HttpHeaders:</span><br><span class="line">        - name: string</span><br><span class="line">          value: string</span><br><span class="line">      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式</span><br><span class="line">         port: number</span><br><span class="line">       initialDelaySeconds: 0  #容器启动完成后首次探测的时间，单位为秒</span><br><span class="line">       timeoutSeconds: 0   #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span><br><span class="line">       periodSeconds: 0    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span><br><span class="line">       successThreshold: 0</span><br><span class="line">       failureThreshold: 0</span><br><span class="line">       securityContext:</span><br><span class="line">         privileged:false</span><br><span class="line">    restartPolicy: [Always | Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span><br><span class="line">    nodeSelector: obeject  #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span><br><span class="line">    imagePullSecrets:    #Pull镜像时使用的secret名称，以key：secretkey格式指定</span><br><span class="line">    - name: string</span><br><span class="line">    hostNetwork:false      #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span><br><span class="line">    volumes:       #在该pod上定义共享存储卷列表</span><br><span class="line">    - name: string     #共享存储卷名称 （volumes类型有很多种）</span><br><span class="line">      emptyDir: &#123;&#125;     #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span><br><span class="line">      hostPath: string     #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span><br><span class="line">        path: string     #Pod所在宿主机的目录，将被用于同期中mount的目录</span><br><span class="line">      secret:      #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span><br><span class="line">        scretname: string  </span><br><span class="line">        items:     </span><br><span class="line">        - key: string</span><br><span class="line">          path: string</span><br><span class="line">      configMap:     #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span><br><span class="line">        name: string</span><br><span class="line">        items:</span><br><span class="line">        - key: string</span><br></pre></td></tr></table></figure><h3 id="端口和IP"><a href="#端口和IP" class="headerlink" title="端口和IP"></a>端口和IP</h3><p>和docker的内网环境类似，k8s也具有集群内部网络和外部网络.</p><h4 id="1-nodePort"><a href="#1-nodePort" class="headerlink" title="1. nodePort"></a>1. nodePort</h4><p>外部流量访问k8s集群中service入口的一种方式（另一种方式是LoadBalancer），即nodeIP:nodePort是提供给外部流量访问k8s集群中service的入口。</p><p>比如外部用户要访问k8s集群中的一个Web应用，那么我们可以配置对应service的<strong>type=NodePort</strong>，nodePort=30001。其他用户就可以通过浏览器<a href="http://node:30001访问到该web服务。" target="_blank" rel="noopener">http://node:30001访问到该web服务。</a></p><p>而数据库等服务可能不需要被外界访问，只需被内部服务访问即可，那么我们就不必设置service的NodePort。</p><h4 id="2-port"><a href="#2-port" class="headerlink" title="2. port"></a>2. port</h4><p>k8s集群内部服务之间访问<strong>service</strong>的入口。即<strong>clusterIP:port</strong>是service暴露在clusterIP上的端口。</p><ul><li>mysql容器暴露了3306端口（参考DockerFile），集群内其他容器通过33306端口访问mysql服务，但是<strong>外部流量不能访问mysql服务</strong>，因为mysql服务没有配置NodePort。对应的service.yaml如下：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr"> name:</span> <span class="string">mysql-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr"> ports:</span></span><br><span class="line"><span class="attr"> - port:</span> <span class="number">33306</span></span><br><span class="line"><span class="attr">   targetPort:</span> <span class="number">3306</span></span><br><span class="line"><span class="attr"> selector:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mysql-pod</span></span><br></pre></td></tr></table></figure><h4 id="3-targetPort"><a href="#3-targetPort" class="headerlink" title="3. targetPort"></a>3. targetPort</h4><p>容器的端口（最终的流量端口）。targetPort是pod上的端口，从port和nodePort上来的流量，经过kube-proxy流入到后端pod的targetPort上，最后进入容器。</p><p>与<strong>制作容器时暴露的端口一致</strong>（使用DockerFile中的<strong>EXPOSE</strong>），例如官方的nginx（参考DockerFile）暴露80端口。 对应的service.yaml如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr"> name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr"> type:</span> <span class="string">NodePort</span>         <span class="string">//</span> <span class="string">有配置NodePort，外部流量可访问k8s中的服务</span></span><br><span class="line"><span class="attr"> ports:</span></span><br><span class="line"><span class="attr"> - port:</span> <span class="number">30080</span>          <span class="string">//</span> <span class="string">服务访问端口</span></span><br><span class="line"><span class="attr">   targetPort:</span> <span class="number">80</span>       <span class="string">//</span> <span class="string">容器端口</span></span><br><span class="line"><span class="attr">   nodePort:</span> <span class="number">30001</span>      <span class="string">//</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr"> selector:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-pod</span></span><br></pre></td></tr></table></figure><p>总的来说</p><ul><li>port和nodePort都是service的端口，前者暴露给k8s集群内部服务访问，后者暴露给k8s集群外部流量访问。</li><li>从上两个端口过来的数据都需要经过反向代理kube-proxy，流入后端pod的targetPort上，最后到达pod内的容器。</li></ul>]]></content>
    
    <summary type="html">
    
      一条从Spring Cloud向K8S的路,循循善诱.
    
    </summary>
    
      <category term="服务" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="K8S" scheme="https://caribouw.github.io/Caribou.github.io/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-101 Symmetrc Tree 对称树的判定</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/01/leetcode-101-Symmetrc-Tree/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/01/leetcode-101-Symmetrc-Tree/</id>
    <published>2019-09-01T15:23:08.000Z</published>
    <updated>2019-09-15T08:40:59.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leet-code-101-对称树判定"><a href="#Leet-code-101-对称树判定" class="headerlink" title="Leet code 101 对称树判定"></a>Leet code 101 对称树判定</h2><p>树的数据格式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要判定一棵树是否按照根节点镜像对称，属于比较简答的树的递归问题</p><p>一颗对称树可以如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><h4 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h4><p>首先想到的就是，可以顺着左右子树分别向下递归。相同深度时，比较的两棵子树的根节点相同，并且可以从 <code>左子树的左儿子</code> 和 <code>右子树的右儿子</code> 是否相同，并且 <code>左子树的右儿子</code> 和 <code>左子树的左儿子</code>是否相同入手。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//check if the tree is symmetric</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *left, TreeNode *right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!left &amp;&amp; !right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!left || !right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;val == right-&gt;val &amp;&amp;</span><br><span class="line">               isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp;</span><br><span class="line">               isSymmetric(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      判定一颗给定树是否对称
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Tree" scheme="https://caribouw.github.io/Caribou.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-148 Sort Linked List 基于链表排序</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/01/leetcode-148-sort-list/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/01/leetcode-148-sort-list/</id>
    <published>2019-09-01T15:23:08.000Z</published>
    <updated>2019-09-15T08:40:59.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="148-链表排序"><a href="#148-链表排序" class="headerlink" title="148 链表排序"></a>148 链表排序</h2><p>给定一个链表，将其进行排序。主要考察了基本的排序内容</p><p>给定数据结构 ListNode</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="基于链表的归并排序"><a href="#基于链表的归并排序" class="headerlink" title="基于链表的归并排序"></a>基于链表的归并排序</h4><p>链表本身无法直接获取索引的特点，归并排序首先需要得到中间节点，并且能够从中间节点开始分隔。</p><p>之后的排序方式和基于数组的归并排序类似，难度不大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序主函数</span></span><br><span class="line">  <span class="function">ListNode *<span class="title">mergeSortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">          <span class="keyword">return</span> head;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          ListNode *fast = head, *slow = head;</span><br><span class="line">          <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">              fast = fast-&gt;next-&gt;next;</span><br><span class="line">              slow = slow-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          ListNode *preHead = head;</span><br><span class="line">          ListNode *postHead = slow-&gt;next;</span><br><span class="line">          <span class="comment">//截断</span></span><br><span class="line">          slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">          preHead = mergeSortList(preHead);</span><br><span class="line">          postHead = mergeSortList(postHead);</span><br><span class="line">          <span class="keyword">return</span> merge(preHead, postHead);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//归并操作</span></span><br><span class="line">  <span class="function">ListNode *<span class="title">merge</span><span class="params">(ListNode *pre, ListNode *post)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>)</span><br><span class="line">          <span class="keyword">return</span> post;</span><br><span class="line">      <span class="keyword">if</span> (post == <span class="literal">nullptr</span>)</span><br><span class="line">          <span class="keyword">return</span> pre;</span><br><span class="line">      ListNode *result, *p;</span><br><span class="line">      <span class="comment">//let pre to be the head</span></span><br><span class="line">      <span class="keyword">if</span> (pre-&gt;val &lt; post-&gt;val) &#123;</span><br><span class="line">          result = pre;</span><br><span class="line">          pre = pre-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result = post;</span><br><span class="line">          post = post-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      p = result;</span><br><span class="line">      <span class="keyword">while</span> (pre != <span class="literal">nullptr</span> &amp;&amp; post != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(pre-&gt;val &lt; post-&gt;val)&#123;</span><br><span class="line">              p-&gt;next = pre;</span><br><span class="line">              pre=pre-&gt;next;</span><br><span class="line">          &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">              p-&gt;next = post;</span><br><span class="line">              post = post-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          p=p-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(pre == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">          p-&gt;next = post;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          p-&gt;next = pre;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      针对链表进行排序
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="List" scheme="https://caribouw.github.io/Caribou.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 向技术低头</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/01/hello-world/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/01/hello-world/</id>
    <published>2019-09-01T13:54:56.000Z</published>
    <updated>2019-09-15T08:40:59.548Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      hexo的基本使用方式,主要采取的是静态文件的部署.其实非常类似于 CI/CD 的方式
    
    </summary>
    
      <category term="笔记" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Welcome" scheme="https://caribouw.github.io/Caribou.github.io/tags/Welcome/"/>
    
  </entry>
  
</feed>
