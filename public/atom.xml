<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Caribou</title>
  
  
  <link href="/Caribou.github.io/atom.xml" rel="self"/>
  
  <link href="https://caribouw.github.io/Caribou.github.io/"/>
  <updated>2020-01-15T06:19:14.137Z</updated>
  <id>https://caribouw.github.io/Caribou.github.io/</id>
  
  <author>
    <name>Fangming Lu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++新特性</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2020/01/15/c-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2020/01/15/c-新特性/</id>
    <published>2020-01-15T02:14:27.000Z</published>
    <updated>2020-01-15T06:19:14.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What’s-new-in-C-11"><a href="#What’s-new-in-C-11" class="headerlink" title="What’s new in C++ 11?"></a>What’s new in C++ 11?</h2><h3 id="storage-duration-specifier"><a href="#storage-duration-specifier" class="headerlink" title="storage duration specifier"></a>storage duration specifier</h3><p>多个C++版本都对变量存储时间的定义有严格的说明</p><ul><li><p><code>auto</code> - <em>automatic</em> storage duration.</p></li><li><p><code>register</code> - <em>automatic</em> storage duration. Also hints to the compiler to place the object in the processor’s register. (deprecated) ——<em>since C++ 17</em></p></li><li><p><code>static</code> - <em>static</em> or <em>thread</em> storage duration and <em>internal</em> linkage</p></li><li><p><code>extern</code> - <em>static</em> or <em>thread</em> storage duration and <em>external</em> linkage.</p></li><li><p><code>thread_local</code> - <em>thread</em> storage duration</p><p>The <code>thread_local</code> keyword is only allowed for objects declared at namespace scope, objects declared at block scope, and static data members. It indicates that the object has <strong>thread storage duration</strong>. It can be combined with <code>static</code> or <code>extern</code> to specify internal or external linkage (except for static data members which always have external linkage), respectively, but that additional <code>static</code> doesn’t affect the storage duration.</p></li><li><p><code>mutable</code> - does not affect storage duration or linkage</p><p>注意：<code>mutable</code> 主要是标识 <strong>const对象</strong> 中某些可变的成员，实现了从二进制的物理 <strong>const</strong> 到逻辑 <strong>const</strong> (外观不变)</p></li></ul><h3 id="Variadic-templates"><a href="#Variadic-templates" class="headerlink" title="Variadic templates"></a>Variadic templates</h3><p>可变类模板，在 <code>c++ reference</code> 里面以 <em>parameter pack</em> 来代替</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... <span class="title">Types</span>&gt;//<span class="title">class</span> ... <span class="title">Types</span> 是一个 <span class="title">pack</span> 的声明</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">f</span>(<span class="title">Types</span>... <span class="title">args</span>) &#123;</span>&#125;<span class="comment">//Types... args 是</span></span><br></pre></td></tr></table></figure><h4 id="Pack-Expansion"><a href="#Pack-Expansion" class="headerlink" title="Pack Expansion"></a>Pack Expansion</h4><ul><li><code>&amp;args...</code> 代表的是参数扩展</li><li><code>&amp;args</code>代表的是 <em>pack pattern</em> 本身</li></ul><h3 id="Move-semantics"><a href="#Move-semantics" class="headerlink" title="Move semantics"></a>Move semantics</h3><blockquote><p><strong>凡是取地址（<code>&amp;</code>）操作可以成功的都是左值，其余都是右值</strong></p><ul><li>等号左边的不一定是左值——可以通过操作符重载来让左部变成 <strong>右值</strong></li></ul></blockquote><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>我们之前常见的都是 <strong>左值引用</strong>，指的是我们只能够将 <strong>左值</strong> 赋给一个引用。</p><ul><li><p><code>int&amp; a = 1</code> 就是非法的。而我们也可以 <code>int const&amp; i = 42;</code> 来进行一个 <em>tricky</em> 的躲避</p><p>在 <code>c++11</code>中允许了右值引用的出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int&amp;&amp; a = 3;</span><br></pre></td></tr></table></figure></li></ul><h4 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h4><p>我们在进行 <code>Test(const Test&amp; test)</code> 拷贝构造函数的执行过程中，会造成很多的拷贝浪费。当单独的一次拷贝构造函数 (特别是对指针数组这些资源)过程消耗特别大的时候，对于性能来说是很低的。</p><p>那么 <code>c++11</code>标准给出了 <strong>移动拷贝构造函数</strong> 和 <strong>移动赋值操作符重载</strong>。此外，还支持 <code>std::move()</code>来强制性让 <strong>左值转化为右值</strong></p><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>我们想要实现</p><blockquote><p>多级函数调用过程中</p><ul><li>如果变量是左值，那么它作为其他函数的参数的时候也应该是 <strong>左值</strong></li><li>如果变量是右值，那么它作为其他函数的参数的时候也应该是 <strong>右值</strong></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"in func"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"in relay"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    func(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    relay(Test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子就是一个 <strong>反例</strong>。我们在传入 <code>func(t)</code> 的时候，其实调用了 <strong>拷贝构造函数</strong> (因为编译器把 <strong>t</strong> 当做了一个 <strong>左值</strong>)</p><blockquote><p><code>std::forward&lt;T&gt;()</code> ，能够保留参数的左右值类型</p></blockquote><h3 id="Value-Category"><a href="#Value-Category" class="headerlink" title="Value Category"></a>Value Category</h3><p>不止左值右值那么简单</p><blockquote><p>Cpp reference:</p><p>Each C++ <a href="https://en.cppreference.com/w/cpp/language/expressions" target="_blank" rel="noopener">expression</a> (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a <em>type</em> and a <em>value category</em>. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: <em>prvalue</em>, <em>xvalue</em>, and <em>lvalue</em>.</p></blockquote>]]></content>
    
    <summary type="html">
    
      虽说是新特性，但是C++ 11 &amp; 14 已经推出了将近10年了.这次就好好整理一下
    
    </summary>
    
    
      <category term="整理" scheme="https://caribouw.github.io/Caribou.github.io/tags/%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>杂谈-沉思帖</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/12/22/%E6%9D%82%E8%B0%88-%E9%B8%A1%E8%A1%80%E5%B8%96/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/12/22/杂谈-鸡血帖/</id>
    <published>2019-12-22T15:35:20.000Z</published>
    <updated>2019-12-22T15:55:54.793Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多尝试新的方向，不浮躁地随波逐流；</p><p>有一个自己喜爱的方向是如此地难能可贵</p></blockquote><h2 id="杂谈-沉思帖"><a href="#杂谈-沉思帖" class="headerlink" title="杂谈-沉思帖"></a>杂谈-沉思帖</h2><p>2019 秋季这个课表算是无法无天了，虽然在春季就做了一些心理预设，但是当它到来的时候，特别是到了现在考试周将近，还是压得人喘不过气。</p><p>前一段时间一直在各处投递简历。在打消了出国打算、ML的打算之后，我从暑期就开始对自己的方向进行了思考，留给我试错的时间已经不多了，在后续的一年半时间中，我是需要针对一桩事业真正投入地进行付出，并且能够有一定的产出的。在我各处找着实习的时候，字节一面后十分钟的拒信给了我巨大的打击——</p><blockquote><p>基础不牢，地动山摇</p></blockquote><p>面试官丢给我的几乎每一个计网问题我都招架不来，可以说上个学期学的内容全数奉还给了老师。内心千万个声音在警戒着我：你的基础根本不牢固，做了种种项目又有什么用？</p><p>图森的面试官告诉我，如果这些基本的网络知识不过关，如何能够在出错的时候进行精准的错误排查？特别是在客户流量比较大的情况下，网络阻塞、丢包这些错误屡见不鲜，如何可以最大限度地减少经济损失？</p><blockquote><p>网络协议中每一层的网络攻击可以有哪些？</p></blockquote><p>这个问题我可能一辈子也不忘了，图森的二面官这么一个问题丢过来，我当时的反应就是：一个也没有。</p><p>后续的结果也显而易见，又是一封拒信。虽然 <code>coding</code> 过关，但是基础过于不扎实而不会要我。</p><p>所以，基础 基础 基础！！！</p><p>什么叫做基础呢？</p><p>其实这些问题，老师课上也没有系统性的说过。我丢失了大一的时候看书的习惯，大二只是对课堂内的东西进行机械接受。最讽刺的就是，当字节面试官问“你觉得计网是一门怎么样的课”的时候，我第一反应回答就是“一门背书的课”。我现在回顾过来，真想好好打当时的自己一个巴掌。不过事实的确如此，我在大二下就是背书来学计网的，当时的我根本没有心思听老师讲课，只想着多做一些项目美滋滋。</p><p>现在就到了要亡羊补牢的时候了，11月上旬的样子吧，我开始恶补我之前的 <code>JVM</code>, 计网，多线程，<code>linux</code> 内核相关的知识。加上后续几个面试的逼迫，我可以说拼了老命在学 (这么紧的课程还要面试，真的会折磨我自己)</p><p><code>12.21</code> ，<em>TX</em> 的面试官突然打来电话，约了一面。可以说这次是我把握比较好的一次面试了。说着，人的确就是一个犯贱的种，需要一些外力压迫来威胁自己去学习。还有一个很重要的点就是，我真的过于浮躁了，急于求成想去学 <em>ML</em> 但是发现真实资源如此贫乏(一整个院搞什么ML? 我们又不是人工智能学院！) 没有一个前辈带领的路走得真心艰苦，没有方向，没有可以去追随的人，于是放弃。现在是时候好好静下心去听听自己了。</p><blockquote><p>冬至已至。</p><p>希望新的一年，能够笃定，坚毅。</p></blockquote>]]></content>
    
    <summary type="html">
    
      总结2019经历
    
    </summary>
    
      <category term="杂谈" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="UpUp" scheme="https://caribouw.github.io/Caribou.github.io/tags/UpUp/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 阅读笔记(1)</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/12/14/TCP-IP-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/12/14/TCP-IP-阅读笔记-1/</id>
    <published>2019-12-14T14:24:04.000Z</published>
    <updated>2019-12-14T14:39:17.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP连接形式"><a href="#TCP连接形式" class="headerlink" title="TCP连接形式"></a>TCP连接形式</h3><p>TCP连接使用了一对套接字 (<code>socket</code>) 来进行唯一表示，也就是把 <code>IP</code> 头部的源和目的IP地址，携同TCP头部的源端口号和目的端口号，来进行一个标识。</p><h3 id="Seq-与-Ack"><a href="#Seq-与-Ack" class="headerlink" title="Seq 与 Ack"></a>Seq 与 Ack</h3><p>序列号与响应号是通信双方进行确认判定的依据。每一次报文中的响应号就是上一次报文的序列号  + 1 ，表示了接收方想要接收的下一个序列号。</p><p>我们所熟知的三次握手，其实本质上就是发送方和接收方的序列号交换：</p><blockquote><p>第一次报文发送：SYN表明是客户端期望进行序列号同步，并且发送自己的序列号</p><p>第二次报文发送：SYN表示是服务端期望进行序列号同步，返回之前客户端的序列号 + 1 , 表示此时客户端序列号已经同步。此时还需要发送服务端自己的序列号，等待客户端是否给予最后一次响应。</p><p>第三次报文发送：ACK确实就是服务端序列号 + 1 的话，那么表明服务端的序列号也已经同步。至此通过三次报文交换来实现全双工通信的两端序列号同步。</p></blockquote><p>对于四次挥手，其实也是序列号的交换问题。</p><p>书上的问题给出了进一步的思考：如果出现同时建立连接和同时断开连接，报文发送个数是多少？</p><ul><li>对于同时建立连接的情况，一开始同时就会有两次报文发送，这时候两个报文都是 SYN，期望同步自己的序列号。此时连接两端的两个 <code>socket</code> 其实都只需要得到自己想要的 <code>ACK</code> 就可以了。这时候就是四次报文交换</li><li>对于同时断开连接的情况，和上面完全一样，也是四次</li></ul><h3 id="TIME-WAIT问题"><a href="#TIME-WAIT问题" class="headerlink" title="TIME_WAIT问题"></a>TIME_WAIT问题</h3><p>四次挥手结束之后，连接断开的发起者还会继续等待 <code>2MSL</code> 的时间长度，这种做法能够避免最后一次 <strong>ACK</strong> 因为网络问题没有发送到，给 <strong>被动断开方</strong> 时间进行超时重传。</p><p>在发起者还在等待的时候，其实两端的端口还是在连接的状态。问题就来了——端口占用问题。</p><p>也就是说，如果我们这时候在服务端或者客户端，断开 <code>socket</code> 却又立即重启，这时候就会出现端口占用的情况，导致我们的连接被拒绝。</p>]]></content>
    
    <summary type="html">
    
      TCP协议基本内容
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://caribouw.github.io/Caribou.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/12/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/12/07/设计模式-单例/</id>
    <published>2019-12-07T08:47:11.000Z</published>
    <updated>2019-12-07T08:47:48.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>给出最原始的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个静态的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="comment">//私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//给出一个公共的静态方法返回一个单一实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就需要考虑==多线程环境==下的单例模式实现了</p><p><strong>懒汉模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>饿汉模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多线程下的懒汉模式会出现问题——在判定是 <em>null</em> 的时候，还没来得及进行创建实例，另一个进程就进入进行判定</p></blockquote><h4 id="解决办法1"><a href="#解决办法1" class="headerlink" title="解决办法1"></a>解决办法1</h4><p>方法上添加 <strong>synchronized</strong> 关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题：如果两个线程都要获取单例引用，只能等一个线程获取后，另一个线程才能获取。</p></blockquote><h4 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h4><p>双检查锁机制（Double Check Locking）,也叫”DCL“</p><blockquote><p>双锁的意思，是指 检测两次instance是否为空。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//使用volatile关键字保其可见性  </span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MySingleton</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;<span class="comment">//懒汉式   </span></span><br><span class="line">                  <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">                    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;<span class="comment">//二次检查  </span></span><br><span class="line">                        instance = <span class="keyword">new</span> MySingleton();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决办法3"><a href="#解决办法3" class="headerlink" title="解决办法3"></a>解决办法3</h4><p>当然，我们最好还是采取<strong>饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决办法4"><a href="#解决办法4" class="headerlink" title="解决办法4"></a>解决办法4</h4><p>采取 <strong>静态内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决办法5"><a href="#解决办法5" class="headerlink" title="解决办法5"></a>解决办法5</h4><p>枚举 Enum</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;p&gt;给出最原始的代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://caribouw.github.io/Caribou.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库-索引</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/12/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B4%E7%90%86-%E7%B4%A2%E5%BC%95/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/12/05/数据库整理-索引/</id>
    <published>2019-12-05T13:54:56.000Z</published>
    <updated>2019-12-05T07:41:32.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h4 id="页存储"><a href="#页存储" class="headerlink" title="页存储"></a>页存储</h4><img src="https://i.loli.net/2019/12/05/dQE6NVkHZJcWfye.png" style="zoom:50%;"><p>如上就是数据库在Disk Storage的一个存储方式。一个页包含若干 <em>Data Rows</em> , 通过 <em>Row directory</em> 来进行索引</p><blockquote><p>A row in a table can be uniquely specified with the page number (P) and slot number (S).</p></blockquote><h5 id="位图索引"><a href="#位图索引" class="headerlink" title="位图索引"></a>位图索引</h5><p><a href="https://www.cnblogs.com/LBSer/p/3322630.html" target="_blank" rel="noopener">https://www.cnblogs.com/LBSer/p/3322630.html</a></p><p>位图索引中只维护distinct值，也就是说重复的值是不维护在树中</p><p>对于每一个列建立一个</p><ul><li><p>位图索引适合只有几个固定值的列，如性别、婚姻状况、行政区等等，而身份证号这种类型不适合用位图索引。</p></li><li><p>此外，位图索引适合静态数据，而不适合索引频繁更新的列</p></li></ul><h5 id="散列索引"><a href="#散列索引" class="headerlink" title="散列索引"></a>散列索引</h5><p>散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。</p><p>散列索引根据对应键的散列码来找到最终的索引项的技术，其实和B树就差不多，也就是一种索引之上的二级辅助索引，我理解散列索引都是二级或更高级的稀疏索引，否则桶就太多了，效率也不会很高</p><h5 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><p>所谓聚簇索引，就是指<strong>主索引文件</strong>和<strong>数据文件</strong>为==同一份文件==，聚簇索引主要用在<strong>Innodb</strong>存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，如下图所示：</p><p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><h5 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h5><p>聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接<strong>指向对应数据块</strong>。</p><h5 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h5><p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要<strong>二次查找</strong>。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据叶，再通过数据叶中的Page Directory找到数据行</p><h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><p>表明此索引的==每一个索引值只对应唯一的数据记录==，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复</p><h5 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h5><p>在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问</p><hr><p>数据库引擎 ：myISAM , innodb</p><p>myisam索引：因为myisam的索引和数据是分开存储存储的，myisam通过<strong>key_buffer</strong>把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因  </p><p>innodb索引：innodb的数据和索引放在一起，当找到索引也就找到了数据</p><img src="https://img-blog.csdn.net/20161102111454921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:75%;"><p>1.对于<strong>非聚簇索引表</strong>来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。</p><p>2.对于<strong>聚簇索引表</strong>来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)</p><blockquote><h5 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h5><p>1.当你需要取出==一定范围内==的数据时，用聚簇索引也比用非聚簇索引好。</p><p>2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。</p><p>3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p><h5 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h5><p>1.<strong>插入速度严重依赖于插入顺序</strong>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</p><p>2.<strong>更新主键的代价很高，因为将会导致被更新的行移动</strong>。因此，对于InnoDB表，我们一般定义主键为不可更新。</p><p>3.<strong>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</strong></p><p>二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</p><p>4.<strong>采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多</strong>，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</p></blockquote>]]></content>
    
    <summary type="html">
    
      数据库索引相关内容
    
    </summary>
    
      <category term="笔记" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://caribouw.github.io/Caribou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_1043</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/11/08/leetcode-1043/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/11/08/leetcode-1043/</id>
    <published>2019-11-08T11:59:05.000Z</published>
    <updated>2019-11-08T12:05:05.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Given an integer array <code>A</code>, you partition the array into (contiguous) subarrays of length at most <code>K</code>. After partitioning, each subarray has their values changed to become the maximum value of that subarray.</p><p>Return the largest sum of the given array after partitioning.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,15,7,9,2,5,10], K = 3</span><br><span class="line">Output: 84</span><br><span class="line">Explanation: A becomes [15,15,15,9,10,10,10]</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>构造一个 <em>dp</em> 数组, 满足</p><ul><li><code>dp[i]</code> 表示max sum of A[0: i+1)</li></ul><p>那么我们在接下来的每一个 <code>dp[i]</code> 中, 需要不断向前查询.将 <code>i</code> 之前的数组内容分成两部分：</p><ol><li>已经dp纳入计算的部分 <em>pre</em></li><li>当前计算的 <em>cur</em></li></ol><p>那么我们逐步增加 <em>cur</em> 的长度 ( from 1 to min(k,i) ) , 找到这个 <em>cur</em> 子数组的最大值 , 乘以 <em>cur</em> 长度，那么就是 <em>cur</em> 子数组的最优解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = A.size();</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">          <span class="keyword">int</span> cur_max = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// j from 1 to min(K,i)</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(K, i); j++) &#123;</span><br><span class="line">              cur_max = max(cur_max, A[i - j]);</span><br><span class="line">              dp[i] = max(dp[i], dp[i - j] + cur_max * j); </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[n];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      给定一个整数数组A，您将该数组划分为(连续的)长度最多为k的子数组。在划分之后，每个子数组的值都更改为该子数组的最大值。分区后返回给定数组的最大和。
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Array" scheme="https://caribouw.github.io/Caribou.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_1238 Grey Code</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/10/28/leetcode-1238/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/10/28/leetcode-1238/</id>
    <published>2019-10-28T01:12:41.000Z</published>
    <updated>2019-10-28T01:28:15.779Z</updated>
    
    <content type="html"><![CDATA[<p>引用：<a href="https://cp-algorithms.com/algebra/gray-code.html" target="_blank" rel="noopener">https://cp-algorithms.com/algebra/gray-code.html</a></p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Given 2 integers <code>n</code> and <code>start</code>. Your task is return <strong>any</strong> permutation <code>p</code> of <code>(0,1,2.....,2^n -1)</code>such that :</p><ul><li><code>p[0] = start</code></li><li><code>p[i]</code> and <code>p[i+1]</code> differ by only one bit in their binary representation.</li><li><code>p[0]</code> and <code>p[2^n -1]</code> must also differ by only one bit in their binary representation.</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>说实话，一开始没思路. 之后根据discussion才了解到格雷码的概念</p><p>实现特别简单，直接套公式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; circularPermutation(<span class="keyword">int</span> n, <span class="keyword">int</span> start) &#123;</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; ++i)</span><br><span class="line">            res.add(start ^ i ^ i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h3><p>格雷码是一种准权码，具有一种反射特性和循环特性的单步自补码，它的循环、单步特性消除了随机取数时出现重大误差的可能，它的反射、自补特性使得求反非常方便。格雷码属于可靠性编码，是一种错误最小化的编码方式。</p><p>自然二进制码可以直接由数/模转换器转换成模拟信号，但是在某些情况下，例如从十进制的3转换到4的二进制时，每一位都要变。3的二进制位：<strong>011</strong>，而4的二进制位：<strong>100</strong>，所以这就会使数字电路产生很大的尖峰电流脉冲。而格雷码则没有这一缺点，它是一种数字排序系统，其中的所有相邻整数在它们的数字表示中只有一个数字不同。它在任意两个相邻的数之间转换时，只有一个数位发生变化。它大大地减少了由一个状态到下一个状态时逻辑的混淆。另外由于最大数与最小数之间也仅一个位不同，故通常又叫<strong>格雷反射码</strong>或<strong>循环码</strong>。</p><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　G(i) = B(i+1) XOR B(i); 0 &lt;= i &lt; N - 1</span><br><span class="line">　　G(i) = B(i);      i = N - 1</span><br></pre></td></tr></table></figure><p>也就是说, 格雷码根据当前位和前一位进行 <strong>异或</strong> 运算 , 最高位不变</p><p>那么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G = G ^ (G &gt;&gt; 1)</span><br></pre></td></tr></table></figure><p>只能说，这个没接触过的知识，让我在一开始做的时候根本找不到入手点… 还是太弱了</p>]]></content>
    
    <summary type="html">
    
      给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,,...,2^n-1) 的排列 p (满足格雷码序列)
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode_470</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/10/15/leetcode-470/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/10/15/leetcode-470/</id>
    <published>2019-10-15T01:18:45.000Z</published>
    <updated>2019-10-15T01:54:55.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Given a function <code>rand7</code> which generates a uniform random integer in the range 1 to 7, write a function <code>rand10</code> which generates a uniform random integer in the range 1 to 10.</p><p>Do NOT use system’s <code>Math.random()</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: [7]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: [8,4]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: [8,1,10]</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>非常非常有趣的一个题目！</p><p>已知有一个函数rand7() , 需要我们给出rand10()的算法实现</p><p>思路可以说百花齐放. 这里我给出几个</p><h4 id="两次rand7扩展范围"><a href="#两次rand7扩展范围" class="headerlink" title="两次rand7扩展范围"></a>两次rand7扩展范围</h4><p>一次 <code>rand7()</code> 的范围是 <code>[1,7]</code> , 那么 <code>(rand7() - 1) * 7 + rand7() - 1</code> 的范围就是 <code>[0,47]</code></p><p>这时我们舍弃大于等于40的部分 即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rand40 = <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">while</span> (rand40 &gt;= <span class="number">40</span>) &#123;</span><br><span class="line">            rand40 = (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rand40 % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="暴力版随机"><a href="#暴力版随机" class="headerlink" title="暴力版随机"></a>暴力版随机</h4><p>没有用到一次rand7()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + count++ % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用rand7()函数来实现rand10()
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode_1143_最长公共序列</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/10/12/leetcode-1143/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/10/12/leetcode-1143/</id>
    <published>2019-10-12T00:25:25.000Z</published>
    <updated>2019-10-12T00:43:53.526Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Given two strings text1 and text2, return the length of their longest common subsequence.</p><p>A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A common subsequence of two strings is a subsequence that is common to both strings.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">Output: 3  </span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no such common subsequence, so the result is 0.</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用DP来进行实现. 第一版的想法就是构造一个二维数组 <code>dp[m][n]</code> , 对于 <code>dp[i][j]</code> 表示 <code>text1.subStr(0,i)</code> 和 <code>text2.subStr(0,j)</code>的最长公共序列长度.</p><p>状态转移方程如下：</p><ul><li>如果当前 <code>text1[i]=text2[j]</code>,  <code>dp[i][j]=1+dp[i-1][j-1]</code></li><li>否则就是之前进行匹配的 <code>dp[i][j]=max(dp[i-1][j],dp[i][j-1])</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length();</span><br><span class="line">        <span class="keyword">int</span> n = text2.length();</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m ; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j  = <span class="number">0</span> ; j &lt;= n ; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i * j == <span class="number">0</span>) </span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j] , dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      给定两个字符串text1和text2，返回它们最长的公共子序列的长度。字符串的子序列是从原始字符串生成的新字符串，其中删除了一些字符（可以是一个字符），而不会更改其余字符的相对顺序。(例如，“ ace”是“ abcde”的子序列，而“ aec”则不是).
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode_214</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/10/10/leetcode-214/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/10/10/leetcode-214/</id>
    <published>2019-10-10T00:41:32.000Z</published>
    <updated>2019-10-11T15:24:56.834Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>对于给定的字符串s，可以通过在其前面添加字符将其转换为回文。查找并返回通过执行此转换可以找到的最短回文</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aacecaaa&quot;</span><br><span class="line">Output: &quot;aaacecaaa&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcd&quot;</span><br><span class="line">Output: &quot;dcbabcd&quot;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先想到的, 我们需要找到字符串的中轴字符. 从该字符往外进行查找, 其最坏情况就是以<strong>第一个字符</strong>来进行扩展. 最好情况就是从中间的字符进行扩展. 我们可以从最中间开始进行查找, 第一个找到的就是最短的字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">//从最好情况往最差情况找</span></span><br><span class="line">        <span class="comment">//起点是 .5</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                index = n / <span class="number">2</span>;</span><br><span class="line">                ans = findPalindrome(s, index - <span class="number">1</span>, index);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index = (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                ans = findPalindrome(s, index, index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ans.empty())<span class="keyword">return</span> ans;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findPalindrome(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findPalindrome</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> leftIndex, <span class="keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (rightIndex &gt;= n) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &gt;= <span class="number">0</span> &amp;&amp; rightIndex &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[leftIndex] != s[rightIndex]) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            --leftIndex;</span><br><span class="line">            ++rightIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans = s;</span><br><span class="line">        <span class="keyword">while</span> (rightIndex &lt; n) &#123;</span><br><span class="line">            ans = s[rightIndex++] + ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>BTW , 这个Solution 很不幸的TLE了hh</p><h3 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h3><h4 id="Brute-force"><a href="#Brute-force" class="headerlink" title="Brute force"></a>Brute force</h4><p>将原有的字符串 <code>s</code> 看做是两个部分：前半部分是一个 Palidorm <strong>A</strong> , 后半部分 <strong>B</strong> 不是. 那么当我们找到最长的 <strong>Palidorm</strong> 时, 只需要把第二个部分回转, 复制到首部就可以. (这样相当于 $B^rAB$ )</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rev</span><span class="params">(s)</span></span>;</span><br><span class="line">    reverse(rev.begin(), rev.end());</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.substr(<span class="number">0</span>, n - i) == rev.substr(i))</span><br><span class="line">            <span class="keyword">return</span> rev.substr(<span class="number">0</span>, i) + s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是很不幸 , 这个在最后一个用例也 TLE 翻车了</p><h4 id="Manacher’s-Algorithm-马拉车算法"><a href="#Manacher’s-Algorithm-马拉车算法" class="headerlink" title="Manacher’s Algorithm 马拉车算法"></a>Manacher’s Algorithm 马拉车算法</h4><p>我的算法中, 主要的想法就是从各个可能的中心点往两边进行展开，时间复杂度达到了 $O(N^2)$。 而Manacher’s Algorithm 将查询回文串的时间复杂度优化到了 $O(N)$</p><ol><li>在原有的字符串中，相邻两个字符之间都插入 $#$ ，两边插入标识开始和结尾的符号。最终该字符串长度一定是<strong>奇数</strong></li></ol><p><img src="https://pic4.zhimg.com/80/v2-8c613143224234c971d9b5353a3f05aa_hd.jpg" alt="img"></p><ol start="2"><li>最终需要构造出一个生成数组 $P$ , 它如下表示 : </li></ol><p>每一个位置都表示以当前位置为中心进行扩展的字符串长度 (包括 <strong>#</strong> )  那么在原字符串中，其</p><p>字符串的位置是 <code>(i - P[i])/2 , (i - P[i])/2 + P[i] - 1</code></p><p>回文串长度是 <code>P[i] - 1</code></p><p>在新的字符串中, <code>Right_index = P[i] + i</code> . 也就是说，我们可以根据 <strong>P[i]</strong>来获取最 <strong>右</strong> 字符的位置<br><img src="https://pic4.zhimg.com/80/v2-d570f7a9e732d577d556b0e6cff1d263_hd.jpg" alt="img"></p><ol start="3"><li>数组 $P$ 生成</li></ol><p>我们获取 $P[i]$ 的时候不再总是根据当前为中心进行两边扩展，而是根据 $P[j], for;0\le j &lt;i$ 来进行</p><p>假设我们需要求 <code>P[i]</code> , 此前求出的最大回文串的中心 index 为 <code>Po</code> , 它的最右侧 index 为 <code>P</code></p><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *t, <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(t) &amp;&amp; j &lt; <span class="built_in">strlen</span>(p)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || t[i] == p[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="built_in">strlen</span>(p))</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(p)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || p[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出如下 PMT 的示例</p><p><img src="https://pic1.zhimg.com/80/v2-40b4885aace7b31499da9b90b7c46ed3_hd.jpg" alt="img"></p><p>PMT的含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于字符串 s , index 为 i 时，PMT[i] 表示它的 [前缀集合] 交  [后缀集合] 之后的最长匹配长度</span><br><span class="line">其中前缀集合和后缀集合不包含数组本身</span><br></pre></td></tr></table></figure><p>为编程方便需要，我们给出 next 数组。它实质上是 PMT数组右移一位, 且<code>next[0] = -1</code></p><p>根据这个，我们可以给出算法逻辑</p><ul><li>如果当前指针匹配，那么原字符串 target 和匹配串 pattern 的指针分别自增即可</li><li>如果发生不匹配，那么 target 不变动 (懒惰式), 匹配串指针 <code>j = next[j]</code></li></ul><p>相比如马拉车算法，KMP算法的适用性还是更加广泛的</p><hr><p>我们回到这个问题上来，回顾一下我们的目标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add string before the input so the result string will be a palindrome</span><br><span class="line">在原有的字符串之前插入一些字符串，使得它最终是一个回文串</span><br></pre></td></tr></table></figure><p>在 <strong>Brute force</strong> 里面已经提到：我们先找出最长的、从0下标开始的最长回文串 P , 那么只要把 <strong>剩下的子串反转之后insert到开头</strong>就可以构造出结果. 这一点很好理解</p><p>那么我们的目标就变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">寻找从0下标开始的最长回文串</span><br></pre></td></tr></table></figure><p>那么我们怎么把这个问题和之前说到的 <strong>KMP</strong> 算法结合呢？同样的也是进行字符串匹配. 我们需要把字符串进行预先的反转，而后把回文的匹配转化为正向的字符串匹配. 具体算法流程如下：</p><ol><li><p>给定字符串 <strong>s</strong> , 我们反转它, 得到 <strong>s*</strong> . 生成字符串 <code>s#s*</code>. 这样一来，我们只需要生成 KMP 表即可 (因为 <strong>s</strong> 和 <strong>s*</strong>就是前缀和后缀)</p></li><li><p>假设新的字符串 <code>s#s*</code> 的长度是 m , 那么 next[m] 的值就是我们所需要查找的 <code>从0下标开始的最长回文串</code>的长度. 取得 s.substr(m) , 进行反转之后复制到首部即可</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] fetchNext(String s) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = -<span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">      ans[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (-<span class="number">1</span> == j || s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">              ++j;</span><br><span class="line">              ++i;</span><br><span class="line">              <span class="keyword">if</span> (i == s.length())</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              ans[i] = j;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              j = ans[j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      StringBuilder sb = <span class="keyword">new</span> StringBuilder(s).reverse();</span><br><span class="line">      String wholeStr = s + <span class="string">"#"</span> + sb.toString();</span><br><span class="line">      <span class="keyword">int</span>[] next = fetchNext(wholeStr);</span><br><span class="line">      <span class="keyword">int</span> index = next[wholeStr.length() - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(index + <span class="number">1</span>)).reverse().append(s).toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      对于给定的字符串s，可以通过在其前面添加字符将其转换为回文。查找并返回通过执行此转换可以找到的最短回文。
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="String" scheme="https://caribouw.github.io/Caribou.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_941</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/10/10/leetcode-941/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/10/10/leetcode-941/</id>
    <published>2019-10-10T00:41:32.000Z</published>
    <updated>2019-10-10T00:45:09.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Given an array <code>A</code> of integers, return <code>true</code> if and only if it is a <em>valid mountain array</em>.</p><p>Recall that A is a mountain array if and only if:</p><ul><li><p><code>A.length &gt;= 3</code></p></li><li><p>There exists some i with <code>0 &lt; i &lt; A.length - 1</code></p><p> such that:</p><ul><li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li><li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul></li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,5,5]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,3,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>数组长度不小于3</li><li>数组中不存在连续的相同的数</li><li>需要满足：<ul><li>存在最高点</li><li>最高点出现之前需要上升</li><li>最高点之后严格递减</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mount = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">bool</span> reachTop = <span class="literal">false</span> , asc = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;A.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mount == A[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!reachTop)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mount &lt; A[i]) &#123;</span><br><span class="line">                    asc = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (mount &gt; A[i])&#123;</span><br><span class="line">                    reachTop = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mount = A[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(mount &lt;= A[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    mount = A[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> asc &amp;&amp; reachTop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      给定一个整数数组，当且仅当它是一个有效的山地数组时返回true。
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Array" scheme="https://caribouw.github.io/Caribou.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LC周赛 2019-10-05</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/10/08/leetcode-%E5%91%A8%E8%B5%9B20191005/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/10/08/leetcode-周赛20191005/</id>
    <published>2019-10-08T01:57:04.000Z</published>
    <updated>2019-10-08T02:13:59.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Play-with-Chips"><a href="#1-Play-with-Chips" class="headerlink" title="1. Play with Chips"></a>1. Play with Chips</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>There are some chips, and the i-th chip is at position <code>chips[i]</code>.</p><p>You can perform any of the two following types of moves <strong>any number of times</strong> (possibly zero) <strong>on any chip</strong>:</p><ul><li>Move the <code>i</code>-th chip by 2 units to the left or to the right with a cost of <strong>0</strong>.</li><li>Move the <code>i</code>-th chip by 1 unit to the left or to the right with a cost of <strong>1</strong>.</li></ul><p>There can be two or more chips at the same position initially.</p><p>Return the minimum cost needed to move all the chips to the same position (any position).</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果两个chip的位置相差为偶数, 则 <code>cost = 0</code>. 否则 <code>coust = 1</code></p><p>我们预先获取chip的一个哈希来进行缓存, 之后遍历哈希中的每一个数, 作为 <strong>目的地</strong>.</p><p>那么我们的问题就变成 ： 找出那一个 <strong>目的地</strong> , 使得 <code>cost</code> 最小即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostToMoveChips</span><span class="params">(<span class="keyword">int</span>[] chips)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : chips) &#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : set) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> chip : chips) &#123;</span><br><span class="line">            <span class="keyword">int</span> dis = Math.abs(num - chip);</span><br><span class="line">            sum += dis % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; min) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        min = Math.min(sum, min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Longest-Arithmetic-Subsequence-of-Given-Difference"><a href="#2-Longest-Arithmetic-Subsequence-of-Given-Difference" class="headerlink" title="2. Longest Arithmetic Subsequence of Given Difference"></a>2. Longest Arithmetic Subsequence of Given Difference</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>Given an integer array <code>arr</code> and an integer <code>difference</code>, return the length of the longest subsequence in <code>arr</code> which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals <code>difference</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,2,3,4], difference = 1</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest arithmetic subsequence is [1,2,3,4].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,3,5,7], difference = 1</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The longest arithmetic subsequence is any single element.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest arithmetic subsequence is [7,5,3,1].</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>一开始很明显想到用 <code>DP</code> 来解决. 每一步前进的同时需要缓存下当前位置, 便于后续的查找</p><p>我们缓存如下的内容：</p><ul><li>每一个数字和它所处可能位置 <code>Set</code> 的哈希映射</li><li>DP 数组，用于当前 <code>dp[i]</code> 的确定</li></ul><p>一开始就这样做了，但是 error 了一次. 原因就是这里的 dp 数组并不是单调上升，因为可能会出现中间断层的情况，例如 <code>[1,2,3,1,2,3,4]</code> , 中间的 <code>1</code> 位置就是断层的出现点. (之后一想，其实也可以通过自己的维护来进行避免，问题不大)</p><p>最终代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = arr.length;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       Map&lt;Integer, Set&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       set.add(<span class="number">0</span>);</span><br><span class="line">       map.put(arr[<span class="number">0</span>], set);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!map.containsKey(arr[i])) &#123;</span><br><span class="line">               set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">               set.add(i);</span><br><span class="line">               map.put(arr[i], set);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               set = map.get(arr[i]);</span><br><span class="line">               set.add(i);</span><br><span class="line">               map.put(arr[i], set);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> target = arr[i] - difference;</span><br><span class="line">           <span class="keyword">if</span> (!map.containsKey(target)) &#123; <span class="comment">//不包含前一个数</span></span><br><span class="line">               dp[i] = <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               set = map.get(target);</span><br><span class="line">               <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> num : set) &#123;</span><br><span class="line">                   maxLen = Math.max(maxLen, dp[num]);</span><br><span class="line">               &#125;</span><br><span class="line">               dp[i] = maxLen + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num : dp) &#123;</span><br><span class="line">           ans = Math.max(num, ans);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3-Path-with-Maximum-Gold"><a href="#3-Path-with-Maximum-Gold" class="headerlink" title="3. Path with Maximum Gold"></a>3. Path with Maximum Gold</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>In a gold mine <code>grid</code> of size <code>m * n</code>, each cell in this mine has an integer representing the amount of gold in that cell, <code>0</code> if it is empty.</p><p>Return the maximum amount of gold you can collect under the conditions:</p><ul><li>Every time you are located in a cell you will collect all the gold in that cell.</li><li>From your position you can walk one step to the left, right, up or down.</li><li>You can’t visit the same cell more than once.</li><li>Never visit a cell with <code>0</code> gold.</li><li>You can start and stop collecting gold from <strong>any</strong> position in the grid that has some gold. </li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[0,6,0],[5,8,7],[0,9,0]]</span><br><span class="line">Output: 24</span><br><span class="line">Explanation:</span><br><span class="line">[[0,6,0],</span><br><span class="line"> [5,8,7],</span><br><span class="line"> [0,9,0]]</span><br><span class="line">Path to get the maximum gold, 9 -&gt; 8 -&gt; 7.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]</span><br><span class="line">Output: 28</span><br><span class="line">Explanation:</span><br><span class="line">[[1,0,7],</span><br><span class="line"> [2,0,6],</span><br><span class="line"> [3,4,5],</span><br><span class="line"> [0,3,0],</span><br><span class="line"> [9,0,20]]</span><br><span class="line">Path to get the maximum gold, 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7.</span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>很简单的 DFS 算法实现, 没什么好说的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximumGold</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    max = Math.max(max, dfs(grid, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span>[] startPos, <span class="keyword">int</span> gold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> r = startPos[<span class="number">0</span>], c = startPos[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= m || c &gt;= n || grid[r][c] == <span class="number">0</span>) <span class="keyword">return</span> gold;</span><br><span class="line">        gold += grid[r][c];</span><br><span class="line">        <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                nums[i][j] = grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[r][c] = <span class="number">0</span>;             <span class="comment">//Get the gold</span></span><br><span class="line">        <span class="keyword">int</span> a1 = dfs(nums, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c + <span class="number">1</span>&#125;, gold);</span><br><span class="line">        <span class="keyword">int</span> b1 = dfs(nums, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c - <span class="number">1</span>&#125;, gold);</span><br><span class="line">        <span class="keyword">int</span> c1 = dfs(nums, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r + <span class="number">1</span>, c&#125;, gold);</span><br><span class="line">        <span class="keyword">int</span> d1 = dfs(nums, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r - <span class="number">1</span>, c&#125;, gold);</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a1, b1, c1, d1&#125;).max().getAsInt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-Count-Vowels-Permutation"><a href="#4-Count-Vowels-Permutation" class="headerlink" title="4. Count Vowels Permutation"></a>4. Count Vowels Permutation</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>Given an integer <code>n</code>, your task is to count how many strings of length <code>n</code> can be formed under the following rules:</p><ul><li>Each character is a lower case vowel (<code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;u&#39;</code>)</li><li>Each vowel <code>&#39;a&#39;</code> may only be followed by an <code>&#39;e&#39;</code>.</li><li>Each vowel <code>&#39;e&#39;</code> may only be followed by an <code>&#39;a&#39;</code> or an <code>&#39;i&#39;</code>.</li><li>Each vowel <code>&#39;i&#39;</code> <strong>may not</strong> be followed by another <code>&#39;i&#39;</code>.</li><li>Each vowel <code>&#39;o&#39;</code> may only be followed by an <code>&#39;i&#39;</code> or a <code>&#39;u&#39;</code>.</li><li>Each vowel <code>&#39;u&#39;</code> may only be followed by an <code>&#39;a&#39;.</code></li></ul><p>Since the answer may be too large, return it modulo <code>10^9 + 7.</code></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: All possible strings are: &quot;a&quot;, &quot;e&quot;, &quot;i&quot; , &quot;o&quot; and &quot;u&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: All possible strings are: &quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; and &quot;ua&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 5</span><br><span class="line">Output: 68</span><br></pre></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>假定某一步的最末位中, ‘a’ , ‘e’ , ‘i’ , ‘o’ , ‘u’ 的个数分别是 a , e , i , o , u ，那么下一步末位的个数就分别是 <code>u+e+i</code>, <code>a + i</code>, <code>e + o</code> , <code>i</code> , <code>o +i</code> </p><p>我这里用了一个hash来保存 (小声：这个hard题是简单题的赶脚233)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mod = <span class="number">1_000_000_007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelPermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'a'</span>, <span class="number">1L</span>);</span><br><span class="line">        map.put(<span class="string">'e'</span>, <span class="number">1L</span>);</span><br><span class="line">        map.put(<span class="string">'i'</span>, <span class="number">1L</span>);</span><br><span class="line">        map.put(<span class="string">'o'</span>, <span class="number">1L</span>);</span><br><span class="line">        map.put(<span class="string">'u'</span>, <span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            Map&lt;Character, Long&gt; tmp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            tmp.put(<span class="string">'a'</span>, (map.get(<span class="string">'u'</span>) + map.get(<span class="string">'e'</span>) + map.get(<span class="string">'i'</span>)) % mod);</span><br><span class="line">            tmp.put(<span class="string">'e'</span>, (map.get(<span class="string">'a'</span>) + map.get(<span class="string">'i'</span>)) % mod);</span><br><span class="line">            tmp.put(<span class="string">'i'</span>, (map.get(<span class="string">'e'</span>) + map.get(<span class="string">'o'</span>)) % mod);</span><br><span class="line">            tmp.put(<span class="string">'o'</span>, (map.get(<span class="string">'i'</span>)) % mod);</span><br><span class="line">            tmp.put(<span class="string">'u'</span>, (map.get(<span class="string">'o'</span>) + map.get(<span class="string">'i'</span>)) % mod);</span><br><span class="line"></span><br><span class="line">            map = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (map.values().stream().reduce(Long::sum).get() % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次周赛4个题目全部 AC , RANK  740</p>]]></content>
    
    <summary type="html">
    
      20191005周赛记录
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="competition" scheme="https://caribouw.github.io/Caribou.github.io/tags/competition/"/>
    
  </entry>
  
  <entry>
    <title>LC周赛 2019-09-29</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/29/leetcode-20190929%E5%91%A8%E8%B5%9B/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/29/leetcode-20190929周赛/</id>
    <published>2019-09-28T23:50:40.000Z</published>
    <updated>2019-09-30T01:25:27.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Unique-Number-of-Occurrences"><a href="#1-Unique-Number-of-Occurrences" class="headerlink" title="1. Unique Number of Occurrences"></a>1. Unique Number of Occurrences</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Given an array of integers <code>arr</code>, write a function that returns <code>true</code> if and only if the number of occurrences of each value in the array is unique.</p><p>给出一个<code>int</code>数组中的各个数的 <strong>出现次数</strong> 是否唯一</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>可以直接利用 <strong>map</strong> 来存储各个数的出现次数, 而后进行 value-set 的值的比较即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : map.keySet()) &#123;</span><br><span class="line">            set.add(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().size() == set.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-Get-Equal-Substrings-Within-Budget"><a href="#2-Get-Equal-Substrings-Within-Budget" class="headerlink" title="2. Get Equal Substrings Within Budget"></a>2. Get Equal Substrings Within Budget</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>You are given two strings <code>s</code> and <code>t</code> of the same length. You want to change <code>s</code> to <code>t</code>. Changing the <code>i</code>-th character of <code>s</code> to <code>i</code>-th character of <code>t</code> costs <code>|s[i] - t[i]|</code> that is, the absolute difference between the ASCII values of the characters.</p><p>You are also given an integer <code>maxCost</code>.</p><p>Return the maximum length of a substring of <code>s</code> that can be changed to be the same as the corresponding substring of <code>t</code>with a cost less than or equal to <code>maxCost</code>.</p><p>If there is no substring from <code>s</code> that can be changed to its corresponding substring from <code>t</code>, return <code>0</code></p><p>给出两个长度<strong>相等</strong>的字符串,和一个 <code>cost</code>, 我们需要给出最长的子串长度, 来让其<code>|s[i] - t[i]|</code>之和不大于cost</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>首先可以把两个字符串相减——逐字符进行减计算，得到绝对值, 由此获取一个 <code>int</code> 数组</p><p>而后的问题变为：给定一个 <code>int</code> 数组和一个 <code>cost</code> , 求出最大子数组，来满足不大于 <code>cost</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(String s, String t, <span class="keyword">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] costs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            costs[i] = Math.abs(s.charAt(i) - t.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                sum += costs[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; maxCost) &#123;</span><br><span class="line">                    ans = Math.max(ans, j - i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-Remove-All-Adjacent-Duplicates-in-String-II"><a href="#3-Remove-All-Adjacent-Duplicates-in-String-II" class="headerlink" title="3.Remove All Adjacent Duplicates in String II"></a>3.Remove All Adjacent Duplicates in String II</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>Given a string <code>s</code>, a <em>k</em> <em>duplicate removal</em> consists of choosing <code>k</code> adjacent and equal letters from <code>s</code> and removing them causing the left and the right side of the deleted substring to concatenate together.</p><p>We repeatedly make <code>k</code> duplicate removals on <code>s</code> until we no longer can.</p><p>Return the final string after all such duplicate removals have been made.</p><p>It is guaranteed that the answer is unique.</p><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code> , 每次我们可以一次性删除 <code>s</code> 中的 <code>k</code> 个连续的并且所有字符相同的子串, 求出最后的结果</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>每一次根据 s , k 来从左往右查找满足该条件的子串, 返回一个长度为 <strong>2</strong> 的 <code>int</code> 数组, 作为满足该条件的 <strong>第一个</strong> 子串的指针, 逐个进行删除即可. </p><p>之后也可以进行进一步优化 ： 每一次查找的时候查询所有满足该条件的子串，一次性删除 , 再进行下一轮的查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] indexes = findDuplicates(s, k);</span><br><span class="line">      String ans = s;</span><br><span class="line">      <span class="keyword">while</span> (indexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">          ans = ans.substring(<span class="number">0</span>, indexes[<span class="number">0</span>]) + ans.substring(indexes[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">          indexes = findDuplicates(ans, k);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] findDuplicates(String s, <span class="keyword">int</span> k) &#123;</span><br><span class="line">      <span class="keyword">int</span> n = s.length();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">          <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">              <span class="keyword">if</span> (s.charAt(j) != ch)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (j - i + <span class="number">1</span> == k) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="4-Minimum-Moves-to-Reach-Target-with-Rotations"><a href="#4-Minimum-Moves-to-Reach-Target-with-Rotations" class="headerlink" title="4. Minimum Moves to Reach Target with Rotations"></a>4. Minimum Moves to Reach Target with Rotations</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>In an <code>n*n</code> grid, there is a snake that spans 2 cells and starts moving from the top left corner at <code>(0, 0)</code> and <code>(0, 1)</code>. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at <code>(n-1, n-2)</code> and <code>(n-1, n-1)</code>.</p><p>In one move the snake can:</p><ul><li>Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.</li><li>Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.</li><li>Rotate clockwise if it’s in a horizontal position and the two cells under it are both empty. In that case the snake moves from <code>(r, c)</code> and <code>(r, c+1)</code> to <code>(r, c)</code> and <code>(r+1, c)</code>.<br><img src="https://assets.leetcode.com/uploads/2019/09/24/image-2.png" alt="img"></li><li>Rotate counterclockwise if it’s in a vertical position and the two cells to its right are both empty. In that case the snake moves from <code>(r, c)</code> and <code>(r+1, c)</code> to <code>(r, c)</code> and <code>(r, c+1)</code>.<br><img src="https://assets.leetcode.com/uploads/2019/09/24/image-1.png" alt="img"></li></ul><p>Return the minimum number of moves to reach the target.</p><p>If there is no way to reach the target, return <code>-1</code>.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很典型的DFS题目，下一步的行走都将影响后续的结果. 蛇很有可能进入 <strong>死胡同</strong> , 也就是我们无法进行下一步的查找.</p><p>我这里单独实现了蛇的位置 (水平 / 垂直) 判定 , 蛇进行 <strong>左移、右移、顺时针旋转、逆时针旋转</strong> 的逻辑. 而后穷举所有可能的情况</p><p>//TODO: 这个代码还没AC ， 只过了 17 / 42 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] originPos = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = dfs(grid, <span class="number">0</span>, originPos);</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> number, <span class="keyword">int</span>[][] pos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//visited</span></span><br><span class="line">        grid[pos[<span class="number">0</span>][<span class="number">0</span>]][pos[<span class="number">0</span>][<span class="number">1</span>]] = grid[pos[<span class="number">1</span>][<span class="number">0</span>]][pos[<span class="number">1</span>][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (isDestination(pos, grid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = pos[<span class="number">0</span>][<span class="number">0</span>], b = pos[<span class="number">0</span>][<span class="number">1</span>], c = pos[<span class="number">1</span>][<span class="number">0</span>], d = pos[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (isHorizen(pos)) &#123;</span><br><span class="line">            <span class="comment">// ---&gt;</span></span><br><span class="line">            <span class="keyword">boolean</span> isInfi = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> A = Integer.MAX_VALUE, B = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (d + <span class="number">1</span> &lt; n &amp;&amp; grid[a][d + <span class="number">1</span>] == <span class="number">0</span>) &#123;     <span class="comment">//You could move right</span></span><br><span class="line">                isInfi = <span class="keyword">false</span>;</span><br><span class="line">                A = dfs(grid, number + <span class="number">1</span>, moveRight(pos));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a + <span class="number">1</span> &lt; m &amp;&amp; grid[a + <span class="number">1</span>][b] == <span class="number">0</span> &amp;&amp; grid[a + <span class="number">1</span>][b + <span class="number">1</span>] == <span class="number">0</span>) &#123;   <span class="comment">//You could rotate clock or down</span></span><br><span class="line">                isInfi = <span class="keyword">false</span>;</span><br><span class="line">                B = Math.min(dfs(grid, number + <span class="number">1</span>, clockRotate(pos)), dfs(grid, number + <span class="number">1</span>, moveDown(pos)));</span><br><span class="line">            &#125;                                <span class="comment">//死胡同</span></span><br><span class="line">            <span class="keyword">if</span> (isInfi)</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Math.min(A, B);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isVertical(pos)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isInfi = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> A = Integer.MAX_VALUE, B = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; m &amp;&amp; grid[c + <span class="number">1</span>][b] == <span class="number">0</span>) &#123;             <span class="comment">//You could move downWard</span></span><br><span class="line">                isInfi = <span class="keyword">false</span>;</span><br><span class="line">                A = dfs(grid, number + <span class="number">1</span>, moveDown(pos));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b + <span class="number">1</span> &lt; n &amp;&amp; grid[a][b + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; grid[c][b + <span class="number">1</span>] == <span class="number">0</span>) &#123;   <span class="comment">//You could rotate counter or right</span></span><br><span class="line">                isInfi = <span class="keyword">false</span>;</span><br><span class="line">                B = Math.min(dfs(grid, number + <span class="number">1</span>, counterClockRotate(pos)), dfs(grid, number + <span class="number">1</span>, moveRight(pos)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isInfi)</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Math.min(A, B);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//死胡同</span></span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDestination</span><span class="params">(<span class="keyword">int</span>[][] pos, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">return</span> pos[<span class="number">0</span>][<span class="number">0</span>] == m - <span class="number">1</span> &amp;&amp; pos[<span class="number">0</span>][<span class="number">1</span>] == n - <span class="number">2</span> &amp;&amp;</span><br><span class="line">                pos[<span class="number">1</span>][<span class="number">0</span>] == m - <span class="number">1</span> &amp;&amp; pos[<span class="number">1</span>][<span class="number">1</span>] == n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isHorizen</span><span class="params">(<span class="keyword">int</span>[][] pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pos[<span class="number">0</span>][<span class="number">0</span>] == pos[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isVertical</span><span class="params">(<span class="keyword">int</span>[][] pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pos[<span class="number">0</span>][<span class="number">1</span>] == pos[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] moveRight(<span class="keyword">int</span>[][] pos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;pos[<span class="number">0</span>][<span class="number">0</span>], pos[<span class="number">0</span>][<span class="number">1</span>] + <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;pos[<span class="number">1</span>][<span class="number">0</span>], pos[<span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] moveDown(<span class="keyword">int</span>[][] pos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;pos[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1</span>, pos[<span class="number">0</span>][<span class="number">1</span>]&#125;,</span><br><span class="line">                &#123;pos[<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>, pos[<span class="number">1</span>][<span class="number">1</span>]&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要是水平的朝向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] clockRotate(<span class="keyword">int</span>[][] pos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;pos[<span class="number">0</span>][<span class="number">0</span>], pos[<span class="number">0</span>][<span class="number">1</span>]&#125;,</span><br><span class="line">                &#123;<span class="number">1</span> + pos[<span class="number">1</span>][<span class="number">0</span>], pos[<span class="number">0</span>][<span class="number">1</span>]&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] counterClockRotate(<span class="keyword">int</span>[][] pos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;pos[<span class="number">0</span>][<span class="number">0</span>], pos[<span class="number">0</span>][<span class="number">1</span>]&#125;,</span><br><span class="line">                &#123;pos[<span class="number">0</span>][<span class="number">0</span>], <span class="number">1</span> + pos[<span class="number">0</span>][<span class="number">1</span>]&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我借鉴了讨论区大家的想法，在这里做一个分享</p><p>遇到 <code>shortest path</code> , 大家的反应是使用 <strong>BFS</strong> . </p><p><strong>BFS</strong>的最简单形式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在某一个点上, 遍历所有的邻接点 , 将邻接点全部push到队列中 ;</span><br><span class="line">下一轮迭代中对出队列的节点做同样的操作</span><br></pre></td></tr></table></figure><p>这里贴出我觉得写得比较清楚的答案。反思一下, 我并没有进行对象化, 其实抽象成对象可以让实现变得方便很多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length, res = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Snake&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] seen = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="comment">// Tail has been pos (i,j), the horizontal/vertical direcitional traversed has been represented as 1 &amp; 2 respectively</span></span><br><span class="line">        seen[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        q.offer(<span class="keyword">new</span> Snake(<span class="string">'H'</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            System.out.println(size);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Snake s = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (s.dir == <span class="string">'H'</span> &amp;&amp; s.r == n -<span class="number">1</span> &amp;&amp; s.c == n -<span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">                Snake down = move(grid, seen, <span class="keyword">new</span> Snake(s.dir, s.r + <span class="number">1</span>, s.c), <span class="string">'D'</span>);</span><br><span class="line">                Snake right = move(grid, seen, <span class="keyword">new</span> Snake(s.dir, s.r, s.c + <span class="number">1</span>), <span class="string">'R'</span>);</span><br><span class="line">                <span class="keyword">char</span> dir = (s.dir == <span class="string">'H'</span> ? <span class="string">'V'</span> : <span class="string">'H'</span>);</span><br><span class="line">                Snake clock = move(grid, seen, <span class="keyword">new</span> Snake(dir,s.r,s.c), <span class="string">'C'</span>);</span><br><span class="line">                <span class="keyword">if</span> (right != <span class="keyword">null</span>) q.offer(right);</span><br><span class="line">                <span class="keyword">if</span> (down != <span class="keyword">null</span>) q.offer(down);</span><br><span class="line">                <span class="keyword">if</span> (clock != <span class="keyword">null</span>) q.offer(clock);</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Snake <span class="title">move</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span>[][] seen, Snake s, <span class="keyword">char</span> action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r0 = s.r, c0 = s.c, n = grid.length, r1 = r0, c1 = c0;</span><br><span class="line">        <span class="keyword">char</span> dir= s.dir;</span><br><span class="line">        <span class="keyword">if</span> (r0 &gt;= n || c0 &gt;= n || grid[r0][c0] == <span class="number">1</span> || seen[r0][c0] == <span class="number">3</span> || (seen[r0][c0] == <span class="number">1</span> &amp;&amp; dir == <span class="string">'H'</span>) || (seen[r0][c0] == <span class="number">2</span> &amp;&amp; dir == <span class="string">'V'</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (dir == <span class="string">'H'</span>) &#123;</span><br><span class="line">            c1 = c0 + <span class="number">1</span>;</span><br><span class="line">            r1 = r0;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="string">'V'</span>) &#123;</span><br><span class="line">            c1 = c0;</span><br><span class="line">            r1 = r0 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r1 &gt;= n || c1 &gt;= n || grid[r1][c1] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="string">'C'</span> &amp;&amp; (grid[r0 + <span class="number">1</span>][c0+<span class="number">1</span>] == <span class="number">1</span> || grid[r0 + <span class="number">1</span>][c0] == <span class="number">1</span> &amp;&amp; grid[r0][c0+<span class="number">1</span>] == <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        seen[r0][c0] += dir == <span class="string">'H'</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> dir; <span class="comment">// 'H' or 'V'</span></span><br><span class="line">        <span class="keyword">int</span> r; <span class="comment">// tail row</span></span><br><span class="line">        <span class="keyword">int</span> c; <span class="comment">//tail column</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Snake</span><span class="params">(<span class="keyword">char</span> dir, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.dir = dir;</span><br><span class="line">            <span class="keyword">this</span>.r = r;</span><br><span class="line">            <span class="keyword">this</span>.c = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于这个, 我们继续把之前的代码进行修改, 如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tail_r;</span><br><span class="line">        <span class="keyword">int</span> tail_c;</span><br><span class="line">        <span class="keyword">char</span> direction; <span class="comment">//'H' / 'V'</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Snake</span><span class="params">(<span class="keyword">int</span> tail_r, <span class="keyword">int</span> tail_c, <span class="keyword">char</span> d)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tail_r = tail_r;</span><br><span class="line">            <span class="keyword">this</span>.tail_c = tail_c;</span><br><span class="line">            <span class="keyword">this</span>.direction = d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Snake <span class="title">moveRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Snake(<span class="keyword">this</span>.tail_r, <span class="keyword">this</span>.tail_c + <span class="number">1</span>, direction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Snake <span class="title">moveDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Snake(<span class="keyword">this</span>.tail_r + <span class="number">1</span>, <span class="keyword">this</span>.tail_c, direction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Snake <span class="title">rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">char</span> direction = <span class="keyword">this</span>.direction == <span class="string">'H'</span> ? <span class="string">'V'</span> : <span class="string">'H'</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Snake(<span class="keyword">this</span>.tail_r, <span class="keyword">this</span>.tail_c, direction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] fetchPos() &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.direction == <span class="string">'H'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                        &#123;tail_r, tail_c&#125;,</span><br><span class="line">                        &#123;tail_r, tail_c + <span class="number">1</span>&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                        &#123;tail_r, tail_c&#125;,</span><br><span class="line">                        &#123;tail_r + <span class="number">1</span>, tail_c&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        Snake s = <span class="keyword">new</span> Snake(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'H'</span>);</span><br><span class="line">        <span class="keyword">int</span> n = grid.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Snake&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.offer(s);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                Snake snake = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (isDestination(snake.fetchPos(), grid)) <span class="keyword">return</span> ans;</span><br><span class="line">                Snake down = <span class="keyword">null</span>, right = <span class="keyword">null</span>, rotate = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//move down</span></span><br><span class="line">                <span class="keyword">if</span> (snake.direction == <span class="string">'H'</span> &amp;&amp; snake.tail_r + <span class="number">1</span> &lt; n &amp;&amp; snake.tail_c + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[snake.tail_r + <span class="number">1</span>][snake.tail_c] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            grid[snake.tail_r + <span class="number">1</span>][snake.tail_c + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        grid[snake.tail_r + <span class="number">1</span>][snake.tail_c]</span><br><span class="line">                                = grid[snake.tail_r + <span class="number">1</span>][snake.tail_c + <span class="number">1</span>]</span><br><span class="line">                                = <span class="number">1</span>;</span><br><span class="line">                        down = snake.moveDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snake.direction == <span class="string">'V'</span> &amp;&amp; snake.tail_r + <span class="number">2</span> &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[snake.tail_r + <span class="number">2</span>][snake.tail_c] == <span class="number">0</span>) &#123;</span><br><span class="line">                        grid[snake.tail_r + <span class="number">2</span>][snake.tail_c] = <span class="number">1</span>;</span><br><span class="line">                        down = snake.moveDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//move right</span></span><br><span class="line">                <span class="keyword">if</span> (snake.direction == <span class="string">'H'</span> &amp;&amp; snake.tail_c + <span class="number">2</span> &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[snake.tail_r][snake.tail_c + <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        grid[snake.tail_r][snake.tail_c + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                        right = snake.moveRight();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snake.direction == <span class="string">'V'</span> &amp;&amp; snake.tail_c + <span class="number">1</span> &lt; n &amp;&amp; snake.tail_r + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[snake.tail_r + <span class="number">1</span>][snake.tail_c] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            grid[snake.tail_r + <span class="number">1</span>][snake.tail_c + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        grid[snake.tail_r + <span class="number">1</span>][snake.tail_c] = grid[snake.tail_r + <span class="number">1</span>][snake.tail_c + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                        right = snake.moveRight();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//rotate clockwise</span></span><br><span class="line">                <span class="keyword">if</span> (snake.direction == <span class="string">'H'</span> &amp;&amp; snake.tail_c + <span class="number">1</span> &lt; n &amp;&amp; snake.tail_r + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[snake.tail_r + <span class="number">1</span>][snake.tail_c] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            grid[snake.tail_r + <span class="number">1</span>][snake.tail_c + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        rotate = snake.rotate();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snake.direction == <span class="string">'V'</span> &amp;&amp; snake.tail_c + <span class="number">1</span> &lt; n &amp;&amp; snake.tail_r + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[snake.tail_r][snake.tail_c + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            grid[snake.tail_r + <span class="number">1</span>][snake.tail_c + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        rotate = snake.rotate();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != right) q.offer(right);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != down) q.offer(down);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != rotate) q.offer(rotate);</span><br><span class="line">            &#125;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDestination</span><span class="params">(<span class="keyword">int</span>[][] pos, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">return</span> pos[<span class="number">0</span>][<span class="number">0</span>] == m - <span class="number">1</span> &amp;&amp; pos[<span class="number">0</span>][<span class="number">1</span>] == n - <span class="number">2</span> &amp;&amp;</span><br><span class="line">                pos[<span class="number">1</span>][<span class="number">0</span>] == m - <span class="number">1</span> &amp;&amp; pos[<span class="number">1</span>][<span class="number">1</span>] == n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//[[0,0,0,0,0,1],[1,1,0,0,1,0],[0,0,0,0,1,1],[0,0,1,0,1,0],[0,1,1,0,0,0],[0,1,1,0,0,0]]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().minimumMoves(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次周赛 AC 了三个题, 前面三个题目用时30分钟. 最后一个题抖抖索索不太敢写下去, 其实还是深度优先遍历的使用, 也暴露了我对于这些算法使用的不熟悉</p>]]></content>
    
    <summary type="html">
    
      20190915周赛记录
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="competition" scheme="https://caribouw.github.io/Caribou.github.io/tags/competition/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-413 Arithmetic Slices</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/26/leetcode-413/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/26/leetcode-413/</id>
    <published>2019-09-26T12:15:02.000Z</published>
    <updated>2019-09-26T12:20:44.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p><p>For example, these are arithmetic sequence:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure><p>The following sequence is not arithmetic.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure><p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p><p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p><p>The function should return the number of arithmetic slices in the array A.</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>简单的DP问题. 每一次遇到 <code>dp[i]</code> 的时候, 需要考虑之前的 <strong>最长等差数列的长度</strong> .</p><p>如果最长等差数列的长度为 $n$ , 那么可以得到状态转移方程 <code>dp[i] = dp[i-1] + n​</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; n ; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + countArithLength(A,i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countArithLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pad = A[endIndex] - A[endIndex - <span class="number">1</span>] , ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = endIndex<span class="number">-1</span> ; i &gt;= <span class="number">1</span> ; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] - A[i<span class="number">-1</span>] == pad) ++ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>speed 100% ;</p><p>mem 100%</p>]]></content>
    
    <summary type="html">
    
      等差数列计数
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-419 Battleships in a Board</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/24/leetcode-419/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/24/leetcode-419/</id>
    <published>2019-09-24T01:19:23.000Z</published>
    <updated>2019-09-24T01:27:56.546Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Given an 2D board, count how many battleships are in it. The battleships are represented with <code>&#39;X&#39;``&#39;.&#39;</code></p><ul><li>You receive a valid board, made of only battleships or empty slots.</li><li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape <code>1xN</code> (1 row, N columns) or <code>Nx1</code> (N rows, 1 column), where N can be of any size.</li><li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X..X</span><br><span class="line">...X</span><br><span class="line">...X</span><br></pre></td></tr></table></figure><p>In the above board there are <strong>2</strong> battleships.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始想到 DP 来做, 当前位置的数和三个数有关 : <code>dp[i-1][j-1] , dp[i][j-1] , dp[i-1][j]</code> . 当且仅当 : <code>board[i][j] = &#39;X&#39;</code> 并且左节点和上节点都是 <code>.</code> 时 , 战舰数目加一</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Solution::solutionDP(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board) &#123;</span><br><span class="line">    <span class="keyword">int</span> row = board.size();</span><br><span class="line">    <span class="keyword">int</span> col = board[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span> (row * col == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//construct the dp arr</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == dot)</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == ship)</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//首先进行边界的分析. 具体为 : 最左侧和最上侧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; col; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][i - <span class="number">1</span>] == dot &amp;&amp; board[<span class="number">0</span>][i] == ship)</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i - <span class="number">1</span>][<span class="number">0</span>] == dot &amp;&amp; board[i][<span class="number">0</span>] == ship)</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> basic = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//add a ship</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == ship &amp;&amp; board[i - <span class="number">1</span>][j] == dot &amp;&amp; board[i][j - <span class="number">1</span>] == dot) &#123;</span><br><span class="line">                dp[i][j] = basic + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = basic;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是后来一想，根本不需要这么麻烦啊. 谨记 ：当状态转移方程出现了 <code>dp[i][0] = dp[i - 1][0]</code> 这样的方式, 都是可以进行空间复杂度上的优化的 . 在这里就可以直接优化到 <code>O(1)</code>.</p><p>我们判定当前的 <code>board[i][j]</code>:</p><ul><li>如果是 <code>X</code>, 那么当且仅当 <code>board[i-1][j] , board[i][j-1]</code>都是 <code>.</code> 时需要把计数器加一</li><li>其他所有情况, 计数器不变即可</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Mem rank : 100 %</p><p>Speed rank : 99.4 %</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Solution::solutionOnePass(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board) &#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = board.size();</span><br><span class="line">    <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == ship &amp;&amp;</span><br><span class="line">                ((i == <span class="number">0</span> || board[i - <span class="number">1</span>][j] == dot)) &amp;&amp; (j == <span class="number">0</span> || board[i][j - <span class="number">1</span>] == dot)) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      计数二维矩阵中的战舰数目
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="One way pass" scheme="https://caribouw.github.io/Caribou.github.io/tags/One-way-pass/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-740 Delete and earn</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/23/leetcode-740%20/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/23/leetcode-740 /</id>
    <published>2019-09-23T15:23:08.000Z</published>
    <updated>2019-09-23T09:53:58.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除每个等于 <code>nums[i] - 1</code> 或 <code>nums[i] + 1</code> 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>典型的使用 DP . 每一次的pick选取都会导致近邻的元素被同时删除. 这时候我们就需要考虑 <code>选取pick的时候进行profit最大化</code> . 这样也有一点贪心算法的味道. 具体是不是我也不清楚hhh</p><p>首先需要得到数组的各个数产生的 <code>profit</code> 大小 , 这里我使用了一个数组 <code>profits</code> 来进行表示.</p><p>此后进行 <code>dp</code> 数组的维护, 状态转移方程分析如下 :</p><p>在选取位置 <strong>i</strong> 处的总效益时</p><ol><li>如果选取 <code>profit[i]</code> ，那么 <code>profit[i-1]</code> 必定没有被选取. 我们得到 <code>profit[i] + dp[i-2]</code></li><li>如果不选取 <code>profit[i]</code> , 那么就有 <code>dp[i] = dp[i-1]</code></li></ol><p>将如上两种情况进行最大值比较，状态转移方程如下 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max (dp[i-1] , dp[i-2] + profit[i])</span><br></pre></td></tr></table></figure><h3 id="Post-on-LC"><a href="#Post-on-LC" class="headerlink" title="Post on LC"></a>Post on LC</h3><p>The  <code>profit</code> means the total profit of the single number.<br>For example , the array [2,2,3,3,4] . The profit of <strong>2</strong> is <strong>4</strong>  and the profit of <strong>3</strong> is <strong>6</strong>. </p><p>Then we could maintain the <strong>dp</strong> array. That is : If we choose the current <strong>i</strong> to pick , the we cannot pick <strong>i-1</strong> . So if <strong>i-1</strong> is chosen , we have to check the dp[i-2] + profits[i] to see the total profit , otherwise we compare it with the dp[i-1]<br>Thus the <code>dp[i]=max(dp[i-1],dp[i-2]+profits[i])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10001</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; profits = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : nums)</span><br><span class="line">            profits[n]+=n;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>] = profits[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">2</span> ; i&lt; n ;++i)&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>],profits[i] + dp[i<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DP" scheme="https://caribouw.github.io/Caribou.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-513 Find Bottom Left Tree Value</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/17/leetcode-513/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/17/leetcode-513/</id>
    <published>2019-09-17T15:23:08.000Z</published>
    <updated>2019-09-17T02:22:02.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="513-寻找最深最左二叉树节点"><a href="#513-寻找最深最左二叉树节点" class="headerlink" title="513 寻找最深最左二叉树节点"></a>513 寻找最深最左二叉树节点</h2><p>Given a binary tree, find the leftmost value in the last row of the tree.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉树的层次序遍历. 但是有所不同的是, 需要判定每一层的开始位置 。所以我们在每一层queue push 进入之后，添加一个nullptr来进行标记</p><ul><li>当队列中第一次遇到 <code>nullptr</code> 处在队列末尾, 表示队首节点是最左侧 , 更新 <code>ans</code>。后续再次遇到 <code>nullptr</code> 在队尾时不再计入</li><li>当<code>nullptr</code>处在队首, 表示一行已经被遍历完全. 直接把 <code>nullptr</code> 重新放置到队尾. 置标记位为 <code>true</code></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>首先我们来看一下简单的二叉树层次序遍历的逻辑</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Solution::levelPrint(TreeNode *root) &#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">queue</span>.empty()) &#123;</span><br><span class="line">        <span class="comment">//visit</span></span><br><span class="line">        TreeNode *node = <span class="built_in">queue</span>.front();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; node-&gt;val &lt;&lt; <span class="string">","</span>;</span><br><span class="line">        <span class="comment">//pop</span></span><br><span class="line">        <span class="built_in">queue</span>.pop();</span><br><span class="line">        <span class="comment">//push back</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            <span class="built_in">queue</span>.push(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            <span class="built_in">queue</span>.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常明显，我们一直进行队列的出、入, 当队列为空时, 表示我们已经完成了层次序遍历</p><ul><li>我们继续看本题. 由于队尾标识 <code>nullptr</code> 会一直存在, 我们无法根据 <code>队列为空</code> 来进行遍历终结的判定. 那么什么时候已经遍历完了呢？ 非常简单，整个队列只有 <code>nullptr</code> 一个元素. </li></ul><p>具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Solution::findBottomLeftValue(TreeNode *root) &#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">auto</span> *ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">queue</span>.push(root);</span><br><span class="line">    <span class="built_in">queue</span>.push(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">bool</span> endFlag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">queue</span>.empty()) &#123;</span><br><span class="line">        <span class="comment">//visit</span></span><br><span class="line">        TreeNode *node = <span class="built_in">queue</span>.front();</span><br><span class="line">        <span class="built_in">queue</span>.pop();</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;<span class="comment">//第一个不是空</span></span><br><span class="line">            <span class="keyword">if</span> (endFlag &amp;&amp; !<span class="built_in">queue</span>.back()) &#123;</span><br><span class="line">                ans-&gt;val = node-&gt;val;</span><br><span class="line">                endFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//push back</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                <span class="built_in">queue</span>.push(node-&gt;left);</span><br><span class="line">                endFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                <span class="built_in">queue</span>.push(node-&gt;right);</span><br><span class="line">                endFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>.front() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">queue</span>.pop();</span><br><span class="line">            <span class="built_in">queue</span>.push(<span class="literal">nullptr</span>);</span><br><span class="line">            endFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      寻找二叉树中最深一层的最左侧节点
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Tree" scheme="https://caribouw.github.io/Caribou.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>如果可以选择更加友好的方式</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/15/review2019-09-15/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/15/review2019-09-15/</id>
    <published>2019-09-15T14:04:54.000Z</published>
    <updated>2019-09-15T14:08:56.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Review-for-20190915"><a href="#Review-for-20190915" class="headerlink" title="Review for 20190915"></a>Review for 20190915</h2>]]></content>
    
    <summary type="html">
    
      9月到了中旬，时已过中秋
    
    </summary>
    
      <category term="Review" scheme="https://caribouw.github.io/Caribou.github.io/categories/Review/"/>
    
    
  </entry>
  
  <entry>
    <title>LC周赛 2019-09-15</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/15/LC%E5%91%A8%E8%B5%9B-2019-09-15/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/15/LC周赛-2019-09-15/</id>
    <published>2019-09-15T08:41:44.000Z</published>
    <updated>2019-09-15T09:26:47.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-寻找字符串中Balloon个数"><a href="#1-寻找字符串中Balloon个数" class="headerlink" title="1. 寻找字符串中Balloon个数"></a>1. 寻找字符串中Balloon个数</h2><p>给你一个字符串 <code>text</code>，你需要使用 <code>text</code> 中的字母来拼凑尽可能多的单词 <strong>“balloon”（气球）</strong>。</p><p>字符串 <code>text</code> 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 <strong>“balloon”</strong>。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>很快可以通过哈希表来建立一个 <code>字符到字符在text中出现次数</code>的映射, 然后根据<code>ballon</code> 来进行对照得出最终结果: 一定是 { <code>b</code> 出现次数 , <code>a</code> 出现次数 , <code>n</code> 出现次数 , <code>l</code> 出现次数的一半 , <code>o</code> 出现次数的一半 } 中的最小值, 即满足</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNumberOfBalloons</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length(); ++i) &#123;</span><br><span class="line">            map.put(text.charAt(i), map.getOrDefault(text.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = map.getOrDefault(<span class="string">'b'</span>, <span class="number">0</span>),</span><br><span class="line">                a = map.getOrDefault(<span class="string">'a'</span>, <span class="number">0</span>),</span><br><span class="line">                l = map.getOrDefault(<span class="string">'l'</span>, <span class="number">0</span>) / <span class="number">2</span>,</span><br><span class="line">                o = map.getOrDefault(<span class="string">'o'</span>, <span class="number">0</span>) / <span class="number">2</span>,</span><br><span class="line">                n = map.getOrDefault(<span class="string">'n'</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.min(b, Math.min(a, Math.min(l, Math.min(o, n))));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-反转每对括号间的子串"><a href="#2-反转每对括号间的子串" class="headerlink" title="2. 反转每对括号间的子串"></a>2. 反转每对括号间的子串</h2><p>给出一个字符串 <code>s</code>（仅含有小写英文字母和括号）。</p><p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p><p>注意，您的结果中 <strong>不应</strong> 包含任何括号。</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>很明显这是一个 <strong>递归</strong> 问题. 举例说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(u(love)i)&quot;</span><br></pre></td></tr></table></figure><p>我们需要先找出 <strong>最小匹配括号子串</strong> , 将其翻转之后, 再对其父级的子串进行翻转. </p><p>但是有一个比较坑的点, 测试用例里面有这样的 <code>a()b(((c)))de</code> ， 也就是说，可以存在平级的括号. 这一点当时没想到. 从这里我们需要改变想法：</p><ul><li>当遇到同级的括号，先处理过当前的 <code>()</code> 对，然后继续使用 ReverseParentheses 来对后续同级括号进行翻转. 这个属于迭代式的处理</li><li>当遇到子级括号, 也就是正常的 <code>(d(c))</code>这样的情况，就使用递归函数解决</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>)</span><br><span class="line">            begin = i;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">            end = i;</span><br><span class="line">            String temp = s.substring(begin + <span class="number">1</span>, end);<span class="comment">//最小 ()</span></span><br><span class="line">            <span class="keyword">return</span> reverseParentheses(s.substring(<span class="number">0</span>, begin) + reverseString(temp) + s.substring(end + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] temp = s.toCharArray();</span><br><span class="line">    StringBuilder r = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = temp.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        r.append(temp[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-k次串联数组之后的最大子数组之和"><a href="#3-k次串联数组之后的最大子数组之和" class="headerlink" title="3. k次串联数组之后的最大子数组之和"></a>3. k次串联数组之后的最大子数组之和</h2><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code>。</p><p>首先，我们要对该数组进行修改，即把原数组 <code>arr</code> 重复 <code>k</code> 次。</p><blockquote><p>举个例子，如果 <code>arr = [1, 2]</code> 且 <code>k = 3</code>，那么修改后的数组就是 <code>[1, 2, 1, 2, 1, 2]</code>。</p></blockquote><p>然后，请你返回修改后的数组中的最大的子数组之和。</p><p>注意，子数组长度可以是 <code>0</code>，在这种情况下它的总和也是 <code>0</code>。</p><p>由于 <strong>结果可能会很大</strong>，所以需要 <strong>模（mod）</strong> <code>10^9 + 7</code> 后再返回。 </p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>一看，这个不就是最大子数组的翻版吗 hhh , 那么直接贪心上啊 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MOD = <span class="number">1000_000_007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumHelper</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalLen = arr.length * k;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalLen; ++i) &#123;</span><br><span class="line">            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = Math.max(sum, max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，<strong>TLE</strong> 了. 也就是说，这个算法不容忍 <strong>O(N)</strong> 的时间复杂度. 我们需要找到数组在进行串联的时候的一个和数关系来进行快速获取答案.</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>前缀和判断，一共如下可能</p><ul><li><p>答案为 0</p></li><li><p>答案仅从当前不串联的数组中得到, 即 k = 1时的最大子数组和</p></li><li><p>答案从 k = 2 的串联结果得到，第一部分的后缀和的最大值加上第二部分的前缀和的最大值。</p></li><li><p>答案从整个串联 k &gt; 2 次后的结果得到，且一定是第一部分的后缀和的最大值，中间部分的总和，加上最后一部分的前缀和的最大值。</p></li></ul><p>第二种可能从<strong>当前前缀和</strong>减去<strong>当前前缀和的最小值</strong>得到。</p><p>前缀和的最大值直接可以维护出来，后缀和的最大值可以通过总和减去前缀和的最小值得到。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>需要维护数组的 <strong>总和</strong>, <strong>最大前缀和</strong> , <strong>最小前缀和</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MOD = <span class="number">1000_000_007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kConcatenationMaxSum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> sumHelper(arr);</span><br><span class="line">    <span class="keyword">long</span>[] sum = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">long</span>[] maxL = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">long</span>[] minL = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">        maxL[i] = Math.max(maxL[i - <span class="number">1</span>], sum[i]);</span><br><span class="line">        minL[i] = Math.min(minL[i - <span class="number">1</span>], sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.max(ans,</span><br><span class="line">            Math.max(</span><br><span class="line">                    sum[n] - minL[n] + maxL[n],</span><br><span class="line">                    sum[n] - minL[n] + maxL[n] + sum[n] * (k - <span class="number">2</span>)</span><br><span class="line">            )</span><br><span class="line">    ) % MOD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumHelper</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalLen = arr.length;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalLen; ++i) &#123;</span><br><span class="line">        sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(sum, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-查找集群内的「关键连接」"><a href="#4-查找集群内的「关键连接」" class="headerlink" title="4. 查找集群内的「关键连接」"></a>4. 查找集群内的「关键连接」</h2><p>力扣数据中心有 <code>n</code> 台服务器，分别按从 <code>0</code> 到 <code>n-1</code> 的方式进行了编号。</p><p>它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 <code>connections</code> 是无向的。</p><p>从形式上讲，<code>connections[i] = [a, b]</code> 表示服务器 <code>a</code> 和 <code>b</code> 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。</p><p>「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。</p><p>请你以任意顺序返回该集群内的所有 「关键连接」。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      20190915周赛记录
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="competition" scheme="https://caribouw.github.io/Caribou.github.io/tags/competition/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-406 Reconstruct Queue</title>
    <link href="https://caribouw.github.io/Caribou.github.io/2019/09/14/leetcode-406-ReconstructQueue/"/>
    <id>https://caribouw.github.io/Caribou.github.io/2019/09/14/leetcode-406-ReconstructQueue/</id>
    <published>2019-09-14T15:23:08.000Z</published>
    <updated>2019-09-15T08:40:59.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="406-队列重组问题"><a href="#406-队列重组问题" class="headerlink" title="406 队列重组问题"></a>406 队列重组问题</h2><p>题干：给予的队列中，每一个元素表示了这个人的身高、他之前不比他矮的人的个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">思路:</span><br><span class="line">* 比较菜，看了第一个hint.</span><br><span class="line">* 第一个hint里面提到, 我们可以先对 h 值最小的入手.</span><br><span class="line">* 我们得到最小的h 一个人 P0 之后,是可以直接定位他重排之后的位置的. 假设从0计数，那么最矮的人的位置和k的关系就是</span><br><span class="line">* P0 处在位置k.</span><br><span class="line">* 当然,如果存在多个身高最小的人,那么他们的k大小必然是连续的. 依次根据k值从小到大排列即可</span><br><span class="line">*</span><br><span class="line">* 一个人的位置定下之后,我们就可以继续找身高第二小的人. 注意这时候也可能会有身高一样的情况发生.</span><br><span class="line">* 假设身高第二小的人 P1 (h1,k1) . 他重排之后的位置为index. 重排之后在他前面的身高比他小的人数为pre .</span><br><span class="line">* 那么不难得出如下等式</span><br><span class="line">*      index = k1 + pre</span><br><span class="line">* 这样一来程序就不难写了</span><br></pre></td></tr></table></figure><p>如上是第一次写的想法. 其实是被hint带进去了。我想着从最矮的人入手，但是在当最矮的人入队列之后，第二个参数 <code>k</code> 的条件将会被打破. </p><ul><li>注意：这时我的初始排序策略为 : <code>优先判定身高进行升序排列，身高相同者第二个参数升序排列</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="最矮方案不行那就重新审视题目"><a href="#最矮方案不行那就重新审视题目" class="headerlink" title="最矮方案不行那就重新审视题目"></a>最矮方案不行那就重新审视题目</h4><p>hint里面提到了 ： 如果找到了最矮的人，那么可以马上确定他的位置. 这句话其实有另一层含义 ——如果一个人最后被插入队列，那么只有当其身高是最矮的时候，那么肯定可以确定他需要插入到 <code>k</code> 这个位置上. 那么我们转变排序策略, 进行 <code>优先判定身高进行降序排列, 身高相同者第二个参数升序排列</code>，以此来保证其排序完成后，可以根据该排序的先后顺序，依次进行插入.</p><h4 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Solution::reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;people) &#123;</span><br><span class="line">    sort(people.begin(),people.end(),[](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span><br><span class="line">    &#123; <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : people)</span><br><span class="line">        ans.insert(ans.begin()+v[<span class="number">1</span>], v);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。
    
    </summary>
    
      <category term="算法" scheme="https://caribouw.github.io/Caribou.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Queue" scheme="https://caribouw.github.io/Caribou.github.io/tags/Queue/"/>
    
  </entry>
  
</feed>
