[{"title":"背包问题","url":"/Caribou.github.io/2020/01/15/背包问题/","content":"\n### 1. 01背包问题\n\n有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。\n\n分析：\n\n- 每一个背包只有 **拿出 or 不拿出** 两种情况\n- 对于 **dp** 数组，我们某一个状态 `dp[i][j]` 表示 **前i种背包的情况下，他们的总重量是 j 的最优解**\n  - 如果 **i** 背包不拿，那么 `dp[i][j] = dp[i - 1][j]`\n  - 如果 **i** 背包拿取，那么 `dp[i][j] = dp[i - 1][j - weights[i]] + values[i]`\n    - 也就是说，拿取之后，需要看剩下的部分最优解\n\n#### 算法优化\n\n根据之前的状态转移方程，我们可以约减一维的 **dp** 空间\n\n改进之后的 **dp** 状态转移方程如下：\n\n`dp[i] = max(dp[j], dp[j - weights[i]] + values[i])`\n\n> 为什么在内层循环，**j** 需要逆序？\n>\n> 在没有开始计算的时候，**dp[i]表示的是dp\\[i-1]\\[j]** 。而当我们需要计算 `dp[i] = max(dp[j], dp[j - weights[i]] + values[i])`的时候，需要保证 `dp[j - w[i]]` 是 **没有被改变的**。因此需要**从后往前**\n\n### 2. 完全背包问题\n\n每一件物品可以 **无限次** 拿取\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int N , V;\n    cin >> N >> V;\n    vector<int> w(N + 1) , v(N + 1);\n    for(int i = 1 ; i <= N ; ++i) cin >> w[i] >> v[i];\n    \n    vector<vector<int>> dp(N + 1 , vector<int>(V + 1 , 0));\n    \n    for(int i = 1; i <= N ; ++i){\n        for(int j = 0 ;j <= V; ++j){\n            dp[i][j] = dp[i - 1][j];\n            for(int k = 0 ; k*w[i] <= j; ++k){\n                dp[i][j] = max(dp[i][j] , dp[i][j - k * w[i]] + k * v[i]);\n            }\n        }\n    }\n    \n    cout << dp[N][V] << endl;\n    \n}\n```\n\n最重要的状态转移方程对比\n\n- **01背包** ：`dp[i][j] = max(dp[i-1][j],dp[i - 1][j - w[i]] + v[i])`\n- **完全背包** ：`dp[i][j] = max(dp[i][j] , dp[i - 1][j - k * w[i]] + k * v[i]);`\n\n不难看出，两者其实非常的类似。根据下标我们可以给出压缩之后的优化版本完全背包解法\n\n> **01背包** 和 **完全背包** 的不同\n>\n> ```cpp\n> //01背包\n> for i  in 0 ... N\n>     for  j = V ... 0\n>         f[j] = max{f[j], f[j - weight[i]] + value[i]}\n> //完全背包\n> for i int 0 ... N\n>   \tfor\t j = 0 ... V\n>       \tf[j] = max{f[j] , f[j - weight[j]] + value[i]}\n> ```\n>\n> 可以看出，只有内层循环的执行顺序不同\n\n给出 **完全背包问题** 的优化方案\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n    int n , capacity;\n    cin >> n >> capacity;\n    vector<int> c(n + 1) , w(n + 1);\n    vector<int> dp(max(n , capacity));\n    for(int i = 1 ; i <= n ;++i) cin >> c[i] >> w[i];\n    \n    for(int i = 1; i <= n ;++i)\n        for(int j = c[i] ; j <= capacity ; ++j)\n            dp[j] = max(dp[j] , dp[j - c[i]] + w[i]);\n    \n    cout << dp[capacity];\n}\n```\n\n","tags":["算法"]},{"title":"c++新特性","url":"/Caribou.github.io/2020/01/15/c-新特性/","content":"\n## What’s new in C++ 11?\n\n###  storage duration specifier\n\n多个C++版本都对变量存储时间的定义有严格的说明\n\n- `auto` - *automatic* storage duration.\n\n- `register` - *automatic* storage duration. Also hints to the compiler to place the object in the processor's register. (deprecated) ——*since C++ 17*\n\n- `static` - *static* or *thread* storage duration and *internal* linkage\n\n- `extern` - *static* or *thread* storage duration and *external* linkage.\n\n- `thread_local` - *thread* storage duration\n\n  The `thread_local` keyword is only allowed for objects declared at namespace scope, objects declared at block scope, and static data members. It indicates that the object has **thread storage duration**. It can be combined with `static` or `extern` to specify internal or external linkage (except for static data members which always have external linkage), respectively, but that additional `static` doesn't affect the storage duration.\n\n- `mutable` - does not affect storage duration or linkage\n\n  注意：`mutable` 主要是标识 **const对象** 中某些可变的成员，实现了从二进制的物理 **const** 到逻辑 **const** (外观不变)\n\n### Variadic templates\n\n可变类模板，在 `c++ reference` 里面以 *parameter pack* 来代替\n\n```cpp\ntemplate<class... Types>\t\t\t//class ... Types 是一个 pack 的声明\t\nvoid f(Types... args) {}\t\t\t//Types... args 是\n```\n\n#### Pack Expansion\n\n- `&args...` 代表的是参数扩展\n- `&args`代表的是 *pack pattern* 本身\n\n### Move semantics\n\n> **凡是取地址（`&`）操作可以成功的都是左值，其余都是右值**\n>\n> - 等号左边的不一定是左值——可以通过操作符重载来让左部变成 **右值**\n\n#### 右值引用\n\n我们之前常见的都是 **左值引用**，指的是我们只能够将 **左值** 赋给一个引用。\n\n-  `int& a = 1` 就是非法的。而我们也可以 `int const& i = 42;` 来进行一个 *tricky* 的躲避\n\n  在 `c++11`中允许了右值引用的出现\n```\nint&& a = 3;\n```\n\n#### 移动语义\n\n我们在进行 `Test(const Test& test)` 拷贝构造函数的执行过程中，会造成很多的拷贝浪费。当单独的一次拷贝构造函数 (特别是对指针数组这些资源)过程消耗特别大的时候，对于性能来说是很低的。\n\n那么 `c++11`标准给出了 **移动拷贝构造函数** 和 **移动赋值操作符重载**。此外，还支持 `std::move()`来强制性让 **左值转化为右值**\n\n#### 完美转发\n\n我们想要实现\n\n> 多级函数调用过程中\n>\n> - 如果变量是左值，那么它作为其他函数的参数的时候也应该是 **左值**\n> - 如果变量是右值，那么它作为其他函数的参数的时候也应该是 **右值**\n\n```cpp\ntemplate <typename T>\nvoid func(T t) {\n    cout << \"in func\" << endl;\n}\n\ntemplate <typename T>\nvoid relay(T&& t) {\n    cout << \"in relay\" << endl;\n    func(t);\n}\n\nint main() {\n    relay(Test());\n}\n```\n\n上面这个例子就是一个 **反例**。我们在传入 `func(t)` 的时候，其实调用了 **拷贝构造函数** (因为编译器把 **t** 当做了一个 **左值**)\n\n> `std::forward<T>()` ，能够保留参数的左右值类型\n\n### Value Category\n\n不止左值右值那么简单\n\n> Cpp reference:\n>\n> Each C++ [expression](https://en.cppreference.com/w/cpp/language/expressions) (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a *type* and a *value category*. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: *prvalue*, *xvalue*, and *lvalue*.\n\n\n\n","tags":["整理"]},{"title":"杂谈-沉思帖","url":"/Caribou.github.io/2019/12/22/杂谈-鸡血帖/","content":"\n> 多尝试新的方向，不浮躁地随波逐流；\n>\n> 有一个自己喜爱的方向是如此地难能可贵\n\n## 杂谈-沉思帖\n\n2019 秋季这个课表算是无法无天了，虽然在春季就做了一些心理预设，但是当它到来的时候，特别是到了现在考试周将近，还是压得人喘不过气。\n\n前一段时间一直在各处投递简历。在打消了出国打算、ML的打算之后，我从暑期就开始对自己的方向进行了思考，留给我试错的时间已经不多了，在后续的一年半时间中，我是需要针对一桩事业真正投入地进行付出，并且能够有一定的产出的。在我各处找着实习的时候，字节一面后十分钟的拒信给了我巨大的打击——\n\n> 基础不牢，地动山摇\n\n面试官丢给我的几乎每一个计网问题我都招架不来，可以说上个学期学的内容全数奉还给了老师。内心千万个声音在警戒着我：你的基础根本不牢固，做了种种项目又有什么用？\n\n图森的面试官告诉我，如果这些基本的网络知识不过关，如何能够在出错的时候进行精准的错误排查？特别是在客户流量比较大的情况下，网络阻塞、丢包这些错误屡见不鲜，如何可以最大限度地减少经济损失？\n\n> 网络协议中每一层的网络攻击可以有哪些？\n\n这个问题我可能一辈子也不忘了，图森的二面官这么一个问题丢过来，我当时的反应就是：一个也没有。\n\n后续的结果也显而易见，又是一封拒信。虽然 `coding` 过关，但是基础过于不扎实而不会要我。\n\n所以，基础 基础 基础！！！\n\n什么叫做基础呢？\n\n其实这些问题，老师课上也没有系统性的说过。我丢失了大一的时候看书的习惯，大二只是对课堂内的东西进行机械接受。最讽刺的就是，当字节面试官问“你觉得计网是一门怎么样的课”的时候，我第一反应回答就是“一门背书的课”。我现在回顾过来，真想好好打当时的自己一个巴掌。不过事实的确如此，我在大二下就是背书来学计网的，当时的我根本没有心思听老师讲课，只想着多做一些项目美滋滋。\n\n现在就到了要亡羊补牢的时候了，11月上旬的样子吧，我开始恶补我之前的 `JVM`, 计网，多线程，`linux` 内核相关的知识。加上后续几个面试的逼迫，我可以说拼了老命在学 (这么紧的课程还要面试，真的会折磨我自己)\n\n`12.21` ，*TX* 的面试官突然打来电话，约了一面。可以说这次是我把握比较好的一次面试了。说着，人的确就是一个犯贱的种，需要一些外力压迫来威胁自己去学习。还有一个很重要的点就是，我真的过于浮躁了，急于求成想去学 *ML* 但是发现真实资源如此贫乏(一整个院搞什么ML? 我们又不是人工智能学院！) 没有一个前辈带领的路走得真心艰苦，没有方向，没有可以去追随的人，于是放弃。现在是时候好好静下心去听听自己了。\n\n> 冬至已至。\n>\n> 希望新的一年，能够笃定，坚毅。","tags":["UpUp"],"categories":["杂谈"]},{"title":"TCP/IP 阅读笔记(1)","url":"/Caribou.github.io/2019/12/14/TCP-IP-阅读笔记-1/","content":"\n### TCP连接形式\n\nTCP连接使用了一对套接字 (`socket`) 来进行唯一表示，也就是把 `IP` 头部的源和目的IP地址，携同TCP头部的源端口号和目的端口号，来进行一个标识。\n\n### Seq 与 Ack\n\n序列号与响应号是通信双方进行确认判定的依据。每一次报文中的响应号就是上一次报文的序列号  + 1 ，表示了接收方想要接收的下一个序列号。\n\n我们所熟知的三次握手，其实本质上就是发送方和接收方的序列号交换：\n\n> 第一次报文发送：SYN表明是客户端期望进行序列号同步，并且发送自己的序列号\n>\n> 第二次报文发送：SYN表示是服务端期望进行序列号同步，返回之前客户端的序列号 + 1 , 表示此时客户端序列号已经同步。此时还需要发送服务端自己的序列号，等待客户端是否给予最后一次响应。\n>\n> 第三次报文发送：ACK确实就是服务端序列号 + 1 的话，那么表明服务端的序列号也已经同步。至此通过三次报文交换来实现全双工通信的两端序列号同步。\n\n对于四次挥手，其实也是序列号的交换问题。\n\n书上的问题给出了进一步的思考：如果出现同时建立连接和同时断开连接，报文发送个数是多少？\n\n- 对于同时建立连接的情况，一开始同时就会有两次报文发送，这时候两个报文都是 SYN，期望同步自己的序列号。此时连接两端的两个 `socket` 其实都只需要得到自己想要的 `ACK` 就可以了。这时候就是四次报文交换\n- 对于同时断开连接的情况，和上面完全一样，也是四次\n\n### TIME_WAIT问题\n\n四次挥手结束之后，连接断开的发起者还会继续等待 `2MSL` 的时间长度，这种做法能够避免最后一次 **ACK** 因为网络问题没有发送到，给 **被动断开方** 时间进行超时重传。\n\n在发起者还在等待的时候，其实两端的端口还是在连接的状态。问题就来了——端口占用问题。\n\n也就是说，如果我们这时候在服务端或者客户端，断开 `socket` 却又立即重启，这时候就会出现端口占用的情况，导致我们的连接被拒绝。\n\n","tags":["读书笔记"]},{"title":"设计模式-单例","url":"/Caribou.github.io/2019/12/07/设计模式-单例/","content":"\n## 单例模式\n\n给出最原始的代码\n\n```java\npublic class Singleton {\n\n    //一个静态的实例\n    private static Singleton singleton;\n    //私有化构造函数\n    private Singleton(){}\n    //给出一个公共的静态方法返回一个单一实例\n    public static Singleton getInstance(){\n        if (singleton == null) {\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n```\n\n现在我们就需要考虑==多线程环境==下的单例模式实现了\n\n**懒汉模式**\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton(){}\n    public static Singleton getInstance(){\n        if (instance == null) {\n            //Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n**饿汉模式**\n\n```java\npublic class Singleton {\n    private static Singleton instance = new Singleton();\n    private Singleton(){}\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n> 多线程下的懒汉模式会出现问题——在判定是 *null* 的时候，还没来得及进行创建实例，另一个进程就进入进行判定\n\n#### 解决办法1\n\n方法上添加 **synchronized** 关键字\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton(){}\n    public static synchronized Singleton getInstance(){\n        if (instance == null) {\n            //Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n> 问题：如果两个线程都要获取单例引用，只能等一个线程获取后，另一个线程才能获取。\n\n#### 解决方法2\n\n双检查锁机制（Double Check Locking）,也叫”DCL“\n\n> 双锁的意思，是指 检测两次instance是否为空。\n\n```java\npublic class Singleton {  \n      \n    //使用volatile关键字保其可见性  \n    volatile private static Singleton instance = null;  \n      \n    private MySingleton(){}  \n       \n    public static MySingleton getInstance() {   \n            if(instance == null){//懒汉式   \n                  synchronized (Singleton.class) {  \n                    if(instance == null){//二次检查  \n                        instance = new MySingleton();  \n                    }  \n                } \n            }\n        return instance;  \n    }  \n}  \n```\n\n#### 解决办法3\n\n当然，我们最好还是采取**饿汉式**\n\n```java\npublic class Singleton{\n    //类加载时就初始化\n    private static final Singleton instance = new Singleton();\n    \n    private Singleton(){}\n\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n#### 解决办法4\n\n采取 **静态内部类**\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE; \n    }  \n}\n```\n\n#### 解决办法5\n\n枚举 Enum\n\n```java\npublic enum EasySingleton{\n    INSTANCE;\n}\n```\n\n","tags":["设计模式"]},{"title":"数据库-索引","url":"/Caribou.github.io/2019/12/05/数据库整理-索引/","content":"\n## 索引\n\n#### 页存储\n\n<img src=\"https://i.loli.net/2019/12/05/dQE6NVkHZJcWfye.png\" style=\"zoom:50%;\" />\n\n如上就是数据库在Disk Storage的一个存储方式。一个页包含若干 *Data Rows* , 通过 *Row directory* 来进行索引\n\n> A row in a table can be uniquely specified with the page number (P) and slot number (S).\n\n##### 位图索引\n\nhttps://www.cnblogs.com/LBSer/p/3322630.html\n\n位图索引中只维护distinct值，也就是说重复的值是不维护在树中\n\n对于每一个列建立一个\n\n- 位图索引适合只有几个固定值的列，如性别、婚姻状况、行政区等等，而身份证号这种类型不适合用位图索引。\n\n- 此外，位图索引适合静态数据，而不适合索引频繁更新的列\n\n##### 散列索引\n\n散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。\n\n散列索引根据对应键的散列码来找到最终的索引项的技术，其实和B树就差不多，也就是一种索引之上的二级辅助索引，我理解散列索引都是二级或更高级的稀疏索引，否则桶就太多了，效率也不会很高\n\n##### 聚簇索引\n\n所谓聚簇索引，就是指**主索引文件**和**数据文件**为==同一份文件==，聚簇索引主要用在**Innodb**存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，如下图所示：\n\n在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。\n\n##### 非聚簇索引\n\n聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接**指向对应数据块**。\n\n##### 辅助索引\n\n在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要**二次查找**。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据叶，再通过数据叶中的Page Directory找到数据行\n\n##### 唯一索引\n\n表明此索引的==每一个索引值只对应唯一的数据记录==，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复\n\n##### 主键索引\n\n在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问\n\n---\n\n数据库引擎 ：myISAM , innodb\n\nmyisam索引：因为myisam的索引和数据是分开存储存储的，myisam通过**key_buffer**把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因  \n\ninnodb索引：innodb的数据和索引放在一起，当找到索引也就找到了数据\n\n<img src=\"https://img-blog.csdn.net/20161102111454921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\" style=\"zoom:75%;\" />\n\n1.对于**非聚簇索引表**来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。\n\n2.对于**聚簇索引表**来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)\n\n> ##### 聚簇索引的优点\n>\n> 1.当你需要取出==一定范围内==的数据时，用聚簇索引也比用非聚簇索引好。\n>\n> 2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。\n>\n> 3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。\n>\n> ##### 聚簇索引的缺点\n>\n> 1.**插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。\n>\n> 2.**更新主键的代价很高，因为将会导致被更新的行移动**。因此，对于InnoDB表，我们一般定义主键为不可更新。\n>\n> 3.**二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。**\n>\n> 二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。\n>\n> 4.**采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多**，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。\n\n\n\n","tags":["笔记"],"categories":["笔记"]},{"title":"leetcode_1043","url":"/Caribou.github.io/2019/11/08/leetcode-1043/","content":"\n### 描述\n\nGiven an integer array `A`, you partition the array into (contiguous) subarrays of length at most `K`. After partitioning, each subarray has their values changed to become the maximum value of that subarray.\n\nReturn the largest sum of the given array after partitioning.\n\n \n\n**Example 1:**\n\n```\nInput: A = [1,15,7,9,2,5,10], K = 3\nOutput: 84\nExplanation: A becomes [15,15,15,9,10,10,10]\n```\n\n### 思路\n\n构造一个 _dp_ 数组, 满足\n\n- `dp[i]` 表示max sum of A[0: i+1)\n\n那么我们在接下来的每一个 `dp[i]` 中, 需要不断向前查询.将 `i` 之前的数组内容分成两部分：\n\n1. 已经dp纳入计算的部分 _pre_\n2. 当前计算的 _cur_\n\n那么我们逐步增加 _cur_ 的长度 ( from 1 to min(k,i) ) , 找到这个 _cur_ 子数组的最大值 , 乘以 _cur_ 长度，那么就是 _cur_ 子数组的最优解\n\n```cpp\n\t\tint maxSumAfterPartitioning(vector<int> &A, int K) {\n        int n = A.size();\n        vector<int> dp(n + 1);\n        for (int i = 1; i <= n; i++) {\n            int cur_max = -1;\n          \t// j from 1 to min(K,i)\n            for (int j = 1; j <= min(K, i); j++) {\n                cur_max = max(cur_max, A[i - j]);\n                dp[i] = max(dp[i], dp[i - j] + cur_max * j); \n            }\n        }\n        return dp[n];\n    }\n```\n\n","tags":["Array"],"categories":["算法"]},{"title":"leetcode_1238 Grey Code","url":"/Caribou.github.io/2019/10/28/leetcode-1238/","content":"\n引用：https://cp-algorithms.com/algebra/gray-code.html\n\n### 描述\n\nGiven 2 integers `n` and `start`. Your task is return **any** permutation `p` of `(0,1,2.....,2^n -1) `such that :\n\n- `p[0] = start`\n- `p[i]` and `p[i+1]` differ by only one bit in their binary representation.\n- `p[0]` and `p[2^n -1]` must also differ by only one bit in their binary representation.\n\n### 思路\n\n说实话，一开始没思路. 之后根据discussion才了解到格雷码的概念\n\n实现特别简单，直接套公式\n\n```cpp\nclass Solution {\n    public List<Integer> circularPermutation(int n, int start) {\n       List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < 1 << n; ++i)\n            res.add(start ^ i ^ i >> 1);\n        return res; \n    }\n}\n```\n\n### 格雷码\n\n格雷码是一种准权码，具有一种反射特性和循环特性的单步自补码，它的循环、单步特性消除了随机取数时出现重大误差的可能，它的反射、自补特性使得求反非常方便。格雷码属于可靠性编码，是一种错误最小化的编码方式。\n\n自然二进制码可以直接由数/模转换器转换成模拟信号，但是在某些情况下，例如从十进制的3转换到4的二进制时，每一位都要变。3的二进制位：**011**，而4的二进制位：**100**，所以这就会使数字电路产生很大的尖峰电流脉冲。而格雷码则没有这一缺点，它是一种数字排序系统，其中的所有相邻整数在它们的数字表示中只有一个数字不同。它在任意两个相邻的数之间转换时，只有一个数位发生变化。它大大地减少了由一个状态到下一个状态时逻辑的混淆。另外由于最大数与最小数之间也仅一个位不同，故通常又叫**格雷反射码**或**循环码**。\n\n#### 求解\n\n```\n　　G(i) = B(i+1) XOR B(i); 0 <= i < N - 1\n　　G(i) = B(i);      i = N - 1\n```\n\n也就是说, 格雷码根据当前位和前一位进行 **异或** 运算 , 最高位不变\n\n那么\n\n```\nG = G ^ (G >> 1)\n```\n\n只能说，这个没接触过的知识，让我在一开始做的时候根本找不到入手点... 还是太弱了","categories":["算法"]},{"title":"leetcode_470","url":"/Caribou.github.io/2019/10/15/leetcode-470/","content":"\n### 描述\n\nGiven a function `rand7` which generates a uniform random integer in the range 1 to 7, write a function `rand10` which generates a uniform random integer in the range 1 to 10.\n\nDo NOT use system's `Math.random()`.\n\n**Example 1:**\n\n```\nInput: 1\nOutput: [7]\n```\n\n**Example 2:**\n\n```\nInput: 2\nOutput: [8,4]\n```\n\n**Example 3:**\n\n```\nInput: 3\nOutput: [8,1,10]\n```\n\n \n\n### 思路\n\n非常非常有趣的一个题目！\n\n已知有一个函数rand7() , 需要我们给出rand10()的算法实现\n\n思路可以说百花齐放. 这里我给出几个\n\n#### 两次rand7扩展范围\n\n一次 `rand7()` 的范围是 `[1,7] ` , 那么 `(rand7() - 1) * 7 + rand7() - 1` 的范围就是 `[0,47]`\n\n这时我们舍弃大于等于40的部分 即可\n\n```cpp\nclass Solution {\npublic:\n    int rand10() {\n        int rand40 = 40;\n        while (rand40 >= 40) {\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\n        }\n        return rand40 % 10 + 1;\n    }\n    \n};\n```\n\n#### 暴力版随机\n\n没有用到一次rand7()\n\n```cpp\nclass Solution {\npublic:\n    int rand10() {\n        return 1 + count++ % 10;\n    }\n    \nprivate:\n    int count = 0;    \n};\n```","categories":["算法"]},{"title":"leetcode_1143_最长公共序列","url":"/Caribou.github.io/2019/10/12/leetcode-1143/","content":"\n### 描述\n\nGiven two strings text1 and text2, return the length of their longest common subsequence.\n\nA subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not). A common subsequence of two strings is a subsequence that is common to both strings.\n\n**Example 1:**\n\n```\nInput: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n```\n\n**Example 2:**\n\n```\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n```\n\n**Example 3:**\n\n```\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n```\n\n### 思路\n\n使用DP来进行实现. 第一版的想法就是构造一个二维数组 `dp[m][n]` , 对于 `dp[i][j]` 表示 `text1.subStr(0,i)` 和 `text2.subStr(0,j)`的最长公共序列长度.\n\n状态转移方程如下：\n\n- 如果当前 `text1[i]=text2[j]`,  `dp[i][j]=1+dp[i-1][j-1]`\n- 否则就是之前进行匹配的 `dp[i][j]=max(dp[i-1][j],dp[i][j-1])`\n\n```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n        int dp[][] = new int[m + 1][n + 1];\n        \n        for(int i = 0; i <= m ; ++i){\n            for(int j  = 0 ; j <= n ; ++j){\n                if(i * j == 0) \n                    dp[i][j] = 0;\n                else if (text1.charAt(i-1) == text2.charAt(j-1)){\n                    dp[i][j] = 1 + dp[i-1][j-1];\n                }else{\n                    dp[i][j] = Math.max(dp[i-1][j] , dp[i][j-1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n```","categories":["算法"]},{"title":"leetcode_214","url":"/Caribou.github.io/2019/10/10/leetcode-214/","content":"\n### 描述\n\n对于给定的字符串s，可以通过在其前面添加字符将其转换为回文。查找并返回通过执行此转换可以找到的最短回文\n\n**Example 1:**\n\n```\nInput: \"aacecaaa\"\nOutput: \"aaacecaaa\"\n```\n\n**Example 2:**\n\n```\nInput: \"abcd\"\nOutput: \"dcbabcd\"\n```\n\n### 思路\n\n首先想到的, 我们需要找到字符串的中轴字符. 从该字符往外进行查找, 其最坏情况就是以**第一个字符**来进行扩展. 最好情况就是从中间的字符进行扩展. 我们可以从最中间开始进行查找, 第一个找到的就是最短的字符串\n\n```cpp\nstring shortestPalindrome(string s) {\n        int n = s.length();\n        //从最好情况往最差情况找\n        //起点是 .5\n        int index = 0;\n        string ans;\n        while (n >= 0) {\n            if (n % 2 == 0) {\n                index = n / 2;\n                ans = findPalindrome(s, index - 1, index);\n            } else {\n                index = (n - 1) / 2;\n                ans = findPalindrome(s, index, index);\n            }\n            if (!ans.empty())return ans;\n            --n;\n        }\n        return findPalindrome(s, 0, 0);\n    }\n\n    string findPalindrome(string s, int leftIndex, int rightIndex) {\n        int n = s.length();\n        if (rightIndex >= n) return \"\";\n        while (leftIndex >= 0 && rightIndex < n) {\n            if (s[leftIndex] != s[rightIndex]) return \"\";\n            --leftIndex;\n            ++rightIndex;\n        }\n        string ans = s;\n        while (rightIndex < n) {\n            ans = s[rightIndex++] + ans;\n        }\n        return ans;\n    }\n```\n\nBTW , 这个Solution 很不幸的TLE了hh\n\n### Solutions\n\n#### Brute force\n\n将原有的字符串 `s` 看做是两个部分：前半部分是一个 Palidorm **A** , 后半部分 **B** 不是. 那么当我们找到最长的 **Palidorm** 时, 只需要把第二个部分回转, 复制到首部就可以. (这样相当于 $B^rAB$ )\n\n```cpp\nstring shortestPalindrome(string s)\n{\n    int n = s.size();\n    string rev(s);\n    reverse(rev.begin(), rev.end());\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n        if (s.substr(0, n - i) == rev.substr(i))\n            return rev.substr(0, i) + s;\n    }\n    return \"\";\n}\n```\n\n但是很不幸 , 这个在最后一个用例也 TLE 翻车了\n\n#### Manacher's Algorithm 马拉车算法\n\n我的算法中, 主要的想法就是从各个可能的中心点往两边进行展开，时间复杂度达到了 $O(N^2)$。 而Manacher's Algorithm 将查询回文串的时间复杂度优化到了 $O(N)$\n\n1. 在原有的字符串中，相邻两个字符之间都插入 $\\#$ ，两边插入标识开始和结尾的符号。最终该字符串长度一定是**奇数**\n\n![img](https://pic4.zhimg.com/80/v2-8c613143224234c971d9b5353a3f05aa_hd.jpg)\n\n2. 最终需要构造出一个生成数组 $P$ , 它如下表示 : \n\n每一个位置都表示以当前位置为中心进行扩展的字符串长度 (包括 **#** )  那么在原字符串中，其\n\n字符串的位置是 `(i - P[i])/2 , (i - P[i])/2 + P[i] - 1`\n\n回文串长度是 `P[i] - 1`\n\n在新的字符串中, `Right_index = P[i] + i` . 也就是说，我们可以根据 **P[i]**来获取最 **右** 字符的位置\n![img](https://pic4.zhimg.com/80/v2-d570f7a9e732d577d556b0e6cff1d263_hd.jpg)\n\n3. 数组 $P$ 生成\n\n\u0010我们获取 $P[i]$ 的时候不再总是根据当前为中心进行两边扩展，而是根据 $P[j], for\\;0\\le j <i$ 来进行\n\n假设我们需要求 `P[i]` , 此前求出的最大回文串的中心 index 为 `Po` , 它的最右侧 index 为 `P`\n\n#### KMP算法\n\n```C\nint KMP(char *t, char *p) {\n    int i = 0;\n    int j = 0;\n\n    while (i < strlen(t) && j < strlen(p)) {\n        if (j == -1 || t[i] == p[j]) {\n            i++;\n            j++;\n        } else\n            j = next[j];\n    }\n\n    if (j == strlen(p))\n        return i - j;\n    else\n        return -1;\n}\n\nvoid getNext(char *p, int *next) {\n    next[0] = -1;\n    int i = 0, j = -1;\n\n    while (i < strlen(p)) {\n        if (j == -1 || p[i] == p[j]) {\n            ++i;\n            ++j;\n            next[i] = j;\n        } else\n            j = next[j];\n    }\n}\n\n```\n\n给出如下 PMT 的示例\n\n![img](https://pic1.zhimg.com/80/v2-40b4885aace7b31499da9b90b7c46ed3_hd.jpg)\n\nPMT的含义：\n\n```\n对于字符串 s , index 为 i 时，PMT[i] 表示它的 [前缀集合] 交  [后缀集合] 之后的最长匹配长度\n其中前缀集合和后缀集合不包含数组本身\n```\n\n为编程方便需要，我们给出 next 数组。它实质上是 PMT数组右移一位, 且`next[0] = -1`\n\n根据这个，我们可以给出算法逻辑\n\n- 如果当前指针匹配，那么原字符串 target 和匹配串 pattern 的指针分别自增即可\n- 如果发生不匹配，那么 target 不变动 (懒惰式), 匹配串指针 `j = next[j]`\n\n相比如马拉车算法，KMP算法的适用性还是更加广泛的\n\n---\n\n我们回到这个问题上来，回顾一下我们的目标\n\n```\nadd string before the input so the result string will be a palindrome\n在原有的字符串之前插入一些字符串，使得它最终是一个回文串\n```\n\n在 **Brute force** 里面已经提到：我们先找出最长的、从0下标开始的最长回文串 P , 那么只要把 **剩下的子串反转之后insert到开头**就可以构造出结果. 这一点很好理解\n\n那么我们的目标就变成\n\n```\n寻找从0下标开始的最长回文串\n```\n\n那么我们怎么把这个问题和之前说到的 **KMP** 算法结合呢？同样的也是进行字符串匹配. 我们需要把字符串进行预先的反转，而后把回文的匹配转化为正向的字符串匹配. 具体算法流程如下：\n\n1. 给定字符串 **s** , 我们反转它, 得到 **s\\*** . 生成字符串 `s#s*`. 这样一来，我们只需要生成 KMP 表即可 (因为 **s** 和 **s\\***就是前缀和后缀)\n\n2. 假设新的字符串 `s#s*` 的长度是 m , 那么 next[m] 的值就是我们所需要查找的 `从0下标开始的最长回文串`的长度. 取得 s.substr(m) , 进行反转之后复制到首部即可\n\n```java\n\t\tprivate int[] fetchNext(String s) {\n        int j = -1, i = 0;\n        int[] ans = new int[s.length()];\n        ans[0] = -1;\n        while (i < s.length() - 1) {\n            if (-1 == j || s.charAt(i) == s.charAt(j)) {\n                ++j;\n                ++i;\n                if (i == s.length())\n                    break;\n                ans[i] = j;\n            } else {\n                j = ans[j];\n            }\n        }\n        return ans;\n    }\n\n    public String shortestPalindrome(String s) {\n        StringBuilder sb = new StringBuilder(s).reverse();\n        String wholeStr = s + \"#\" + sb.toString();\n        int[] next = fetchNext(wholeStr);\n        int index = next[wholeStr.length() - 1];\n        return new StringBuilder(s.substring(index + 1)).reverse().append(s).toString();\n    }\n```\n\n","tags":["String"],"categories":["算法"]},{"title":"leetcode_941","url":"/Caribou.github.io/2019/10/10/leetcode-941/","content":"\n### 描述\n\nGiven an array `A` of integers, return `true` if and only if it is a *valid mountain array*.\n\nRecall that A is a mountain array if and only if:\n\n- `A.length >= 3`\n\n- There exists some i with `0 < i < A.length - 1`\n\n   such that:\n\n  - `A[0] < A[1] < ... A[i-1] < A[i]`\n  - `A[i] > A[i+1] > ... > A[A.length - 1]`\n\n \n\n**Example 1:**\n\n```\nInput: [2,1]\nOutput: false\n```\n\n**Example 2:**\n\n```\nInput: [3,5,5]\nOutput: false\n```\n\n**Example 3:**\n\n```\nInput: [0,3,2,1]\nOutput: true\n```\n\n### 思路\n\n- 数组长度不小于3\n- 数组中不存在连续的相同的数\n- 需要满足：\n  - 存在最高点\n  - 最高点出现之前需要上升\n  - 最高点之后严格递减\n\n```cpp\nclass Solution {\npublic:\n    bool validMountainArray(vector<int>& A) {\n        if (A.size() < 3) return false;\n\n        int mount = A[0];\n        bool reachTop = false , asc = false;\n        for(int i=1; i<A.size();++i){\n            if (mount == A[i]) return false;\n            if (!reachTop){\n                if(mount < A[i]) {\n                    asc = true;\n                }\n                else if (mount > A[i]){\n                    reachTop = true;\n                }\n                mount = A[i];\n            }else{\n                if(mount <= A[i]) return false;\n                else{\n                    mount = A[i];\n                }\n            }\n        }\n        return asc && reachTop;\n    }\n};\n```\n\n","tags":["Array"],"categories":["算法"]},{"title":"LC周赛 2019-10-05","url":"/Caribou.github.io/2019/10/08/leetcode-周赛20191005/","content":"\n## 1. Play with Chips\n\n### 描述\n\nThere are some chips, and the i-th chip is at position `chips[i]`.\n\nYou can perform any of the two following types of moves **any number of times** (possibly zero) **on any chip**:\n\n- Move the `i`-th chip by 2 units to the left or to the right with a cost of **0**.\n- Move the `i`-th chip by 1 unit to the left or to the right with a cost of **1**.\n\nThere can be two or more chips at the same position initially.\n\nReturn the minimum cost needed to move all the chips to the same position (any position).\n\n### 思路 \n\n如果两个chip的位置相差为偶数, 则 `cost = 0`. 否则 `coust = 1 `\n\n我们预先获取chip的一个哈希来进行缓存, 之后遍历哈希中的每一个数, 作为 **目的地**.\n\n那么我们的问题就变成 ： 找出那一个 **目的地** , 使得 `cost` 最小即可\n\n```java\n    public int minCostToMoveChips(int[] chips) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : chips) {\n            set.add(num);\n        }\n        int min = Integer.MAX_VALUE;\n        for (int num : set) {\n            int sum = 0;\n            for (int chip : chips) {\n                int dis = Math.abs(num - chip);\n                sum += dis % 2;\n                if (sum > min) break;\n            }\n            min = Math.min(sum, min);\n        }\n        return min;\n    }\n```\n\n## 2. Longest Arithmetic Subsequence of Given Difference\n\n### 描述\n\nGiven an integer array `arr` and an integer `difference`, return the length of the longest subsequence in `arr` which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals `difference`.\n\n**Example 1:**\n\n```\nInput: arr = [1,2,3,4], difference = 1\nOutput: 4\nExplanation: The longest arithmetic subsequence is [1,2,3,4].\n```\n\n**Example 2:**\n\n```\nInput: arr = [1,3,5,7], difference = 1\nOutput: 1\nExplanation: The longest arithmetic subsequence is any single element.\n```\n\n**Example 3:**\n\n```\nInput: arr = [1,5,7,8,5,3,4,2,1], difference = -2\nOutput: 4\nExplanation: The longest arithmetic subsequence is [7,5,3,1].\n```\n\n### 思路\n\n一开始很明显想到用 `DP` 来解决. 每一步前进的同时需要缓存下当前位置, 便于后续的查找\n\n我们缓存如下的内容：\n\n- 每一个数字和它所处可能位置 `Set` 的哈希映射\n- DP 数组，用于当前 `dp[i]` 的确定\n\n一开始就这样做了，但是 error 了一次. 原因就是这里的 dp 数组并不是单调上升，因为可能会出现中间断层的情况，例如 `[1,2,3,1,2,3,4]` , 中间的 `1` 位置就是断层的出现点. (之后一想，其实也可以通过自己的维护来进行避免，问题不大)\n\n最终代码如下\n\n```java\n public int longestSubsequence(int[] arr, int difference) {\n        int n = arr.length;\n        int[] dp = new int[n];\n        Map<Integer, Set<Integer>> map = new HashMap<>();\n        dp[0] = 1;\n        Set<Integer> set = new HashSet<>();\n        set.add(0);\n        map.put(arr[0], set);\n        for (int i = 1; i < n; ++i) {\n            if (!map.containsKey(arr[i])) {\n                set = new HashSet<>();\n                set.add(i);\n                map.put(arr[i], set);\n            } else {\n                set = map.get(arr[i]);\n                set.add(i);\n                map.put(arr[i], set);\n            }\n\n            int target = arr[i] - difference;\n            if (!map.containsKey(target)) { //不包含前一个数\n                dp[i] = 1;\n            } else {\n                set = map.get(target);\n                int maxLen = 0;\n                for (int num : set) {\n                    maxLen = Math.max(maxLen, dp[num]);\n                }\n                dp[i] = maxLen + 1;\n            }\n        }\n        int ans = 0;\n        for (int num : dp) {\n            ans = Math.max(num, ans);\n        }\n        return ans;\n    }\n```\n\n## 3. Path with Maximum Gold\n\n### 描述\n\nIn a gold mine `grid` of size `m * n`, each cell in this mine has an integer representing the amount of gold in that cell, `0` if it is empty.\n\nReturn the maximum amount of gold you can collect under the conditions:\n\n- Every time you are located in a cell you will collect all the gold in that cell.\n- From your position you can walk one step to the left, right, up or down.\n- You can't visit the same cell more than once.\n- Never visit a cell with `0` gold.\n- You can start and stop collecting gold from **any** position in the grid that has some gold. \n\n**Example 1:**\n\n```\nInput: grid = [[0,6,0],[5,8,7],[0,9,0]]\nOutput: 24\nExplanation:\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\nPath to get the maximum gold, 9 -> 8 -> 7.\n```\n\n**Example 2:**\n\n```\nInput: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\nOutput: 28\nExplanation:\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\nPath to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n```\n\n### 思路\n\n很简单的 DFS 算法实现, 没什么好说的\n\n```java\npublic int getMaximumGold(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int max = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] != 0) {\n                    max = Math.max(max, dfs(grid, new int[]{i, j}, 0));\n                }\n            }\n        }\n        return max;\n    }\n\n    private int dfs(int[][] grid, int[] startPos, int gold) {\n        int m = grid.length, n = grid[0].length;\n        int r = startPos[0], c = startPos[1];\n        if (r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == 0) return gold;\n        gold += grid[r][c];\n        int[][] nums = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                nums[i][j] = grid[i][j];\n            }\n        }\n        nums[r][c] = 0;             //Get the gold\n        int a1 = dfs(nums, new int[]{r, c + 1}, gold);\n        int b1 = dfs(nums, new int[]{r, c - 1}, gold);\n        int c1 = dfs(nums, new int[]{r + 1, c}, gold);\n        int d1 = dfs(nums, new int[]{r - 1, c}, gold);\n        return Arrays.stream(new int[]{a1, b1, c1, d1}).max().getAsInt();\n    }\n```\n\n## 4. Count Vowels Permutation\n\n### 描述\n\nGiven an integer `n`, your task is to count how many strings of length `n` can be formed under the following rules:\n\n- Each character is a lower case vowel (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`)\n- Each vowel `'a'` may only be followed by an `'e'`.\n- Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.\n- Each vowel `'i'` **may not** be followed by another `'i'`.\n- Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.\n- Each vowel `'u'` may only be followed by an `'a'.`\n\nSince the answer may be too large, return it modulo `10^9 + 7.`\n\n**Example 1:**\n\n```\nInput: n = 1\nOutput: 5\nExplanation: All possible strings are: \"a\", \"e\", \"i\" , \"o\" and \"u\".\n```\n\n**Example 2:**\n\n```\nInput: n = 2\nOutput: 10\nExplanation: All possible strings are: \"ae\", \"ea\", \"ei\", \"ia\", \"ie\", \"io\", \"iu\", \"oi\", \"ou\" and \"ua\".\n```\n\n**Example 3:** \n\n```\nInput: n = 5\nOutput: 68\n```\n\n### 思路\n\n假定某一步的最末位中, ‘a’ , ‘e’ , ‘i’ , ‘o’ , ‘u’ 的个数分别是 a , e , i , o , u ，那么下一步末位的个数就分别是 `u+e+i`, `a + i`, `e + o` , `i` , `o +i` \n\n我这里用了一个hash来保存 (小声：这个hard题是简单题的赶脚233)\n\n```java\nclass Solution {\nprivate final long mod = 1_000_000_007;\n    public int countVowelPermutation(int n) {\n        Map<Character, Long> map = new HashMap<>();\n        map.put('a', 1L);\n        map.put('e', 1L);\n        map.put('i', 1L);\n        map.put('o', 1L);\n        map.put('u', 1L);\n        for (int i = 1; i < n; ++i) {\n            Map<Character, Long> tmp = new HashMap<>();\n            tmp.put('a', (map.get('u') + map.get('e') + map.get('i')) % mod);\n            tmp.put('e', (map.get('a') + map.get('i')) % mod);\n            tmp.put('i', (map.get('e') + map.get('o')) % mod);\n            tmp.put('o', (map.get('i')) % mod);\n            tmp.put('u', (map.get('o') + map.get('i')) % mod);\n\n            map = tmp;\n        }\n        return (int) (map.values().stream().reduce(Long::sum).get() % mod);\n    }\n}\n```\n\n## 结语\n\n这次周赛4个题目全部 AC , RANK  740","tags":["competition"],"categories":["算法"]},{"title":"LC周赛 2019-09-29","url":"/Caribou.github.io/2019/09/29/leetcode-20190929周赛/","content":"\n## 1. Unique Number of Occurrences\n\n### 描述\n\nGiven an array of integers `arr`, write a function that returns `true` if and only if the number of occurrences of each value in the array is unique.\n\n给出一个`int`数组中的各个数的 **出现次数** 是否唯一\n\n### 实现\n\n可以直接利用 **map** 来存储各个数的出现次数, 而后进行 value-set 的值的比较即可\n\n```java\npublic boolean uniqueOccurrences(int[] arr) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : arr) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        Set<Integer> set = new HashSet<>();\n        for (int key : map.keySet()) {\n            set.add(map.get(key));\n        }\n        return map.keySet().size() == set.size();\n    }\n```\n\n## 2. Get Equal Substrings Within Budget\n\n### 描述\n\nYou are given two strings `s` and `t` of the same length. You want to change `s` to `t`. Changing the `i`-th character of `s` to `i`-th character of `t` costs `|s[i] - t[i]|` that is, the absolute difference between the ASCII values of the characters.\n\nYou are also given an integer `maxCost`.\n\nReturn the maximum length of a substring of `s` that can be changed to be the same as the corresponding substring of `t`with a cost less than or equal to `maxCost`.\n\nIf there is no substring from `s` that can be changed to its corresponding substring from `t`, return `0`\n\n给出两个长度**相等**的字符串,和一个 `cost`, 我们需要给出最长的子串长度, 来让其`|s[i] - t[i]|`之和不大于cost\n\n### 实现\n\n首先可以把两个字符串相减——逐字符进行减计算，得到绝对值, 由此获取一个 `int` 数组\n\n而后的问题变为：给定一个 `int` 数组和一个 `cost` , 求出最大子数组，来满足不大于 `cost`\n\n```java\npublic int equalSubstring(String s, String t, int maxCost) {\n        int ans = 0;\n        int n = s.length();\n        int[] costs = new int[n];\n        for (int i = 0; i < n; ++i) {\n            costs[i] = Math.abs(s.charAt(i) - t.charAt(i));\n        }\n        for (int i = 0; i < n; ++i) {\n            int sum = 0;\n            for (int j = i; j < n; ++j) {\n                sum += costs[j];\n                if (sum > maxCost) {\n                    ans = Math.max(ans, j - i);\n                    break;\n                } else {\n                    ans = Math.max(ans, j - i + 1);\n                }\n            }\n        }\n\n        return ans;\n    }\n```\n\n## 3.Remove All Adjacent Duplicates in String II\n\n### 描述\n\nGiven a string `s`, a *k* *duplicate removal* consists of choosing `k` adjacent and equal letters from `s` and removing them causing the left and the right side of the deleted substring to concatenate together.\n\nWe repeatedly make `k` duplicate removals on `s` until we no longer can.\n\nReturn the final string after all such duplicate removals have been made.\n\nIt is guaranteed that the answer is unique.\n\n给定一个字符串 `s` 和一个整数 `k` , 每次我们可以一次性删除 `s` 中的 `k` 个连续的并且所有字符相同的子串, 求出最后的结果\n\n### 实现\n\n每一次根据 s , k 来从左往右查找满足该条件的子串, 返回一个长度为 **2** 的 `int` 数组, 作为满足该条件的 **第一个** 子串的指针, 逐个进行删除即可. \n\n之后也可以进行进一步优化 ： 每一次查找的时候查询所有满足该条件的子串，一次性删除 , 再进行下一轮的查询\n\n```java\n\t\tpublic String removeDuplicates(String s, int k) {\n        int[] indexes = findDuplicates(s, k);\n        String ans = s;\n        while (indexes != null) {\n            ans = ans.substring(0, indexes[0]) + ans.substring(indexes[1] + 1);\n            indexes = findDuplicates(ans, k);\n        }\n        return ans;\n    }\n\n    private int[] findDuplicates(String s, int k) {\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            char ch = s.charAt(i);\n            for (int j = i + 1; j < n; ++j) {\n                if (s.charAt(j) != ch)\n                    break;\n                else if (j - i + 1 == k) return new int[]{i, j};\n            }\n        }\n        return null;\n    }\n```\n\n## 4. Minimum Moves to Reach Target with Rotations\n\n### 描述\n\nIn an `n*n` grid, there is a snake that spans 2 cells and starts moving from the top left corner at `(0, 0)` and `(0, 1)`. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at `(n-1, n-2)` and `(n-1, n-1)`.\n\nIn one move the snake can:\n\n- Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n- Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n- Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from `(r, c)` and `(r, c+1)` to `(r, c)` and `(r+1, c)`.\n  ![img](https://assets.leetcode.com/uploads/2019/09/24/image-2.png)\n- Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from `(r, c)` and `(r+1, c)` to `(r, c)` and `(r, c+1)`.\n  ![img](https://assets.leetcode.com/uploads/2019/09/24/image-1.png)\n\nReturn the minimum number of moves to reach the target.\n\nIf there is no way to reach the target, return `-1`.\n\n###  思路\n\n很典型的DFS题目，下一步的行走都将影响后续的结果. 蛇很有可能进入 **死胡同** , 也就是我们无法进行下一步的查找.\n\n我这里单独实现了蛇的位置 (水平 / 垂直) 判定 , 蛇进行 **左移、右移、顺时针旋转、逆时针旋转** 的逻辑. 而后穷举所有可能的情况\n\n//TODO: 这个代码还没AC ， 只过了 17 / 42 \n\n```java\npublic int minimumMoves(int[][] grid) {\n        int[][] originPos = {{0, 0}, {0, 1}};\n        int ans = dfs(grid, 0, originPos);\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }\n\n    private int dfs(int[][] grid, int number, int[][] pos) {\n        //visited\n        grid[pos[0][0]][pos[0][1]] = grid[pos[1][0]][pos[1][1]] = 1;\n        if (isDestination(pos, grid)) {\n            return number;\n        }\n        int a = pos[0][0], b = pos[0][1], c = pos[1][0], d = pos[1][1];\n        int m = grid.length;\n        int n = grid[0].length;\n        if (isHorizen(pos)) {\n            // --->\n            boolean isInfi = true;\n            int A = Integer.MAX_VALUE, B = Integer.MAX_VALUE;\n            if (d + 1 < n && grid[a][d + 1] == 0) {     //You could move right\n                isInfi = false;\n                A = dfs(grid, number + 1, moveRight(pos));\n            }\n            if (a + 1 < m && grid[a + 1][b] == 0 && grid[a + 1][b + 1] == 0) {   //You could rotate clock or down\n                isInfi = false;\n                B = Math.min(dfs(grid, number + 1, clockRotate(pos)), dfs(grid, number + 1, moveDown(pos)));\n            }                                //死胡同\n            if (isInfi)\n                return Integer.MAX_VALUE;\n            else\n                return Math.min(A, B);\n        } else if (isVertical(pos)) {\n            boolean isInfi = true;\n            int A = Integer.MAX_VALUE, B = Integer.MAX_VALUE;\n            if (c + 1 < m && grid[c + 1][b] == 0) {             //You could move downWard\n                isInfi = false;\n                A = dfs(grid, number + 1, moveDown(pos));\n            } else if (b + 1 < n && grid[a][b + 1] == 0 && grid[c][b + 1] == 0) {   //You could rotate counter or right\n                isInfi = false;\n                B = Math.min(dfs(grid, number + 1, counterClockRotate(pos)), dfs(grid, number + 1, moveRight(pos)));\n            }\n            if (isInfi)\n                return Integer.MAX_VALUE;\n            else\n                return Math.min(A, B);\n        } else {//死胡同\n            return Integer.MAX_VALUE;\n        }\n    }\n\n    private boolean isDestination(int[][] pos, int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        return pos[0][0] == m - 1 && pos[0][1] == n - 2 &&\n                pos[1][0] == m - 1 && pos[1][1] == n - 1;\n    }\n\n    private boolean isHorizen(int[][] pos) {\n        return pos[0][0] == pos[1][0];\n    }\n\n    private boolean isVertical(int[][] pos) {\n        return pos[0][1] == pos[1][1];\n    }\n\n    private int[][] moveRight(int[][] pos) {\n        return new int[][]{{pos[0][0], pos[0][1] + 1},\n                {pos[1][0], pos[1][1] + 1}};\n    }\n\n    private int[][] moveDown(int[][] pos) {\n        return new int[][]{{pos[0][0] + 1, pos[0][1]},\n                {pos[1][0] + 1, pos[1][1]}};\n    }\n\n    //需要是水平的朝向\n    private int[][] clockRotate(int[][] pos) {\n        return new int[][]{\n                {pos[0][0], pos[0][1]},\n                {1 + pos[1][0], pos[0][1]}\n        };\n\n    }\n\n    private int[][] counterClockRotate(int[][] pos) {\n        return new int[][]{\n                {pos[0][0], pos[0][1]},\n                {pos[0][0], 1 + pos[0][1]},\n        };\n    }\n```\n\n这里我借鉴了讨论区大家的想法，在这里做一个分享\n\n遇到 `shortest path` , 大家的反应是使用 **BFS** . \n\n**BFS**的最简单形式为\n\n```\n在某一个点上, 遍历所有的邻接点 , 将邻接点全部push到队列中 ;\n下一轮迭代中对出队列的节点做同样的操作\n```\n\n这里贴出我觉得写得比较清楚的答案。反思一下, 我并没有进行对象化, 其实抽象成对象可以让实现变得方便很多\n\n```java\nclass Solution {\n    public int minimumMoves(int[][] grid) {\n        int n = grid.length, res = 0;\n        Queue<Snake> q = new ArrayDeque<>();\n        int[][] seen = new int[n][n];\n        // Tail has been pos (i,j), the horizontal/vertical direcitional traversed has been represented as 1 & 2 respectively\n        seen[0][0] = 1; \n        q.offer(new Snake('H', 0, 0));\n        while(!q.isEmpty()) {\n            int size = q.size();\n            System.out.println(size);\n            for(int i = 0; i < size; i++) {\n                Snake s = q.poll();\n                if (s.dir == 'H' && s.r == n -1 && s.c == n -2) return res;\n                Snake down = move(grid, seen, new Snake(s.dir, s.r + 1, s.c), 'D');\n                Snake right = move(grid, seen, new Snake(s.dir, s.r, s.c + 1), 'R');\n                char dir = (s.dir == 'H' ? 'V' : 'H');\n                Snake clock = move(grid, seen, new Snake(dir,s.r,s.c), 'C');\n                if (right != null) q.offer(right);\n                if (down != null) q.offer(down);\n                if (clock != null) q.offer(clock);\n            }\n            res++;\n        }\n        return -1;\n    }\n    \n    Snake move(int[][] grid, int[][] seen, Snake s, char action) {\n        int r0 = s.r, c0 = s.c, n = grid.length, r1 = r0, c1 = c0;\n        char dir= s.dir;\n        if (r0 >= n || c0 >= n || grid[r0][c0] == 1 || seen[r0][c0] == 3 || (seen[r0][c0] == 1 && dir == 'H') || (seen[r0][c0] == 2 && dir == 'V')) return null;\n        if (dir == 'H') {\n            c1 = c0 + 1;\n            r1 = r0;\n        } else if (dir == 'V') {\n            c1 = c0;\n            r1 = r0 + 1;\n        }\n        if (r1 >= n || c1 >= n || grid[r1][c1] == 1) return null;\n        if (action == 'C' && (grid[r0 + 1][c0+1] == 1 || grid[r0 + 1][c0] == 1 && grid[r0][c0+1] == 1)) return null;\n        seen[r0][c0] += dir == 'H' ? 1 : 2;\n        return s;\n    }\n    \n    class Snake {\n        char dir; // 'H' or 'V'\n        int r; // tail row\n        int c; //tail column\n        public Snake(char dir, int r, int c) {\n            this.dir = dir;\n            this.r = r;\n            this.c = c;\n        }\n    }\n}\n```\n\n基于这个, 我们继续把之前的代码进行修改, 如下\n\n```java\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Solution {\n    class Snake {\n        int tail_r;\n        int tail_c;\n        char direction; //'H' / 'V'\n\n        public Snake(int tail_r, int tail_c, char d) {\n            this.tail_r = tail_r;\n            this.tail_c = tail_c;\n            this.direction = d;\n        }\n\n        public Snake moveRight() {\n            return new Snake(this.tail_r, this.tail_c + 1, direction);\n        }\n\n        public Snake moveDown() {\n            return new Snake(this.tail_r + 1, this.tail_c, direction);\n        }\n\n        public Snake rotate() {\n            char direction = this.direction == 'H' ? 'V' : 'H';\n            return new Snake(this.tail_r, this.tail_c, direction);\n        }\n\n        public int[][] fetchPos() {\n            if (this.direction == 'H') {\n                return new int[][]{\n                        {tail_r, tail_c},\n                        {tail_r, tail_c + 1}\n                };\n            } else {\n                return new int[][]{\n                        {tail_r, tail_c},\n                        {tail_r + 1, tail_c}\n                };\n            }\n        }\n    }\n\n    public int minimumMoves(int[][] grid) {\n        Snake s = new Snake(0, 0, 'H');\n        int n = grid.length;\n        int ans = 0;\n        Queue<Snake> q = new ArrayDeque<>();\n        q.offer(s);\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; ++i) {\n                Snake snake = q.poll();\n                if (isDestination(snake.fetchPos(), grid)) return ans;\n                Snake down = null, right = null, rotate = null;\n                //move down\n                if (snake.direction == 'H' && snake.tail_r + 1 < n && snake.tail_c + 1 < n) {\n                    if (grid[snake.tail_r + 1][snake.tail_c] == 0 &&\n                            grid[snake.tail_r + 1][snake.tail_c + 1] == 0) {\n                        grid[snake.tail_r + 1][snake.tail_c]\n                                = grid[snake.tail_r + 1][snake.tail_c + 1]\n                                = 1;\n                        down = snake.moveDown();\n                    }\n                } else if (snake.direction == 'V' && snake.tail_r + 2 < n) {\n                    if (grid[snake.tail_r + 2][snake.tail_c] == 0) {\n                        grid[snake.tail_r + 2][snake.tail_c] = 1;\n                        down = snake.moveDown();\n                    }\n                }\n                //move right\n                if (snake.direction == 'H' && snake.tail_c + 2 < n) {\n                    if (grid[snake.tail_r][snake.tail_c + 2] == 0) {\n                        grid[snake.tail_r][snake.tail_c + 2] = 1;\n                        right = snake.moveRight();\n                    }\n                } else if (snake.direction == 'V' && snake.tail_c + 1 < n && snake.tail_r + 1 < n) {\n                    if (grid[snake.tail_r + 1][snake.tail_c] == 0 &&\n                            grid[snake.tail_r + 1][snake.tail_c + 1] == 0) {\n                        grid[snake.tail_r + 1][snake.tail_c] = grid[snake.tail_r + 1][snake.tail_c + 1] = 1;\n                        right = snake.moveRight();\n                    }\n                }\n                //rotate clockwise\n                if (snake.direction == 'H' && snake.tail_c + 1 < n && snake.tail_r + 1 < n) {\n                    if (grid[snake.tail_r + 1][snake.tail_c] == 0 &&\n                            grid[snake.tail_r + 1][snake.tail_c + 1] == 0) {\n                        rotate = snake.rotate();\n                    }\n                } else if (snake.direction == 'V' && snake.tail_c + 1 < n && snake.tail_r + 1 < n) {\n                    if (grid[snake.tail_r][snake.tail_c + 1] == 0 &&\n                            grid[snake.tail_r + 1][snake.tail_c + 1] == 0) {\n                        rotate = snake.rotate();\n                    }\n                }\n                if (null != right) q.offer(right);\n                if (null != down) q.offer(down);\n                if (null != rotate) q.offer(rotate);\n            }\n            ++ans;\n        }\n\n        return -1;\n    }\n\n    private boolean isDestination(int[][] pos, int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        return pos[0][0] == m - 1 && pos[0][1] == n - 2 &&\n                pos[1][0] == m - 1 && pos[1][1] == n - 1;\n    }\n\n\n    //[[0,0,0,0,0,1],[1,1,0,0,1,0],[0,0,0,0,1,1],[0,0,1,0,1,0],[0,1,1,0,0,0],[0,1,1,0,0,0]]\n    public static void main(String[] args) {\n        System.out.println(new Solution().minimumMoves(new int[][]{\n                {0, 0, 0, 0, 0, 1}, {1, 1, 0, 0, 1, 0}, {0, 0, 0, 0, 1, 1}, {0, 0, 1, 0, 1, 0}, {0, 1, 1, 0, 0, 0}, {0, 1, 1, 0, 0, 0}\n        }));\n    }\n}\n\n```\n\n\n\n## 总结\n\n这次周赛 AC 了三个题, 前面三个题目用时30分钟. 最后一个题抖抖索索不太敢写下去, 其实还是深度优先遍历的使用, 也暴露了我对于这些算法使用的不熟悉\n\n","tags":["competition"],"categories":["算法"]},{"title":"leetcode-413 Arithmetic Slices","url":"/Caribou.github.io/2019/09/26/leetcode-413/","content":"\n### 描述\n\nA sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, these are arithmetic sequence:\n\n```\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\n```\n\nThe following sequence is not arithmetic.\n\n```\n1, 1, 2, 5, 7\n```\n\n\n\nA zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.\n\nA slice (P, Q) of array A is called arithmetic if the sequence:\nA[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.\n\nThe function should return the number of arithmetic slices in the array A.\n\n### 实现\n\n简单的DP问题. 每一次遇到 `dp[i]` 的时候, 需要考虑之前的 **最长等差数列的长度** .\n\n如果最长等差数列的长度为 $n$ , 那么可以得到状态转移方程 `dp[i] = dp[i-1] + n​`\n\n```cpp\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        int n = A.size();\n        if(n <= 2) return 0;\n        \n        vector<int> dp(n,0);\n        dp[0] = dp[1] = 0;\n        \n        for(int i = 2 ; i < n ; ++i){\n            dp[i] = dp[i-1] + countArithLength(A,i);\n        }\n        \n        return dp[n-1];\n    }\n    \nprivate:\n    int countArithLength(vector<int>& A,int endIndex){\n        int pad = A[endIndex] - A[endIndex - 1] , ans = 0;\n        for(int i = endIndex-1 ; i >= 1 ; --i){\n            if(A[i] - A[i-1] == pad) ++ans;\n            else break;\n        }\n        return ans;\n    }\n};\n```\n\nspeed 100% ;\n\nmem 100%","categories":["算法"]},{"title":"leetcode-419 Battleships in a Board","url":"/Caribou.github.io/2019/09/24/leetcode-419/","content":"\n### 描述\n\nGiven an 2D board, count how many battleships are in it. The battleships are represented with `'X'``'.'`\n\n- You receive a valid board, made of only battleships or empty slots.\n- Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape `1xN` (1 row, N columns) or `Nx1` (N rows, 1 column), where N can be of any size.\n- At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n\n**Example:**\n\n```\nX..X\n...X\n...X\n```\n\nIn the above board there are **2** battleships.\n\n### 思路\n\n一开始想到 DP 来做, 当前位置的数和三个数有关 : `dp[i-1][j-1] , dp[i][j-1] , dp[i-1][j]` . 当且仅当 : `board[i][j] = 'X'` 并且左节点和上节点都是 `.` 时 , 战舰数目加一\n\n```cpp\nint Solution::solutionDP(vector<vector<char>> &board) {\n    int row = board.size();\n    int col = board[0].size();\n    if (row * col == 0)\n        return 0;\n    //construct the dp arr\n    vector<vector<int>> dp(row, vector<int>(col, 0));\n\n    if (board[0][0] == dot)\n        dp[0][0] = 0;\n    else if (board[0][0] == ship)\n        dp[0][0] = 1;\n    //首先进行边界的分析. 具体为 : 最左侧和最上侧\n    for (int i = 1; i < col; ++i) {\n        if (board[0][i - 1] == dot && board[0][i] == ship)\n            dp[0][i] = dp[0][i - 1] + 1;\n        else\n            dp[0][i] = dp[0][i - 1];\n    }\n\n    for (int i = 1; i < row; ++i) {\n        if (board[i - 1][0] == dot && board[i][0] == ship)\n            dp[i][0] = dp[i - 1][0] + 1;\n        else\n            dp[i][0] = dp[i - 1][0];\n    }\n\n    for (int i = 1; i < row; ++i) {\n        for (int j = 1; j < col; ++j) {\n            int basic = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\n            //add a ship\n            if (board[i][j] == ship && board[i - 1][j] == dot && board[i][j - 1] == dot) {\n                dp[i][j] = basic + 1;\n            } else {\n                dp[i][j] = basic;\n            }\n        }\n    }\n\n    return dp[row - 1][col - 1];\n}\n```\n\n但是后来一想，根本不需要这么麻烦啊. 谨记 ：当状态转移方程出现了 `dp[i][0] = dp[i - 1][0]` 这样的方式, 都是可以进行空间复杂度上的优化的 . 在这里就可以直接优化到 `O(1)`.\n\n我们判定当前的 `board[i][j]`:\n\n- 如果是 `X`, 那么当且仅当 `board[i-1][j] , board[i][j-1]`都是 `.` 时需要把计数器加一\n- 其他所有情况, 计数器不变即可\n\n### 实现\n\nMem rank : 100 %\n\nSpeed rank : 99.4 %\n\n```cpp\nint Solution::solutionOnePass(vector<vector<char>> &board) {\n    int ans = 0;\n    int m = board.size();\n    int n = board[0].size();\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (board[i][j] == ship &&\n                ((i == 0 || board[i - 1][j] == dot)) && (j == 0 || board[i][j - 1] == dot)) {\n                ++ans;\n            }\n        }\n    }\n    return ans;\n}\n```\n\n","tags":["One way pass"],"categories":["算法"]},{"title":"leetcode-740 Delete and earn","url":"/Caribou.github.io/2019/09/23/leetcode-740 /","content":"\n### 描述\n\n给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 `nums[i]` ，删除它并获得 `nums[i]` 的点数。之后，你必须删除每个等于 `nums[i] - 1` 或 `nums[i] + 1` 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。\n\n### 思路\n\n典型的使用 DP . 每一次的pick选取都会导致近邻的元素被同时删除. 这时候我们就需要考虑 `选取pick的时候进行profit最大化` . 这样也有一点贪心算法的味道. 具体是不是我也不清楚hhh\n\n首先需要得到数组的各个数产生的 `profit` 大小 , 这里我使用了一个数组 `profits` 来进行表示.\n\n此后进行 `dp` 数组的维护, 状态转移方程分析如下 :\n\n在选取位置 **i** 处的总效益时\n\n1. 如果选取 `profit[i]` ，那么 `profit[i-1]` 必定没有被选取. 我们得到 `profit[i] + dp[i-2]`\n2. 如果不选取 `profit[i]` , 那么就有 `dp[i] = dp[i-1]`\n\n将如上两种情况进行最大值比较，状态转移方程如下 :\n\n```\ndp[i] = max (dp[i-1] , dp[i-2] + profit[i])\n```\n\n### Post on LC\n\nThe  `profit` means the total profit of the single number.\nFor example , the array [2,2,3,3,4] . The profit of **2** is **4**  and the profit of **3** is **6**. \n\nThen we could maintain the **dp** array. That is : If we choose the current **i** to pick , the we cannot pick **i-1** . So if **i-1** is chosen , we have to check the dp[i-2] + profits[i] to see the total profit , otherwise we compare it with the dp[i-1]\nThus the `dp[i]=max(dp[i-1],dp[i-2]+profits[i])`\n```c++\nclass Solution {\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        const int n = 10001;\n        \n        vector<int> profits = vector<int>(n,0);\n        \n        for(auto n : nums)\n            profits[n]+=n;\n        \n        vector<int> dp = vector<int>(n,0);\n        dp[1] = profits[1];\n        for(int i= 2 ; i< n ;++i){\n            dp[i] = max(dp[i-1],profits[i] + dp[i-2]);\n        }\n        return dp[n-1];   \n    }\n};\n```","tags":["DP"],"categories":["算法"]},{"title":"leetcode-513 Find Bottom Left Tree Value","url":"/Caribou.github.io/2019/09/17/leetcode-513/","content":"\n## 513 寻找最深最左二叉树节点\n\nGiven a binary tree, find the leftmost value in the last row of the tree.\n\n### 思路\n\n二叉树的层次序遍历. 但是有所不同的是, 需要判定每一层的开始位置 。所以我们在每一层queue push 进入之后，添加一个nullptr来进行标记\n\n- 当队列中第一次遇到 `nullptr` 处在队列末尾, 表示队首节点是最左侧 , 更新 `ans`。后续再次遇到 `nullptr` 在队尾时不再计入\n- 当`nullptr`处在队首, 表示一行已经被遍历完全. 直接把 `nullptr` 重新放置到队尾. 置标记位为 `true`\n\n### 实现\n\n- 首先我们来看一下简单的二叉树层次序遍历的逻辑\n\n```cpp\nvoid Solution::levelPrint(TreeNode *root) {\n    queue<TreeNode *> queue;\n\n    queue.push(root);\n    while (!queue.empty()) {\n        //visit\n        TreeNode *node = queue.front();\n        cout << node->val << \",\";\n        //pop\n        queue.pop();\n        //push back\n        if (node->left)\n            queue.push(node->left);\n        if (node->right)\n            queue.push(node->right);\n    }\n}\n```\n\n非常明显，我们一直进行队列的出、入, 当队列为空时, 表示我们已经完成了层次序遍历\n\n- 我们继续看本题. 由于队尾标识 `nullptr` 会一直存在, 我们无法根据 `队列为空` 来进行遍历终结的判定. 那么什么时候已经遍历完了呢？ 非常简单，整个队列只有 `nullptr` 一个元素. \n\n具体代码如下：\n\n```cpp\nint Solution::findBottomLeftValue(TreeNode *root) {\n    queue<TreeNode *> queue;\n    auto *ans = new TreeNode(0);\n    queue.push(root);\n    queue.push(nullptr);\n    bool endFlag = true;\n    while (!queue.empty()) {\n        //visit\n        TreeNode *node = queue.front();\n        queue.pop();\n        if (node) {//第一个不是空\n            if (endFlag && !queue.back()) {\n                ans->val = node->val;\n                endFlag = false;\n            }\n            //push back\n            if (node->left) {\n                queue.push(node->left);\n                endFlag = false;\n            }\n            if (node->right) {\n                queue.push(node->right);\n                endFlag = false;\n            }\n        }\n        if (queue.size() == 1)\n            break;\n        if (queue.front() == nullptr) {\n            queue.pop();\n            queue.push(nullptr);\n            endFlag = true;\n        }\n\n    }\n    return ans->val;\n}\n\n```\n\n","tags":["Tree"],"categories":["算法"]},{"title":"如果可以选择更加友好的方式","url":"/Caribou.github.io/2019/09/15/review2019-09-15/","content":"\n## Review for 20190915\n\n","categories":["Review"]},{"title":"LC周赛 2019-09-15","url":"/Caribou.github.io/2019/09/15/LC周赛-2019-09-15/","content":"\n## 1. 寻找字符串中Balloon个数\n\n给你一个字符串 `text`，你需要使用 `text` 中的字母来拼凑尽可能多的单词 **\"balloon\"（气球）**。\n\n字符串 `text` 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 **\"balloon\"**。\n\n### 思路：\n\n很快可以通过哈希表来建立一个 `字符到字符在text中出现次数`的映射, 然后根据`ballon ` 来进行对照得出最终结果: 一定是 { `b` 出现次数 , `a` 出现次数 , `n` 出现次数 , `l` 出现次数的一半 , `o` 出现次数的一半 } 中的最小值, 即满足\n\n\n\n```java\npublic int maxNumberOfBalloons(String text) {\n        Map<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < text.length(); ++i) {\n            map.put(text.charAt(i), map.getOrDefault(text.charAt(i), 0) + 1);\n        }\n        int b = map.getOrDefault('b', 0),\n                a = map.getOrDefault('a', 0),\n                l = map.getOrDefault('l', 0) / 2,\n                o = map.getOrDefault('o', 0) / 2,\n                n = map.getOrDefault('n', 0);\n        return Math.min(b, Math.min(a, Math.min(l, Math.min(o, n))));\n    }\n```\n\n##  2. 反转每对括号间的子串\n\n给出一个字符串 `s`（仅含有小写英文字母和括号）。\n\n请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。\n\n注意，您的结果中 **不应** 包含任何括号。\n\n### 思路：\n\n很明显这是一个 **递归** 问题. 举例说明\n\n```\n输入：s = \"(u(love)i)\"\n```\n\n我们需要先找出 **最小匹配括号子串** , 将其翻转之后, 再对其父级的子串进行翻转. \n\n\n\n但是有一个比较坑的点, 测试用例里面有这样的 `a()b(((c)))de` ， 也就是说，可以存在平级的括号. 这一点当时没想到. 从这里我们需要改变想法：\n\n- 当遇到同级的括号，先处理过当前的 `()` 对，然后继续使用 ReverseParentheses 来对后续同级括号进行翻转. 这个属于迭代式的处理\n- 当遇到子级括号, 也就是正常的 `(d(c))`这样的情况，就使用递归函数解决\n\n```java\n    public String reverseParentheses(String s) {\n        int begin = 0;\n        int end;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(')\n                begin = i;\n            if (s.charAt(i) == ')') {\n                end = i;\n                String temp = s.substring(begin + 1, end);//最小 ()\n                return reverseParentheses(s.substring(0, begin) + reverseString(temp) + s.substring(end + 1));\n            }\n        }\n        return s;\n    }\n\n    String reverseString(String s) {\n        char[] temp = s.toCharArray();\n        StringBuilder r = new StringBuilder();\n        for (int i = temp.length - 1; i >= 0; i--)\n            r.append(temp[i]);\n\n        return r.toString();\n    }\n```\n\n## 3. k次串联数组之后的最大子数组之和\n\n给你一个整数数组 `arr` 和一个整数 `k`。\n\n首先，我们要对该数组进行修改，即把原数组 `arr` 重复 `k` 次。\n\n> 举个例子，如果 `arr = [1, 2]` 且 `k = 3`，那么修改后的数组就是 `[1, 2, 1, 2, 1, 2]`。\n\n然后，请你返回修改后的数组中的最大的子数组之和。\n\n注意，子数组长度可以是 `0`，在这种情况下它的总和也是 `0`。\n\n由于 **结果可能会很大**，所以需要 **模（mod）** `10^9 + 7` 后再返回。 \n\n### 思路：\n\n一看，这个不就是最大子数组的翻版吗 hhh , 那么直接贪心上啊 \n\n```java\nprivate static final long MOD = 1000_000_007;\n\nprivate int sumHelper(int[] arr, int k) {\n        int totalLen = arr.length * k;\n        int max = 0;\n        int sum = 0;\n        for (int i = 0; i < totalLen; ++i) {\n            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);\n            if (sum < 0) {\n                sum = 0;\n            } else {\n                max = Math.max(sum, max);\n            }\n        }\n        return max;\n    }\n```\n\n那么问题来了，**TLE** 了. 也就是说，这个算法不容忍 **O(N)** 的时间复杂度. 我们需要找到数组在进行串联的时候的一个和数关系来进行快速获取答案.\n\n#### 分析：\n\n前缀和判断，一共如下可能\n\n- 答案为 0\n\n- 答案仅从当前不串联的数组中得到, 即 k = 1时的最大子数组和\n\n- 答案从 k = 2 的串联结果得到，第一部分的后缀和的最大值加上第二部分的前缀和的最大值。\n\n- 答案从整个串联 k > 2 次后的结果得到，且一定是第一部分的后缀和的最大值，中间部分的总和，加上最后一部分的前缀和的最大值。\n\n第二种可能从**当前前缀和**减去**当前前缀和的最小值**得到。\n\n前缀和的最大值直接可以维护出来，后缀和的最大值可以通过总和减去前缀和的最小值得到。\n\n#### 实现\n\n需要维护数组的 **总和**, **最大前缀和** , **最小前缀和**\n\n```java\n    private static final long MOD = 1000_000_007;\n\n    public int kConcatenationMaxSum(int[] arr, int k) {\n        int n = arr.length;\n        if (k == 1)\n            return sumHelper(arr);\n        long[] sum = new long[n + 1];\n        long[] maxL = new long[n + 1];\n        long[] minL = new long[n + 1];\n        for (int i = 1; i < n + 1; ++i) {\n            sum[i] = sum[i - 1] + arr[i];\n            maxL[i] = Math.max(maxL[i - 1], sum[i]);\n            minL[i] = Math.min(minL[i - 1], sum[i]);\n        }\n        long ans = 0;\n        return (int) (Math.max(ans,\n                Math.max(\n                        sum[n] - minL[n] + maxL[n],\n                        sum[n] - minL[n] + maxL[n] + sum[n] * (k - 2)\n                )\n        ) % MOD);\n    }\n\n    private int sumHelper(int[] arr) {\n        int totalLen = arr.length;\n        int max = 0;\n        int sum = 0;\n        for (int i = 0; i < totalLen; ++i) {\n            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);\n            if (sum < 0) {\n                sum = 0;\n            } else {\n                max = Math.max(sum, max);\n            }\n        }\n        return max;\n    }\n```\n\n## 4. 查找集群内的「关键连接」\n\n力扣数据中心有 `n` 台服务器，分别按从 `0` 到 `n-1` 的方式进行了编号。\n\n它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 `connections` 是无向的。\n\n从形式上讲，`connections[i] = [a, b]` 表示服务器 `a` 和 `b` 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。\n\n「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。\n\n请你以任意顺序返回该集群内的所有 「关键连接」。\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png)","tags":["competition"],"categories":["算法"]},{"title":"leetcode-406 Reconstruct Queue","url":"/Caribou.github.io/2019/09/14/leetcode-406-ReconstructQueue/","content":"\n## 406 队列重组问题\n\n题干：给予的队列中，每一个元素表示了这个人的身高、他之前不比他矮的人的个数。\n\n```\n思路:\n* 比较菜，看了第一个hint.\n* 第一个hint里面提到, 我们可以先对 h 值最小的入手.\n* 我们得到最小的h 一个人 P0 之后,是可以直接定位他重排之后的位置的. 假设从0计数，那么最矮的人的位置和k的关系就是\n* P0 处在位置k.\n* 当然,如果存在多个身高最小的人,那么他们的k大小必然是连续的. 依次根据k值从小到大排列即可\n*\n* 一个人的位置定下之后,我们就可以继续找身高第二小的人. 注意这时候也可能会有身高一样的情况发生.\n* 假设身高第二小的人 P1 (h1,k1) . 他重排之后的位置为index. 重排之后在他前面的身高比他小的人数为pre .\n* 那么不难得出如下等式\n*      index = k1 + pre\n* 这样一来程序就不难写了\n```\n\n如上是第一次写的想法. 其实是被hint带进去了。我想着从最矮的人入手，但是在当最矮的人入队列之后，第二个参数 `k` 的条件将会被打破. \n\n- 注意：这时我的初始排序策略为 : `优先判定身高进行升序排列，身高相同者第二个参数升序排列`\n\n### 题解\n\n#### 最矮方案不行那就重新审视题目\n\nhint里面提到了 ： 如果找到了最矮的人，那么可以马上确定他的位置. 这句话其实有另一层含义 ——如果一个人最后被插入队列，那么只有当其身高是最矮的时候，那么肯定可以确定他需要插入到 `k` 这个位置上. 那么我们转变排序策略, 进行 `优先判定身高进行降序排列, 身高相同者第二个参数升序排列`，以此来保证其排序完成后，可以根据该排序的先后顺序，依次进行插入.\n\n#### 题解代码\n\n```Cpp\nvector<vector<int>> Solution::reconstructQueue(vector<vector<int>> &people) {\n    sort(people.begin(),people.end(),[](const vector<int>& a, const vector<int>& b)\n    { return a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]); });\n\n    vector<vector<int>> ans;\n    for(auto v : people)\n        ans.insert(ans.begin()+v[1], v);\n    return ans;\n}\n```\n\n","tags":["Queue"],"categories":["算法"]},{"title":"Kubernets 进行集群部署","url":"/Caribou.github.io/2019/09/12/Kebernets 进行集群部署/","content":"\n## Kubernets 进行集群部署\n\n### 关键定义\n\n- ##### Pod\n\n运行在Node节点上的若干个容器集合，是一个在容器基础上的更高的抽象。主要由 `master` 节点进行调度，将生成实例化的 Pod 调度到某一个 Node 上进行绑定；\n\n当某一个 Node 宕机，可以进行重新调度，将 Pod 调度到其他的 Node 节点上.\n- #####  Replication Controller\n\n我们一般不会手动自己创建Pod，这样很难管理。利用Replication Controller，可以定义Pod运行内容，副本的个数等信息，它的升级版本是 ReplicaSet。现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。\n\n- ##### Service\n\n可以把一组Pod组成服务 Service，Service有一个虚拟的ClusterIP，服务访问可以通过ClusterIP作为统一请求入口，因为一个 Service 对应一组Pod，所以可以做到负载均衡。服务可以通过 NodePort，LoadBalancer的方式暴露对外服务。注意 type = LoadBalancer需要云服务平台提供基础的服务，自建的K8S集群默认是没有这个东西的。如果在阿里云上定义服务 type = LoadBalancer 后，你会发现，在管理后台的负载均衡页面，会增加一个负载均衡器\n\n\n\n从以上的定义中看出, 一个Node可以认为是一台主机, 而Service作为一个服务提供者, 下包含了多个冗余Node. 能够在某一个Node宕机时及时进行其他备用节点的替补. \n\n我们需要把docker镜像push到远端的某一个镜像管理平台，而后通过配置文件的形式来定义Pod和Service的内容,实现分布式部署.\n\n### K8s YAML配置文件\n\n```\n# yaml格式的pod定义文件完整内容：\napiVersion: v1       #必选，版本号，例如v1\nkind: Pod       #必选，Pod\nmetadata:       #必选，元数据\n  name: string       #必选，Pod名称\n  namespace: string    #必选，Pod所属的命名空间\n  labels:      #自定义标签\n    - name: string     #自定义标签名字\n  annotations:       #自定义注释列表\n    - name: string\nspec:         #必选，Pod中容器的详细定义\n  containers:      #必选，Pod中容器列表\n  - name: string     #必选，容器名称\n    image: string    #必选，容器的镜像名称\n    imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像\n    command: [string]    #容器的启动命令列表，如不指定，使用打包时使用的启动命令\n    args: [string]     #容器的启动命令参数列表\n    workingDir: string     #容器的工作目录\n    volumeMounts:    #挂载到容器内部的存储卷配置\n    - name: string     #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名\n      mountPath: string    #存储卷在容器内mount的绝对路径，应少于512字符\n      readOnly: boolean    #是否为只读模式\n    ports:       #需要暴露的端口库号列表\n    - name: string     #端口号名称\n      containerPort: int   #容器需要监听的端口号\n      hostPort: int    #容器所在主机需要监听的端口号，默认与Container相同\n      protocol: string     #端口协议，支持TCP和UDP，默认TCP\n    env:       #容器运行前需设置的环境变量列表\n    - name: string     #环境变量名称\n      value: string    #环境变量的值\n    resources:       #资源限制和请求的设置\n      limits:      #资源限制的设置\n        cpu: string    #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数\n        memory: string     #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数\n      requests:      #资源请求的设置\n        cpu: string    #Cpu请求，容器启动的初始可用数量\n        memory: string     #内存清楚，容器启动的初始可用数量\n    livenessProbe:     #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可\n      exec:      #对Pod容器内检查方式设置为exec方式\n        command: [string]  #exec方式需要制定的命令或脚本\n      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port\n        path: string\n        port: number\n        host: string\n        scheme: string\n        HttpHeaders:\n        - name: string\n          value: string\n      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式\n         port: number\n       initialDelaySeconds: 0  #容器启动完成后首次探测的时间，单位为秒\n       timeoutSeconds: 0   #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒\n       periodSeconds: 0    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次\n       successThreshold: 0\n       failureThreshold: 0\n       securityContext:\n         privileged:false\n    restartPolicy: [Always | Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod\n    nodeSelector: obeject  #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定\n    imagePullSecrets:    #Pull镜像时使用的secret名称，以key：secretkey格式指定\n    - name: string\n    hostNetwork:false      #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络\n    volumes:       #在该pod上定义共享存储卷列表\n    - name: string     #共享存储卷名称 （volumes类型有很多种）\n      emptyDir: {}     #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值\n      hostPath: string     #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录\n        path: string     #Pod所在宿主机的目录，将被用于同期中mount的目录\n      secret:      #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部\n        scretname: string  \n        items:     \n        - key: string\n          path: string\n      configMap:     #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部\n        name: string\n        items:\n        - key: string\n\n```\n\n### 端口和IP\n\n和docker的内网环境类似，k8s也具有集群内部网络和外部网络.\n\n#### 1. nodePort\n\n外部流量访问k8s集群中service入口的一种方式（另一种方式是LoadBalancer），即nodeIP:nodePort是提供给外部流量访问k8s集群中service的入口。\n\n比如外部用户要访问k8s集群中的一个Web应用，那么我们可以配置对应service的**type=NodePort**，nodePort=30001。其他用户就可以通过浏览器http://node:30001访问到该web服务。\n\n而数据库等服务可能不需要被外界访问，只需被内部服务访问即可，那么我们就不必设置service的NodePort。\n\n\n\n#### 2. port\nk8s集群内部服务之间访问**service**的入口。即**clusterIP:port**是service暴露在clusterIP上的端口。\n\n- mysql容器暴露了3306端口（参考DockerFile），集群内其他容器通过33306端口访问mysql服务，但是**外部流量不能访问mysql服务**，因为mysql服务没有配置NodePort。对应的service.yaml如下：\n\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n name: mysql-service\nspec:\n ports:\n - port: 33306\n   targetPort: 3306\n selector:\n  name: mysql-pod\n```\n\n\n\n#### 3. targetPort\n\n容器的端口（最终的流量端口）。targetPort是pod上的端口，从port和nodePort上来的流量，经过kube-proxy流入到后端pod的targetPort上，最后进入容器。\n\n与**制作容器时暴露的端口一致**（使用DockerFile中的**EXPOSE**），例如官方的nginx（参考DockerFile）暴露80端口。 对应的service.yaml如下：\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n name: nginx-service\nspec:\n type: NodePort         // 有配置NodePort，外部流量可访问k8s中的服务\n ports:\n - port: 30080          // 服务访问端口\n   targetPort: 80       // 容器端口\n   nodePort: 30001      // NodePort\n selector:\n  name: nginx-pod\n```\n\n总的来说\n\n- port和nodePort都是service的端口，前者暴露给k8s集群内部服务访问，后者暴露给k8s集群外部流量访问。\n- 从上两个端口过来的数据都需要经过反向代理kube-proxy，流入后端pod的targetPort上，最后到达pod内的容器。","tags":["K8S"],"categories":["服务"]},{"title":"leetcode-101 Symmetrc Tree 对称树的判定","url":"/Caribou.github.io/2019/09/01/leetcode-101-Symmetrc-Tree/","content":"\n## Leet code 101 对称树判定\n\n树的数据格式如下\n\n```c++\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n```\n\n我们需要判定一棵树是否按照根节点镜像对称，属于比较简答的树的递归问题\n\n一颗对称树可以如下：\n\n```\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```\n\n#### 递归版本\n\n首先想到的就是，可以顺着左右子树分别向下递归。相同深度时，比较的两棵子树的根节点相同，并且可以从 `左子树的左儿子` 和 `右子树的右儿子` 是否相同，并且 `左子树的右儿子` 和 `左子树的左儿子`是否相同入手。\n\n代码如下\n\n```c++\nclass Solution {\npublic:\n    //check if the tree is symmetric\n    bool isSymmetric(TreeNode *root) {\n        if (root == nullptr) {\n            return true;\n        }\n        return isSymmetric(root->left, root->right);\n    }\n\nprivate:\n    bool isSymmetric(TreeNode *left, TreeNode *right) {\n        if (!left && !right)\n            return true;\n        else if (!left || !right)\n            return false;\n        return left->val == right->val &&\n               isSymmetric(left->left, right->right) &&\n               isSymmetric(left->right, right->left);\n    }\n};\n```\n\n","tags":["Tree"],"categories":["算法"]},{"title":"leetcode-148 Sort Linked List 基于链表排序","url":"/Caribou.github.io/2019/09/01/leetcode-148-sort-list/","content":"\n## 148 链表排序\n\n给定一个链表，将其进行排序。主要考察了基本的排序内容\n\n给定数据结构 ListNode\n\n```c++\nstruct ListNode {\n    int val;\n    ListNode *next;\n\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n```\n\n#### 基于链表的归并排序\n\n链表本身无法直接获取索引的特点，归并排序首先需要得到中间节点，并且能够从中间节点开始分隔。\n\n之后的排序方式和基于数组的归并排序类似，难度不大。\n\n```c++\n  //归并排序主函数\n    ListNode *mergeSortList(ListNode *head) {\n        if (head == nullptr || head->next == nullptr)\n            return head;\n        else {\n            ListNode *fast = head, *slow = head;\n            while (fast->next != nullptr && fast->next->next != nullptr) {\n                fast = fast->next->next;\n                slow = slow->next;\n            }\n            ListNode *preHead = head;\n            ListNode *postHead = slow->next;\n            //截断\n            slow->next = nullptr;\n            preHead = mergeSortList(preHead);\n            postHead = mergeSortList(postHead);\n            return merge(preHead, postHead);\n        }\n    }\n\n    //归并操作\n    ListNode *merge(ListNode *pre, ListNode *post) {\n        if (pre == nullptr)\n            return post;\n        if (post == nullptr)\n            return pre;\n        ListNode *result, *p;\n        //let pre to be the head\n        if (pre->val < post->val) {\n            result = pre;\n            pre = pre->next;\n        } else {\n            result = post;\n            post = post->next;\n        }\n        p = result;\n        while (pre != nullptr && post != nullptr) {\n            if(pre->val < post->val){\n                p->next = pre;\n                pre=pre->next;\n            } else{\n                p->next = post;\n                post = post->next;\n            }\n            p=p->next;\n        }\n        if(pre == nullptr){\n            p->next = post;\n        } else {\n            p->next = pre;\n        }\n\n        return result;\n    }\n```\n\n","tags":["List"],"categories":["算法"]},{"title":"Hexo 向技术低头","url":"/Caribou.github.io/2019/09/01/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["Welcome"],"categories":["笔记"]}]