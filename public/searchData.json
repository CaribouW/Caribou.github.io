[{"title":"背包问题","url":"/2020/01/15/背包问题/","content":"\n### 1. 01背包问题\n\n有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。\n\n分析：\n\n- 每一个背包只有 **拿出 or 不拿出** 两种情况\n- 对于 **dp** 数组，我们某一个状态 `dp[i][j]` 表示 **前i种背包的情况下，他们的总重量是 j 的最优解**\n  - 如果 **i** 背包不拿，那么 `dp[i][j] = dp[i - 1][j]`\n  - 如果 **i** 背包拿取，那么 `dp[i][j] = dp[i - 1][j - weights[i]] + values[i]`\n    - 也就是说，拿取之后，需要看剩下的部分最优解\n\n#### 算法优化\n\n根据之前的状态转移方程，我们可以约减一维的 **dp** 空间\n\n改进之后的 **dp** 状态转移方程如下：\n\n`dp[i] = max(dp[j], dp[j - weights[i]] + values[i])`\n\n> 为什么在内层循环，**j** 需要逆序？\n>\n> 在没有开始计算的时候，**dp[i]表示的是dp\\[i-1]\\[j]** 。而当我们需要计算 `dp[i] = max(dp[j], dp[j - weights[i]] + values[i])`的时候，需要保证 `dp[j - w[i]]` 是 **没有被改变的**。因此需要**从后往前**\n\n### 2. 完全背包问题\n\n每一件物品可以 **无限次** 拿取\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int N , V;\n    cin >> N >> V;\n    vector<int> w(N + 1) , v(N + 1);\n    for(int i = 1 ; i <= N ; ++i) cin >> w[i] >> v[i];\n    \n    vector<vector<int>> dp(N + 1 , vector<int>(V + 1 , 0));\n    \n    for(int i = 1; i <= N ; ++i){\n        for(int j = 0 ;j <= V; ++j){\n            dp[i][j] = dp[i - 1][j];\n            for(int k = 0 ; k*w[i] <= j; ++k){\n                dp[i][j] = max(dp[i][j] , dp[i][j - k * w[i]] + k * v[i]);\n            }\n        }\n    }\n    \n    cout << dp[N][V] << endl;\n    \n}\n```\n\n最重要的状态转移方程对比\n\n- **01背包** ：`dp[i][j] = max(dp[i-1][j],dp[i - 1][j - w[i]] + v[i])`\n- **完全背包** ：`dp[i][j] = max(dp[i][j] , dp[i - 1][j - k * w[i]] + k * v[i]);`\n\n不难看出，两者其实非常的类似。根据下标我们可以给出压缩之后的优化版本完全背包解法\n\n> **01背包** 和 **完全背包** 的不同\n>\n> ```cpp\n> //01背包\n> for i  in 0 ... N\n>     for  j = V ... 0\n>         f[j] = max{f[j], f[j - weight[i]] + value[i]}\n> //完全背包\n> for i int 0 ... N\n>   \tfor\t j = 0 ... V\n>       \tf[j] = max{f[j] , f[j - weight[j]] + value[i]}\n> ```\n>\n> 可以看出，只有内层循环的执行顺序不同\n\n给出 **完全背包问题** 的优化方案\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n    int n , capacity;\n    cin >> n >> capacity;\n    vector<int> c(n + 1) , w(n + 1);\n    vector<int> dp(max(n , capacity));\n    for(int i = 1 ; i <= n ;++i) cin >> c[i] >> w[i];\n    \n    for(int i = 1; i <= n ;++i)\n        for(int j = c[i] ; j <= capacity ; ++j)\n            dp[j] = max(dp[j] , dp[j - c[i]] + w[i]);\n    \n    cout << dp[capacity];\n}\n```\n\n","tags":["算法"]},{"title":"c++新特性","url":"/2020/01/15/c-新特性/","content":"\n## What’s new in C++ 11?\n\n###  storage duration specifier\n\n多个C++版本都对变量存储时间的定义有严格的说明\n\n- `auto` - *automatic* storage duration.\n\n- `register` - *automatic* storage duration. Also hints to the compiler to place the object in the processor's register. (deprecated) ——*since C++ 17*\n\n- `static` - *static* or *thread* storage duration and *internal* linkage\n\n- `extern` - *static* or *thread* storage duration and *external* linkage.\n\n- `thread_local` - *thread* storage duration\n\n  The `thread_local` keyword is only allowed for objects declared at namespace scope, objects declared at block scope, and static data members. It indicates that the object has **thread storage duration**. It can be combined with `static` or `extern` to specify internal or external linkage (except for static data members which always have external linkage), respectively, but that additional `static` doesn't affect the storage duration.\n\n- `mutable` - does not affect storage duration or linkage\n\n  注意：`mutable` 主要是标识 **const对象** 中某些可变的成员，实现了从二进制的物理 **const** 到逻辑 **const** (外观不变)\n\n### Variadic templates\n\n可变类模板，在 `c++ reference` 里面以 *parameter pack* 来代替\n\n```cpp\ntemplate<class... Types>\t\t\t//class ... Types 是一个 pack 的声明\t\nvoid f(Types... args) {}\t\t\t//Types... args 是\n```\n\n#### Pack Expansion\n\n- `&args...` 代表的是参数扩展\n- `&args`代表的是 *pack pattern* 本身\n\n### Move semantics\n\n> **凡是取地址（`&`）操作可以成功的都是左值，其余都是右值**\n>\n> - 等号左边的不一定是左值——可以通过操作符重载来让左部变成 **右值**\n\n#### 右值引用\n\n我们之前常见的都是 **左值引用**，指的是我们只能够将 **左值** 赋给一个引用。\n\n-  `int& a = 1` 就是非法的。而我们也可以 `int const& i = 42;` 来进行一个 *tricky* 的躲避\n\n  在 `c++11`中允许了右值引用的出现\n```\nint&& a = 3;\n```\n\n#### 移动语义\n\n我们在进行 `Test(const Test& test)` 拷贝构造函数的执行过程中，会造成很多的拷贝浪费。当单独的一次拷贝构造函数 (特别是对指针数组这些资源)过程消耗特别大的时候，对于性能来说是很低的。\n\n那么 `c++11`标准给出了 **移动拷贝构造函数** 和 **移动赋值操作符重载**。此外，还支持 `std::move()`来强制性让 **左值转化为右值**\n\n#### 完美转发\n\n我们想要实现\n\n> 多级函数调用过程中\n>\n> - 如果变量是左值，那么它作为其他函数的参数的时候也应该是 **左值**\n> - 如果变量是右值，那么它作为其他函数的参数的时候也应该是 **右值**\n\n```cpp\ntemplate <typename T>\nvoid func(T t) {\n    cout << \"in func\" << endl;\n}\n\ntemplate <typename T>\nvoid relay(T&& t) {\n    cout << \"in relay\" << endl;\n    func(t);\n}\n\nint main() {\n    relay(Test());\n}\n```\n\n上面这个例子就是一个 **反例**。我们在传入 `func(t)` 的时候，其实调用了 **拷贝构造函数** (因为编译器把 **t** 当做了一个 **左值**)\n\n> `std::forward<T>()` ，能够保留参数的左右值类型\n\n### Value Category\n\n不止左值右值那么简单\n\n> Cpp reference:\n>\n> Each C++ [expression](https://en.cppreference.com/w/cpp/language/expressions) (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a *type* and a *value category*. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: *prvalue*, *xvalue*, and *lvalue*.\n\n\n\n","tags":["整理"]},{"title":"杂谈-沉思帖","url":"/2019/12/22/杂谈-鸡血帖/","content":"\n> 多尝试新的方向，不浮躁地随波逐流；\n>\n> 有一个自己喜爱的方向是如此地难能可贵\n\n## 杂谈-沉思帖\n\n2019 秋季这个课表算是无法无天了，虽然在春季就做了一些心理预设，但是当它到来的时候，特别是到了现在考试周将近，还是压得人喘不过气。\n\n前一段时间一直在各处投递简历。在打消了出国打算、ML的打算之后，我从暑期就开始对自己的方向进行了思考，留给我试错的时间已经不多了，在后续的一年半时间中，我是需要针对一桩事业真正投入地进行付出，并且能够有一定的产出的。在我各处找着实习的时候，字节一面后十分钟的拒信给了我巨大的打击——\n\n> 基础不牢，地动山摇\n\n面试官丢给我的几乎每一个计网问题我都招架不来，可以说上个学期学的内容全数奉还给了老师。内心千万个声音在警戒着我：你的基础根本不牢固，做了种种项目又有什么用？\n\n图森的面试官告诉我，如果这些基本的网络知识不过关，如何能够在出错的时候进行精准的错误排查？特别是在客户流量比较大的情况下，网络阻塞、丢包这些错误屡见不鲜，如何可以最大限度地减少经济损失？\n\n> 网络协议中每一层的网络攻击可以有哪些？\n\n这个问题我可能一辈子也不忘了，图森的二面官这么一个问题丢过来，我当时的反应就是：一个也没有。\n\n后续的结果也显而易见，又是一封拒信。虽然 `coding` 过关，但是基础过于不扎实而不会要我。\n\n所以，基础 基础 基础！！！\n\n什么叫做基础呢？\n\n其实这些问题，老师课上也没有系统性的说过。我丢失了大一的时候看书的习惯，大二只是对课堂内的东西进行机械接受。最讽刺的就是，当字节面试官问“你觉得计网是一门怎么样的课”的时候，我第一反应回答就是“一门背书的课”。我现在回顾过来，真想好好打当时的自己一个巴掌。不过事实的确如此，我在大二下就是背书来学计网的，当时的我根本没有心思听老师讲课，只想着多做一些项目美滋滋。\n\n现在就到了要亡羊补牢的时候了，11月上旬的样子吧，我开始恶补我之前的 `JVM`, 计网，多线程，`linux` 内核相关的知识。加上后续几个面试的逼迫，我可以说拼了老命在学 (这么紧的课程还要面试，真的会折磨我自己)\n\n`12.21` ，*TX* 的面试官突然打来电话，约了一面。可以说这次是我把握比较好的一次面试了。说着，人的确就是一个犯贱的种，需要一些外力压迫来威胁自己去学习。还有一个很重要的点就是，我真的过于浮躁了，急于求成想去学 *ML* 但是发现真实资源如此贫乏(一整个院搞什么ML? 我们又不是人工智能学院！) 没有一个前辈带领的路走得真心艰苦，没有方向，没有可以去追随的人，于是放弃。现在是时候好好静下心去听听自己了。\n\n> 冬至已至。\n>\n> 希望新的一年，能够笃定，坚毅。","tags":["UpUp"],"categories":["杂谈"]},{"title":"TCP/IP 阅读笔记(1)","url":"/2019/12/14/TCP-IP-阅读笔记-1/","content":"\n### TCP连接形式\n\nTCP连接使用了一对套接字 (`socket`) 来进行唯一表示，也就是把 `IP` 头部的源和目的IP地址，携同TCP头部的源端口号和目的端口号，来进行一个标识。\n\n### Seq 与 Ack\n\n序列号与响应号是通信双方进行确认判定的依据。每一次报文中的响应号就是上一次报文的序列号  + 1 ，表示了接收方想要接收的下一个序列号。\n\n我们所熟知的三次握手，其实本质上就是发送方和接收方的序列号交换：\n\n> 第一次报文发送：SYN表明是客户端期望进行序列号同步，并且发送自己的序列号\n>\n> 第二次报文发送：SYN表示是服务端期望进行序列号同步，返回之前客户端的序列号 + 1 , 表示此时客户端序列号已经同步。此时还需要发送服务端自己的序列号，等待客户端是否给予最后一次响应。\n>\n> 第三次报文发送：ACK确实就是服务端序列号 + 1 的话，那么表明服务端的序列号也已经同步。至此通过三次报文交换来实现全双工通信的两端序列号同步。\n\n对于四次挥手，其实也是序列号的交换问题。\n\n书上的问题给出了进一步的思考：如果出现同时建立连接和同时断开连接，报文发送个数是多少？\n\n- 对于同时建立连接的情况，一开始同时就会有两次报文发送，这时候两个报文都是 SYN，期望同步自己的序列号。此时连接两端的两个 `socket` 其实都只需要得到自己想要的 `ACK` 就可以了。这时候就是四次报文交换\n- 对于同时断开连接的情况，和上面完全一样，也是四次\n\n### TIME_WAIT问题\n\n四次挥手结束之后，连接断开的发起者还会继续等待 `2MSL` 的时间长度，这种做法能够避免最后一次 **ACK** 因为网络问题没有发送到，给 **被动断开方** 时间进行超时重传。\n\n在发起者还在等待的时候，其实两端的端口还是在连接的状态。问题就来了——端口占用问题。\n\n也就是说，如果我们这时候在服务端或者客户端，断开 `socket` 却又立即重启，这时候就会出现端口占用的情况，导致我们的连接被拒绝。\n\n","tags":["读书笔记"]},{"title":"设计模式-单例","url":"/2019/12/07/设计模式-单例/","content":"\n## 单例模式\n\n给出最原始的代码\n\n```java\npublic class Singleton {\n\n    //一个静态的实例\n    private static Singleton singleton;\n    //私有化构造函数\n    private Singleton(){}\n    //给出一个公共的静态方法返回一个单一实例\n    public static Singleton getInstance(){\n        if (singleton == null) {\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n```\n\n现在我们就需要考虑==多线程环境==下的单例模式实现了\n\n**懒汉模式**\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton(){}\n    public static Singleton getInstance(){\n        if (instance == null) {\n            //Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n**饿汉模式**\n\n```java\npublic class Singleton {\n    private static Singleton instance = new Singleton();\n    private Singleton(){}\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n> 多线程下的懒汉模式会出现问题——在判定是 *null* 的时候，还没来得及进行创建实例，另一个进程就进入进行判定\n\n#### 解决办法1\n\n方法上添加 **synchronized** 关键字\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton(){}\n    public static synchronized Singleton getInstance(){\n        if (instance == null) {\n            //Thread.sleep(1000)   这里延时，懒汉式多线程下的错误就会突显。\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n> 问题：如果两个线程都要获取单例引用，只能等一个线程获取后，另一个线程才能获取。\n\n#### 解决方法2\n\n双检查锁机制（Double Check Locking）,也叫”DCL“\n\n> 双锁的意思，是指 检测两次instance是否为空。\n\n```java\npublic class Singleton {  \n      \n    //使用volatile关键字保其可见性  \n    volatile private static Singleton instance = null;  \n      \n    private MySingleton(){}  \n       \n    public static MySingleton getInstance() {   \n            if(instance == null){//懒汉式   \n                  synchronized (Singleton.class) {  \n                    if(instance == null){//二次检查  \n                        instance = new MySingleton();  \n                    }  \n                } \n            }\n        return instance;  \n    }  \n}  \n```\n\n#### 解决办法3\n\n当然，我们最好还是采取**饿汉式**\n\n```java\npublic class Singleton{\n    //类加载时就初始化\n    private static final Singleton instance = new Singleton();\n    \n    private Singleton(){}\n\n    public static Singleton getInstance(){\n        return instance;\n    }\n}\n```\n\n#### 解决办法4\n\n采取 **静态内部类**\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton (){}  \n    \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE; \n    }  \n}\n```\n\n#### 解决办法5\n\n枚举 Enum\n\n```java\npublic enum EasySingleton{\n    INSTANCE;\n}\n```\n\n","tags":["设计模式"]},{"title":"数据库-索引","url":"/2019/12/05/数据库整理-索引/","content":"\n## 索引\n\n#### 页存储\n\n<img src=\"https://i.loli.net/2019/12/05/dQE6NVkHZJcWfye.png\" style=\"zoom:50%;\" />\n\n如上就是数据库在Disk Storage的一个存储方式。一个页包含若干 *Data Rows* , 通过 *Row directory* 来进行索引\n\n> A row in a table can be uniquely specified with the page number (P) and slot number (S).\n\n##### 位图索引\n\nhttps://www.cnblogs.com/LBSer/p/3322630.html\n\n位图索引中只维护distinct值，也就是说重复的值是不维护在树中\n\n对于每一个列建立一个\n\n- 位图索引适合只有几个固定值的列，如性别、婚姻状况、行政区等等，而身份证号这种类型不适合用位图索引。\n\n- 此外，位图索引适合静态数据，而不适合索引频繁更新的列\n\n##### 散列索引\n\n散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。\n\n散列索引根据对应键的散列码来找到最终的索引项的技术，其实和B树就差不多，也就是一种索引之上的二级辅助索引，我理解散列索引都是二级或更高级的稀疏索引，否则桶就太多了，效率也不会很高\n\n##### 聚簇索引\n\n所谓聚簇索引，就是指**主索引文件**和**数据文件**为==同一份文件==，聚簇索引主要用在**Innodb**存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引，如下图所示：\n\n在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。\n\n##### 非聚簇索引\n\n聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接**指向对应数据块**。\n\n##### 辅助索引\n\n在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要**二次查找**。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据叶，再通过数据叶中的Page Directory找到数据行\n\n##### 唯一索引\n\n表明此索引的==每一个索引值只对应唯一的数据记录==，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复\n\n##### 主键索引\n\n在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问\n\n---\n\n数据库引擎 ：myISAM , innodb\n\nmyisam索引：因为myisam的索引和数据是分开存储存储的，myisam通过**key_buffer**把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因  \n\ninnodb索引：innodb的数据和索引放在一起，当找到索引也就找到了数据\n\n<img src=\"https://img-blog.csdn.net/20161102111454921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\" style=\"zoom:75%;\" />\n\n1.对于**非聚簇索引表**来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。\n\n2.对于**聚簇索引表**来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)\n\n> ##### 聚簇索引的优点\n>\n> 1.当你需要取出==一定范围内==的数据时，用聚簇索引也比用非聚簇索引好。\n>\n> 2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。\n>\n> 3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。\n>\n> ##### 聚簇索引的缺点\n>\n> 1.**插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。\n>\n> 2.**更新主键的代价很高，因为将会导致被更新的行移动**。因此，对于InnoDB表，我们一般定义主键为不可更新。\n>\n> 3.**二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。**\n>\n> 二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。\n>\n> 4.**采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多**，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。\n\n\n\n","tags":["笔记"],"categories":["笔记"]},{"title":"LC周赛 2019-10-05","url":"/2019/10/08/leetcode-周赛20191005/","content":"\n## 1. Play with Chips\n\n### 描述\n\nThere are some chips, and the i-th chip is at position `chips[i]`.\n\nYou can perform any of the two following types of moves **any number of times** (possibly zero) **on any chip**:\n\n- Move the `i`-th chip by 2 units to the left or to the right with a cost of **0**.\n- Move the `i`-th chip by 1 unit to the left or to the right with a cost of **1**.\n\nThere can be two or more chips at the same position initially.\n\nReturn the minimum cost needed to move all the chips to the same position (any position).\n\n### 思路 \n\n如果两个chip的位置相差为偶数, 则 `cost = 0`. 否则 `coust = 1 `\n\n我们预先获取chip的一个哈希来进行缓存, 之后遍历哈希中的每一个数, 作为 **目的地**.\n\n那么我们的问题就变成 ： 找出那一个 **目的地** , 使得 `cost` 最小即可\n\n```java\n    public int minCostToMoveChips(int[] chips) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : chips) {\n            set.add(num);\n        }\n        int min = Integer.MAX_VALUE;\n        for (int num : set) {\n            int sum = 0;\n            for (int chip : chips) {\n                int dis = Math.abs(num - chip);\n                sum += dis % 2;\n                if (sum > min) break;\n            }\n            min = Math.min(sum, min);\n        }\n        return min;\n    }\n```\n\n## 2. Longest Arithmetic Subsequence of Given Difference\n\n### 描述\n\nGiven an integer array `arr` and an integer `difference`, return the length of the longest subsequence in `arr` which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals `difference`.\n\n**Example 1:**\n\n```\nInput: arr = [1,2,3,4], difference = 1\nOutput: 4\nExplanation: The longest arithmetic subsequence is [1,2,3,4].\n```\n\n**Example 2:**\n\n```\nInput: arr = [1,3,5,7], difference = 1\nOutput: 1\nExplanation: The longest arithmetic subsequence is any single element.\n```\n\n**Example 3:**\n\n```\nInput: arr = [1,5,7,8,5,3,4,2,1], difference = -2\nOutput: 4\nExplanation: The longest arithmetic subsequence is [7,5,3,1].\n```\n\n### 思路\n\n一开始很明显想到用 `DP` 来解决. 每一步前进的同时需要缓存下当前位置, 便于后续的查找\n\n我们缓存如下的内容：\n\n- 每一个数字和它所处可能位置 `Set` 的哈希映射\n- DP 数组，用于当前 `dp[i]` 的确定\n\n一开始就这样做了，但是 error 了一次. 原因就是这里的 dp 数组并不是单调上升，因为可能会出现中间断层的情况，例如 `[1,2,3,1,2,3,4]` , 中间的 `1` 位置就是断层的出现点. (之后一想，其实也可以通过自己的维护来进行避免，问题不大)\n\n最终代码如下\n\n```java\n public int longestSubsequence(int[] arr, int difference) {\n        int n = arr.length;\n        int[] dp = new int[n];\n        Map<Integer, Set<Integer>> map = new HashMap<>();\n        dp[0] = 1;\n        Set<Integer> set = new HashSet<>();\n        set.add(0);\n        map.put(arr[0], set);\n        for (int i = 1; i < n; ++i) {\n            if (!map.containsKey(arr[i])) {\n                set = new HashSet<>();\n                set.add(i);\n                map.put(arr[i], set);\n            } else {\n                set = map.get(arr[i]);\n                set.add(i);\n                map.put(arr[i], set);\n            }\n\n            int target = arr[i] - difference;\n            if (!map.containsKey(target)) { //不包含前一个数\n                dp[i] = 1;\n            } else {\n                set = map.get(target);\n                int maxLen = 0;\n                for (int num : set) {\n                    maxLen = Math.max(maxLen, dp[num]);\n                }\n                dp[i] = maxLen + 1;\n            }\n        }\n        int ans = 0;\n        for (int num : dp) {\n            ans = Math.max(num, ans);\n        }\n        return ans;\n    }\n```\n\n## 3. Path with Maximum Gold\n\n### 描述\n\nIn a gold mine `grid` of size `m * n`, each cell in this mine has an integer representing the amount of gold in that cell, `0` if it is empty.\n\nReturn the maximum amount of gold you can collect under the conditions:\n\n- Every time you are located in a cell you will collect all the gold in that cell.\n- From your position you can walk one step to the left, right, up or down.\n- You can't visit the same cell more than once.\n- Never visit a cell with `0` gold.\n- You can start and stop collecting gold from **any** position in the grid that has some gold. \n\n**Example 1:**\n\n```\nInput: grid = [[0,6,0],[5,8,7],[0,9,0]]\nOutput: 24\nExplanation:\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\nPath to get the maximum gold, 9 -> 8 -> 7.\n```\n\n**Example 2:**\n\n```\nInput: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\nOutput: 28\nExplanation:\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\nPath to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n```\n\n### 思路\n\n很简单的 DFS 算法实现, 没什么好说的\n\n```java\npublic int getMaximumGold(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int max = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] != 0) {\n                    max = Math.max(max, dfs(grid, new int[]{i, j}, 0));\n                }\n            }\n        }\n        return max;\n    }\n\n    private int dfs(int[][] grid, int[] startPos, int gold) {\n        int m = grid.length, n = grid[0].length;\n        int r = startPos[0], c = startPos[1];\n        if (r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == 0) return gold;\n        gold += grid[r][c];\n        int[][] nums = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                nums[i][j] = grid[i][j];\n            }\n        }\n        nums[r][c] = 0;             //Get the gold\n        int a1 = dfs(nums, new int[]{r, c + 1}, gold);\n        int b1 = dfs(nums, new int[]{r, c - 1}, gold);\n        int c1 = dfs(nums, new int[]{r + 1, c}, gold);\n        int d1 = dfs(nums, new int[]{r - 1, c}, gold);\n        return Arrays.stream(new int[]{a1, b1, c1, d1}).max().getAsInt();\n    }\n```\n\n## 4. Count Vowels Permutation\n\n### 描述\n\nGiven an integer `n`, your task is to count how many strings of length `n` can be formed under the following rules:\n\n- Each character is a lower case vowel (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`)\n- Each vowel `'a'` may only be followed by an `'e'`.\n- Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.\n- Each vowel `'i'` **may not** be followed by another `'i'`.\n- Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.\n- Each vowel `'u'` may only be followed by an `'a'.`\n\nSince the answer may be too large, return it modulo `10^9 + 7.`\n\n**Example 1:**\n\n```\nInput: n = 1\nOutput: 5\nExplanation: All possible strings are: \"a\", \"e\", \"i\" , \"o\" and \"u\".\n```\n\n**Example 2:**\n\n```\nInput: n = 2\nOutput: 10\nExplanation: All possible strings are: \"ae\", \"ea\", \"ei\", \"ia\", \"ie\", \"io\", \"iu\", \"oi\", \"ou\" and \"ua\".\n```\n\n**Example 3:** \n\n```\nInput: n = 5\nOutput: 68\n```\n\n### 思路\n\n假定某一步的最末位中, ‘a’ , ‘e’ , ‘i’ , ‘o’ , ‘u’ 的个数分别是 a , e , i , o , u ，那么下一步末位的个数就分别是 `u+e+i`, `a + i`, `e + o` , `i` , `o +i` \n\n我这里用了一个hash来保存 (小声：这个hard题是简单题的赶脚233)\n\n```java\nclass Solution {\nprivate final long mod = 1_000_000_007;\n    public int countVowelPermutation(int n) {\n        Map<Character, Long> map = new HashMap<>();\n        map.put('a', 1L);\n        map.put('e', 1L);\n        map.put('i', 1L);\n        map.put('o', 1L);\n        map.put('u', 1L);\n        for (int i = 1; i < n; ++i) {\n            Map<Character, Long> tmp = new HashMap<>();\n            tmp.put('a', (map.get('u') + map.get('e') + map.get('i')) % mod);\n            tmp.put('e', (map.get('a') + map.get('i')) % mod);\n            tmp.put('i', (map.get('e') + map.get('o')) % mod);\n            tmp.put('o', (map.get('i')) % mod);\n            tmp.put('u', (map.get('o') + map.get('i')) % mod);\n\n            map = tmp;\n        }\n        return (int) (map.values().stream().reduce(Long::sum).get() % mod);\n    }\n}\n```\n\n## 结语\n\n这次周赛4个题目全部 AC , RANK  740","tags":["competition"],"categories":["算法"]},{"title":"LC周赛 2019-09-15","url":"/2019/09/15/LC周赛-2019-09-15/","content":"\n## 1. 寻找字符串中Balloon个数\n\n给你一个字符串 `text`，你需要使用 `text` 中的字母来拼凑尽可能多的单词 **\"balloon\"（气球）**。\n\n字符串 `text` 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 **\"balloon\"**。\n\n### 思路：\n\n很快可以通过哈希表来建立一个 `字符到字符在text中出现次数`的映射, 然后根据`ballon ` 来进行对照得出最终结果: 一定是 { `b` 出现次数 , `a` 出现次数 , `n` 出现次数 , `l` 出现次数的一半 , `o` 出现次数的一半 } 中的最小值, 即满足\n\n\n\n```java\npublic int maxNumberOfBalloons(String text) {\n        Map<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < text.length(); ++i) {\n            map.put(text.charAt(i), map.getOrDefault(text.charAt(i), 0) + 1);\n        }\n        int b = map.getOrDefault('b', 0),\n                a = map.getOrDefault('a', 0),\n                l = map.getOrDefault('l', 0) / 2,\n                o = map.getOrDefault('o', 0) / 2,\n                n = map.getOrDefault('n', 0);\n        return Math.min(b, Math.min(a, Math.min(l, Math.min(o, n))));\n    }\n```\n\n##  2. 反转每对括号间的子串\n\n给出一个字符串 `s`（仅含有小写英文字母和括号）。\n\n请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。\n\n注意，您的结果中 **不应** 包含任何括号。\n\n### 思路：\n\n很明显这是一个 **递归** 问题. 举例说明\n\n```\n输入：s = \"(u(love)i)\"\n```\n\n我们需要先找出 **最小匹配括号子串** , 将其翻转之后, 再对其父级的子串进行翻转. \n\n\n\n但是有一个比较坑的点, 测试用例里面有这样的 `a()b(((c)))de` ， 也就是说，可以存在平级的括号. 这一点当时没想到. 从这里我们需要改变想法：\n\n- 当遇到同级的括号，先处理过当前的 `()` 对，然后继续使用 ReverseParentheses 来对后续同级括号进行翻转. 这个属于迭代式的处理\n- 当遇到子级括号, 也就是正常的 `(d(c))`这样的情况，就使用递归函数解决\n\n```java\n    public String reverseParentheses(String s) {\n        int begin = 0;\n        int end;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(')\n                begin = i;\n            if (s.charAt(i) == ')') {\n                end = i;\n                String temp = s.substring(begin + 1, end);//最小 ()\n                return reverseParentheses(s.substring(0, begin) + reverseString(temp) + s.substring(end + 1));\n            }\n        }\n        return s;\n    }\n\n    String reverseString(String s) {\n        char[] temp = s.toCharArray();\n        StringBuilder r = new StringBuilder();\n        for (int i = temp.length - 1; i >= 0; i--)\n            r.append(temp[i]);\n\n        return r.toString();\n    }\n```\n\n## 3. k次串联数组之后的最大子数组之和\n\n给你一个整数数组 `arr` 和一个整数 `k`。\n\n首先，我们要对该数组进行修改，即把原数组 `arr` 重复 `k` 次。\n\n> 举个例子，如果 `arr = [1, 2]` 且 `k = 3`，那么修改后的数组就是 `[1, 2, 1, 2, 1, 2]`。\n\n然后，请你返回修改后的数组中的最大的子数组之和。\n\n注意，子数组长度可以是 `0`，在这种情况下它的总和也是 `0`。\n\n由于 **结果可能会很大**，所以需要 **模（mod）** `10^9 + 7` 后再返回。 \n\n### 思路：\n\n一看，这个不就是最大子数组的翻版吗 hhh , 那么直接贪心上啊 \n\n```java\nprivate static final long MOD = 1000_000_007;\n\nprivate int sumHelper(int[] arr, int k) {\n        int totalLen = arr.length * k;\n        int max = 0;\n        int sum = 0;\n        for (int i = 0; i < totalLen; ++i) {\n            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);\n            if (sum < 0) {\n                sum = 0;\n            } else {\n                max = Math.max(sum, max);\n            }\n        }\n        return max;\n    }\n```\n\n那么问题来了，**TLE** 了. 也就是说，这个算法不容忍 **O(N)** 的时间复杂度. 我们需要找到数组在进行串联的时候的一个和数关系来进行快速获取答案.\n\n#### 分析：\n\n前缀和判断，一共如下可能\n\n- 答案为 0\n\n- 答案仅从当前不串联的数组中得到, 即 k = 1时的最大子数组和\n\n- 答案从 k = 2 的串联结果得到，第一部分的后缀和的最大值加上第二部分的前缀和的最大值。\n\n- 答案从整个串联 k > 2 次后的结果得到，且一定是第一部分的后缀和的最大值，中间部分的总和，加上最后一部分的前缀和的最大值。\n\n第二种可能从**当前前缀和**减去**当前前缀和的最小值**得到。\n\n前缀和的最大值直接可以维护出来，后缀和的最大值可以通过总和减去前缀和的最小值得到。\n\n#### 实现\n\n需要维护数组的 **总和**, **最大前缀和** , **最小前缀和**\n\n```java\n    private static final long MOD = 1000_000_007;\n\n    public int kConcatenationMaxSum(int[] arr, int k) {\n        int n = arr.length;\n        if (k == 1)\n            return sumHelper(arr);\n        long[] sum = new long[n + 1];\n        long[] maxL = new long[n + 1];\n        long[] minL = new long[n + 1];\n        for (int i = 1; i < n + 1; ++i) {\n            sum[i] = sum[i - 1] + arr[i];\n            maxL[i] = Math.max(maxL[i - 1], sum[i]);\n            minL[i] = Math.min(minL[i - 1], sum[i]);\n        }\n        long ans = 0;\n        return (int) (Math.max(ans,\n                Math.max(\n                        sum[n] - minL[n] + maxL[n],\n                        sum[n] - minL[n] + maxL[n] + sum[n] * (k - 2)\n                )\n        ) % MOD);\n    }\n\n    private int sumHelper(int[] arr) {\n        int totalLen = arr.length;\n        int max = 0;\n        int sum = 0;\n        for (int i = 0; i < totalLen; ++i) {\n            sum = Math.toIntExact((sum + arr[i % arr.length]) % MOD);\n            if (sum < 0) {\n                sum = 0;\n            } else {\n                max = Math.max(sum, max);\n            }\n        }\n        return max;\n    }\n```\n\n## 4. 查找集群内的「关键连接」\n\n力扣数据中心有 `n` 台服务器，分别按从 `0` 到 `n-1` 的方式进行了编号。\n\n它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 `connections` 是无向的。\n\n从形式上讲，`connections[i] = [a, b]` 表示服务器 `a` 和 `b` 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。\n\n「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。\n\n请你以任意顺序返回该集群内的所有 「关键连接」。\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png)","tags":["competition"],"categories":["算法"]},{"title":"Kubernets 进行集群部署","url":"/2019/09/12/Kebernets 进行集群部署/","content":"\n## Kubernets 进行集群部署\n\n### 关键定义\n\n- ##### Pod\n\n运行在Node节点上的若干个容器集合，是一个在容器基础上的更高的抽象。主要由 `master` 节点进行调度，将生成实例化的 Pod 调度到某一个 Node 上进行绑定；\n\n当某一个 Node 宕机，可以进行重新调度，将 Pod 调度到其他的 Node 节点上.\n- #####  Replication Controller\n\n我们一般不会手动自己创建Pod，这样很难管理。利用Replication Controller，可以定义Pod运行内容，副本的个数等信息，它的升级版本是 ReplicaSet。现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。\n\n- ##### Service\n\n可以把一组Pod组成服务 Service，Service有一个虚拟的ClusterIP，服务访问可以通过ClusterIP作为统一请求入口，因为一个 Service 对应一组Pod，所以可以做到负载均衡。服务可以通过 NodePort，LoadBalancer的方式暴露对外服务。注意 type = LoadBalancer需要云服务平台提供基础的服务，自建的K8S集群默认是没有这个东西的。如果在阿里云上定义服务 type = LoadBalancer 后，你会发现，在管理后台的负载均衡页面，会增加一个负载均衡器\n\n\n\n从以上的定义中看出, 一个Node可以认为是一台主机, 而Service作为一个服务提供者, 下包含了多个冗余Node. 能够在某一个Node宕机时及时进行其他备用节点的替补. \n\n我们需要把docker镜像push到远端的某一个镜像管理平台，而后通过配置文件的形式来定义Pod和Service的内容,实现分布式部署.\n\n### K8s YAML配置文件\n\n```\n# yaml格式的pod定义文件完整内容：\napiVersion: v1       #必选，版本号，例如v1\nkind: Pod       #必选，Pod\nmetadata:       #必选，元数据\n  name: string       #必选，Pod名称\n  namespace: string    #必选，Pod所属的命名空间\n  labels:      #自定义标签\n    - name: string     #自定义标签名字\n  annotations:       #自定义注释列表\n    - name: string\nspec:         #必选，Pod中容器的详细定义\n  containers:      #必选，Pod中容器列表\n  - name: string     #必选，容器名称\n    image: string    #必选，容器的镜像名称\n    imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像\n    command: [string]    #容器的启动命令列表，如不指定，使用打包时使用的启动命令\n    args: [string]     #容器的启动命令参数列表\n    workingDir: string     #容器的工作目录\n    volumeMounts:    #挂载到容器内部的存储卷配置\n    - name: string     #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名\n      mountPath: string    #存储卷在容器内mount的绝对路径，应少于512字符\n      readOnly: boolean    #是否为只读模式\n    ports:       #需要暴露的端口库号列表\n    - name: string     #端口号名称\n      containerPort: int   #容器需要监听的端口号\n      hostPort: int    #容器所在主机需要监听的端口号，默认与Container相同\n      protocol: string     #端口协议，支持TCP和UDP，默认TCP\n    env:       #容器运行前需设置的环境变量列表\n    - name: string     #环境变量名称\n      value: string    #环境变量的值\n    resources:       #资源限制和请求的设置\n      limits:      #资源限制的设置\n        cpu: string    #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数\n        memory: string     #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数\n      requests:      #资源请求的设置\n        cpu: string    #Cpu请求，容器启动的初始可用数量\n        memory: string     #内存清楚，容器启动的初始可用数量\n    livenessProbe:     #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可\n      exec:      #对Pod容器内检查方式设置为exec方式\n        command: [string]  #exec方式需要制定的命令或脚本\n      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port\n        path: string\n        port: number\n        host: string\n        scheme: string\n        HttpHeaders:\n        - name: string\n          value: string\n      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式\n         port: number\n       initialDelaySeconds: 0  #容器启动完成后首次探测的时间，单位为秒\n       timeoutSeconds: 0   #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒\n       periodSeconds: 0    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次\n       successThreshold: 0\n       failureThreshold: 0\n       securityContext:\n         privileged:false\n    restartPolicy: [Always | Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod\n    nodeSelector: obeject  #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定\n    imagePullSecrets:    #Pull镜像时使用的secret名称，以key：secretkey格式指定\n    - name: string\n    hostNetwork:false      #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络\n    volumes:       #在该pod上定义共享存储卷列表\n    - name: string     #共享存储卷名称 （volumes类型有很多种）\n      emptyDir: {}     #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值\n      hostPath: string     #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录\n        path: string     #Pod所在宿主机的目录，将被用于同期中mount的目录\n      secret:      #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部\n        scretname: string  \n        items:     \n        - key: string\n          path: string\n      configMap:     #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部\n        name: string\n        items:\n        - key: string\n\n```\n\n### 端口和IP\n\n和docker的内网环境类似，k8s也具有集群内部网络和外部网络.\n\n#### 1. nodePort\n\n外部流量访问k8s集群中service入口的一种方式（另一种方式是LoadBalancer），即nodeIP:nodePort是提供给外部流量访问k8s集群中service的入口。\n\n比如外部用户要访问k8s集群中的一个Web应用，那么我们可以配置对应service的**type=NodePort**，nodePort=30001。其他用户就可以通过浏览器http://node:30001访问到该web服务。\n\n而数据库等服务可能不需要被外界访问，只需被内部服务访问即可，那么我们就不必设置service的NodePort。\n\n\n\n#### 2. port\nk8s集群内部服务之间访问**service**的入口。即**clusterIP:port**是service暴露在clusterIP上的端口。\n\n- mysql容器暴露了3306端口（参考DockerFile），集群内其他容器通过33306端口访问mysql服务，但是**外部流量不能访问mysql服务**，因为mysql服务没有配置NodePort。对应的service.yaml如下：\n\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n name: mysql-service\nspec:\n ports:\n - port: 33306\n   targetPort: 3306\n selector:\n  name: mysql-pod\n```\n\n\n\n#### 3. targetPort\n\n容器的端口（最终的流量端口）。targetPort是pod上的端口，从port和nodePort上来的流量，经过kube-proxy流入到后端pod的targetPort上，最后进入容器。\n\n与**制作容器时暴露的端口一致**（使用DockerFile中的**EXPOSE**），例如官方的nginx（参考DockerFile）暴露80端口。 对应的service.yaml如下：\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n name: nginx-service\nspec:\n type: NodePort         // 有配置NodePort，外部流量可访问k8s中的服务\n ports:\n - port: 30080          // 服务访问端口\n   targetPort: 80       // 容器端口\n   nodePort: 30001      // NodePort\n selector:\n  name: nginx-pod\n```\n\n总的来说\n\n- port和nodePort都是service的端口，前者暴露给k8s集群内部服务访问，后者暴露给k8s集群外部流量访问。\n- 从上两个端口过来的数据都需要经过反向代理kube-proxy，流入后端pod的targetPort上，最后到达pod内的容器。","tags":["K8S"],"categories":["服务"]}]